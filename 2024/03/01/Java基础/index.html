<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础 | L1n</title><meta name="author" content="楞"><meta name="copyright" content="楞"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Java概述1、JVM、JRE和JDK的关系​	JVM 是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。 ​	JRE 包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包 ​	JDK">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://example.com/2024/03/01/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="L1n">
<meta property="og:description" content="一、Java概述1、JVM、JRE和JDK的关系​	JVM 是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。 ​	JRE 包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包 ​	JDK">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/JavaSE_cover.jpg">
<meta property="article:published_time" content="2024-03-01T07:26:42.000Z">
<meta property="article:modified_time" content="2024-04-25T06:24:30.915Z">
<meta property="article:author" content="楞">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/JavaSE_cover.jpg"><link rel="shortcut icon" href="/img/lh.png"><link rel="canonical" href="http://example.com/2024/03/01/Java%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-25 14:24:30'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/JavaSE_top.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="L1n"><span class="site-name">L1n</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-01T07:26:42.000Z" title="发表于 2024-03-01 15:26:42">2024-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-25T06:24:30.915Z" title="更新于 2024-04-25 14:24:30">2024-04-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">35.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>116分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、Java概述"><a href="#一、Java概述" class="headerlink" title="一、Java概述"></a>一、Java概述</h2><h3 id="1、JVM、JRE和JDK的关系"><a href="#1、JVM、JRE和JDK的关系" class="headerlink" title="1、JVM、JRE和JDK的关系"></a>1、JVM、JRE和JDK的关系</h3><p>​	<strong>JVM</strong></p>
<p>是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p>
<p>​	<strong>JRE</strong></p>
<p>包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p>
<p>​	<strong>JDK</strong></p>
<p>是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
<h3 id="2、什么是跨平台性？原理是什么"><a href="#2、什么是跨平台性？原理是什么" class="headerlink" title="2、什么是跨平台性？原理是什么"></a>2、什么是跨平台性？原理是什么</h3><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p>
<p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p>
<h3 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h3><p>简单易学（Java语言的语法与C语言和C++语言很接近）</p>
<p>面向对象（封装，继承，多态）</p>
<p>平台无关性（Java虚拟机实现平台无关性）</p>
<p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</p>
<p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</p>
<p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</p>
<h3 id="3、什么是字节码？采用字节码的最大好处是什么"><a href="#3、什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="3、什么是字节码？采用字节码的最大好处是什么"></a>3、什么是字节码？采用字节码的最大好处是什么</h3><p><strong>字节码：</strong>Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<h3 id="4、Java和C-的区别"><a href="#4、Java和C-的区别" class="headerlink" title="4、Java和C++的区别"></a>4、Java和C++的区别</h3><ul>
<li><p>都是面向对象的语言，都支持封装、继承和多态</p>
</li>
<li><p>Java不提供指针来直接访问内存，程序内存更加安全</p>
</li>
<li><p>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</p>
</li>
<li><p>Java有自动内存管理机制，不需要程序员手动释放无用内存</p>
</li>
</ul>
<h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h2><h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3><h4 id="1-Java有哪些数据类型"><a href="#1-Java有哪些数据类型" class="headerlink" title="1.Java有哪些数据类型"></a>1.Java有哪些数据类型</h4><ul>
<li>基本数据类型<ul>
<li>数值型<ul>
<li>整数类型(byte,short,int,long)</li>
<li>浮点类型(float,double)</li>
</ul>
</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="/.com//image-20240119173941173.png" alt="image-20240119173941173"></p>
<h4 id="2、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#2、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上"></a>2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h4><p>​	在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p>
<h3 id="2、编码"><a href="#2、编码" class="headerlink" title="2、编码"></a>2、编码</h3><h4 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h4><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p>
<h3 id="3、注释"><a href="#3、注释" class="headerlink" title="3、注释"></a>3、注释</h3><ul>
<li>单行注释<br>格式： &#x2F;&#x2F; 注释文字</li>
<li>多行注释<br>格式： &#x2F;* 注释文字 *&#x2F;</li>
<li>文档注释<br>格式：&#x2F;** 注释文字 *&#x2F;</li>
</ul>
<h3 id="4、访问修饰符"><a href="#4、访问修饰符" class="headerlink" title="4、访问修饰符"></a>4、访问修饰符</h3><p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。<br>public : 对所有类可见。使用对象：类、接口、变量、方法</p>
<p><img src="/img/loading.gif" data-original="/.com//image-20240119174842955.png" alt="image-20240119174842955"></p>
<h3 id="5、运算符"><a href="#5、运算符" class="headerlink" title="5、运算符"></a>5、运算符</h3><h4 id="和-的区别"><a href="#和-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h4><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p>
<p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p>
<p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h3 id="6、关键字"><a href="#6、关键字" class="headerlink" title="6、关键字"></a>6、关键字</h3><h4 id="1-Java-有没有-goto"><a href="#1-Java-有没有-goto" class="headerlink" title="1. Java 有没有 goto"></a>1. Java 有没有 goto</h4><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p>
<h4 id="2-final-有什么用？"><a href="#2-final-有什么用？" class="headerlink" title="2. final 有什么用？"></a>2. final 有什么用？</h4><p>用于修饰类、属性和方法；</p>
<ul>
<li>被final修饰的类不可以被继承</li>
<li>被final修饰的方法不可以被重写</li>
<li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li>
</ul>
<h4 id="3-final-finally-finalize区别"><a href="#3-final-finally-finalize区别" class="headerlink" title="3.final finally finalize区别"></a>3.final finally finalize区别</h4><p>final：可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</p>
<p>finally：一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</p>
<p>finalize：是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</p>
<h4 id="4-this关键字的用法"><a href="#4-this关键字的用法" class="headerlink" title="4. this关键字的用法"></a>4. this关键字的用法</h4><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p>
<p><strong>this的用法在java中大体可以分为3种：</strong></p>
<p>①. 普通的直接引用，this相当于是指向当前对象本身。</p>
<p>②. 形参与成员名字重名，用this来区分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③. 引用本类的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-super关键字的用法"><a href="#5-super关键字的用法" class="headerlink" title="5. super关键字的用法"></a>5. super关键字的用法</h4><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p>
<p>super也有三种用法：</p>
<p>①. 普通的直接引用</p>
<p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p>
<p>②. 子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p>
<p>③. 引用父类构造函数</p>
<ul>
<li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li>
<li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li>
</ul>
<h4 id="6-this与super的区别"><a href="#6-this与super的区别" class="headerlink" title="6. this与super的区别"></a>6. this与super的区别</h4><p><img src="/img/loading.gif" data-original="/.com//image-20240119180341803.png" alt="image-20240119180341803"></p>
<h4 id="7-static存在的主要意义"><a href="#7-static存在的主要意义" class="headerlink" title="7. static存在的主要意义"></a>7. static存在的主要意义</h4><p><img src="/img/loading.gif" data-original="/.com//image-20240119180404935.png" alt="image-20240119180404935"></p>
<h4 id="8-static的独特之处"><a href="#8-static的独特之处" class="headerlink" title="8. static的独特之处"></a>8. static的独特之处</h4><ul>
<li>被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</li>
</ul>
<h4 id="9-static应用场景"><a href="#9-static应用场景" class="headerlink" title="9. static应用场景"></a>9. static应用场景</h4><p>因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。</p>
<p>因此比较常见的static应用场景有：</p>
<ul>
<li>修饰成员变量</li>
<li>修饰成员方法</li>
<li>静态代码块</li>
<li>修饰类【只能修饰内部类也就是静态内部类】</li>
<li>静态导包</li>
</ul>
<h4 id="10-static注意事项"><a href="#10-static注意事项" class="headerlink" title="10. static注意事项"></a>10. static注意事项</h4><ol>
<li>静态只能访问静态。</li>
<li>非静态既可以访问非静态的，也可以访问静态的。</li>
</ol>
<h3 id="7、流程控制语句"><a href="#7、流程控制语句" class="headerlink" title="7、流程控制语句"></a>7、流程控制语句</h3><h4 id="1、break-continue-return-的区别及作用"><a href="#1、break-continue-return-的区别及作用" class="headerlink" title="1、break ,continue ,return 的区别及作用"></a>1、break ,continue ,return 的区别及作用</h4><p><strong>break</strong> 跳出总上一层循环，不再执行循环(结束当前的循环体)</p>
<p><strong>continue</strong> 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p>
<p><strong>return</strong> 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p>
<h4 id="2-在-Java-中，如何跳出当前的多重嵌套循环"><a href="#2-在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="2. 在 Java 中，如何跳出当前的多重嵌套循环"></a>2. 在 Java 中，如何跳出当前的多重嵌套循环</h4><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ok:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;,j=&quot;</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span> ok;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h2><h3 id="1、面向对象概述"><a href="#1、面向对象概述" class="headerlink" title="1、面向对象概述"></a>1、面向对象概述</h3><h5 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h5><p><strong>面向过程：</strong></p>
<p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。</p>
<p>缺点：没有面向对象易维护、易复用、易扩展</p>
<p><strong>面向对象：</strong></p>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p>
<p>缺点：性能比面向过程低</p>
<p><strong>面向过程是具体化的</strong>，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p>
<p><strong>面向对象是模型化的</strong>，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p>
<p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p>
<h3 id="2、面向对象三大特性"><a href="#2、面向对象三大特性" class="headerlink" title="2、面向对象三大特性"></a>2、面向对象三大特性</h3><h4 id="1-面向对象的特征有哪些方面"><a href="#1-面向对象的特征有哪些方面" class="headerlink" title="1. 面向对象的特征有哪些方面"></a>1. 面向对象的特征有哪些方面</h4><h5 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a><strong>抽象</strong></h5><p>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h5><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h5><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p>关于继承如下 3 点请记住：</p>
<ul>
<li><p>子类拥有父类非 private 的属性和方法。</p>
</li>
<li><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li><p>子类可以用自己的方式实现父类的方法。（以后介绍）。</p>
</li>
</ul>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h5><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p><strong>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</strong></p>
<p><strong>其中Java 面向对象编程三大特性：封装 继承 多态</strong></p>
<p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），</p>
<p>方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p>
<ul>
<li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li>
<li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li>
</ul>
<h4 id="2-Java语言是如何实现多态的？"><a href="#2-Java语言是如何实现多态的？" class="headerlink" title="2. Java语言是如何实现多态的？"></a>2. Java语言是如何实现多态的？</h4><h5 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h5><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p>
<p>继承：在多态中必须存在有继承关系的子类和父类。</p>
<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>
<p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<h4 id="3-面向对象五大基本原则是什么（可选）"><a href="#3-面向对象五大基本原则是什么（可选）" class="headerlink" title="3. 面向对象五大基本原则是什么（可选）"></a>3. 面向对象五大基本原则是什么（可选）</h4><ul>
<li><p>单一职责原则SRP(Single Responsibility Principle)</p>
</li>
<li><p>开放封闭原则OCP(Open－Close Principle)</p>
</li>
<li><p>里式替换原则LSP(the Liskov Substitution Principle LSP)</p>
</li>
<li><p>依赖倒置原则DIP(the Dependency Inversion Principle DIP)</p>
</li>
<li><p>接口分离原则ISP(the Interface Segregation Principle ISP)</p>
</li>
</ul>
<h3 id="3、类与接口"><a href="#3、类与接口" class="headerlink" title="3、类与接口"></a>3、类与接口</h3><h4 id="1-抽象类和接口的对比"><a href="#1-抽象类和接口的对比" class="headerlink" title="1.抽象类和接口的对比"></a><strong>1.抽象类和接口的对比</strong></h4><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p>
<p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p><strong>相同点</strong></p>
<p>接口和抽象类都不能实例化</p>
<p>都位于继承的顶端，用于被其他实现或继承</p>
<p>都包含抽象方法，其子类都必须覆写这些抽象方法</p>
<p><strong>不同点</strong></p>
<p><img src="/img/loading.gif" data-original="/.com//image-20240119181802331.png" alt="image-20240119181802331"></p>
<p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>
<ul>
<li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li>
<li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li>
</ul>
<h4 id="2-普通类和抽象类有哪些区别？"><a href="#2-普通类和抽象类有哪些区别？" class="headerlink" title="2. 普通类和抽象类有哪些区别？"></a>2. 普通类和抽象类有哪些区别？</h4><ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<h4 id="3-抽象类能使用-final-修饰吗？"><a href="#3-抽象类能使用-final-修饰吗？" class="headerlink" title="3. 抽象类能使用 final 修饰吗？"></a>3. 抽象类能使用 final 修饰吗？</h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p>
<h4 id="4-创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#4-创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="4. 创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>4. 创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4><p>new关键字</p>
<p>new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。 </p>
<h3 id="4、变量与方法"><a href="#4、变量与方法" class="headerlink" title="4、变量与方法"></a>4、变量与方法</h3><h4 id="1-成员变量与局部变量的区别有哪些"><a href="#1-成员变量与局部变量的区别有哪些" class="headerlink" title="1. 成员变量与局部变量的区别有哪些"></a>1. 成员变量与局部变量的区别有哪些</h4><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</p>
<p>成员变量：方法外部，类内部定义的变量</p>
<p>局部变量：类的方法中的变量。</p>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>成员变量：针对整个类有效。<br>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p>
<h5 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h5><p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。<br>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</p>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：当方法调用完，或者语句结束后，就自动释放。</p>
<h5 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h5><p>成员变量：有默认初始值。</p>
<p>局部变量：没有默认初始值，使用前必须赋值。</p>
<h5 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h5><p>在使用变量时需要遵循的原则为：就近原则<br>首先在局部范围找，有就使用；接着在成员位置找。</p>
<h4 id="2-在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#2-在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="2. 在Java中定义一个不做事且没有参数的构造方法的作用"></a>2. 在Java中定义一个不做事且没有参数的构造方法的作用</h4><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。</p>
<h4 id="3-在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#3-在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="3. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>3. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h4><p>帮助子类做初始化工作。</p>
<h4 id="4-一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#4-一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="4. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>4. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h4><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h4 id="5-构造方法有哪些特性？"><a href="#5-构造方法有哪些特性？" class="headerlink" title="5. 构造方法有哪些特性？"></a>5. 构造方法有哪些特性？</h4><p>名字与类名相同；</p>
<p>没有返回值，但不能用void声明构造函数；</p>
<p>生成类的对象时自动执行，无需调用。</p>
<h4 id="6-静态变量和实例变量区别"><a href="#6-静态变量和实例变量区别" class="headerlink" title="6.静态变量和实例变量区别"></a>6.静态变量和实例变量区别</h4><p><strong>静态变量</strong>： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</p>
<p><strong>实例变量</strong>： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p>
<h3 id="5、内部类"><a href="#5、内部类" class="headerlink" title="5、内部类"></a>5、内部类</h3><h4 id="1-什么是内部类？"><a href="#1-什么是内部类？" class="headerlink" title="1. 什么是内部类？"></a>1. 什么是内部类？</h4><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。</p>
<h4 id="2-内部类的分类有哪些"><a href="#2-内部类的分类有哪些" class="headerlink" title="2. 内部类的分类有哪些"></a>2. 内部类的分类有哪些</h4><p>内部类可以分为四种：<strong>成员内部类</strong>、<strong>局部内部类</strong>、<strong>匿名内部类</strong>和<strong>静态内部类</strong>。</p>
<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>定义在类内部的静态类，就是静态内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static variable:&quot;</span> + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，<code>new 外部类.静态内部类()</code>，如下：、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>

<h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;visit outer static  variable:&quot;</span> + radius);</span><br><span class="line">           System.out.println(<span class="string">&quot;visit outer   variable:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式<code>外部类实例.new 内部类()</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>

<h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><p>定义在方法中的内部类，就是局部内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">out_a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">STATIC_b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFunctionClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inner_c</span> <span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span>  <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStaticFunctionClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span></span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span>  <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法</p>
<p>定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，<code>new 内部类()</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStaticFunctionClass</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匿名内部类&quot;</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//匿名内部类必须继承或实现一个已有的接口 </span></span><br><span class="line"> <span class="keyword">interface</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了没有名字，匿名内部类还有以下特点：</p>
<ul>
<li><p>匿名内部类必须继承一个抽象类或者实现一个接口。</p>
</li>
<li><p>匿名内部类不能定义任何静态成员和静态方法。</p>
</li>
<li><p>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</p>
</li>
<li><p>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
</li>
</ul>
<p>匿名内部类创建方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类/接口&#123; </span><br><span class="line">  <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-内部类的优点"><a href="#3-内部类的优点" class="headerlink" title="3. 内部类的优点"></a>3. 内部类的优点</h4><p>我们为什么要使用内部类呢？因为它有以下优点：</p>
<ul>
<li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li>
<li>内部类不为同一包的其他类所见，具有很好的封装性；</li>
<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li>
<li>匿名内部类可以很方便的定义回调。</li>
</ul>
<h4 id="4-内部类有哪些应用场景"><a href="#4-内部类有哪些应用场景" class="headerlink" title="4. 内部类有哪些应用场景"></a>4. 内部类有哪些应用场景</h4><ol>
<li>一些多算法场合</li>
<li>解决一些非面向对象的语句块。</li>
<li>适当使用内部类，使得代码更加灵活和富有扩展性。</li>
<li>当某个类除了它的外部类，不再被其他的类使用时。</li>
</ol>
<h4 id="5-局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#5-局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="5. 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>5. 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><p>public class Outer {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">outMethod</span><span class="params">()</span>&#123;</span><br><span class="line">    	<span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">    	<span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        	<span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            	System.out.println(a);</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。</p>
<p>而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。</p>
<p>加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;局部变量：&quot;</span> + age);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类变量：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类变量：&quot;</span> + Outer.<span class="built_in">this</span>.age);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">   		in.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部变量：<span class="number">14</span></span><br><span class="line">内部类变量：<span class="number">13</span></span><br><span class="line">外部类变量：<span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="6、重写与重载"><a href="#6、重写与重载" class="headerlink" title="6、重写与重载"></a>6、重写与重载</h3><h4 id="1-构造器（constructor）是否可被重写（override）"><a href="#1-构造器（constructor）是否可被重写（override）" class="headerlink" title="1. 构造器（constructor）是否可被重写（override）"></a>1. 构造器（constructor）是否可被重写（override）</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h4 id="2-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#2-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="2. 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>2. 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<p><strong>重载</strong>：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p>
<p><strong>重写</strong>：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</p>
<h3 id="7、对象相等判断"><a href="#7、对象相等判断" class="headerlink" title="7、对象相等判断"></a>7、对象相等判断</h3><h4 id="1-和-equals-的区别是什么"><a href="#1-和-equals-的区别是什么" class="headerlink" title="1. &#x3D;&#x3D; 和 equals 的区别是什么"></a>1. &#x3D;&#x3D; 和 equals 的区别是什么</h4><p><strong>&#x3D;&#x3D; :</strong> 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址)</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。</p>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。<br>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</p>
<h4 id="2-hashCode-与-equals-重要"><a href="#2-hashCode-与-equals-重要" class="headerlink" title="2. hashCode 与 equals (重要)"></a>2. hashCode 与 equals (重要)</h4><p>HashSet如何检查重复</p>
<p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</p>
<p>hashCode和equals方法的关系</p>
<p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>
<p><strong>hashCode()介绍</strong></p>
<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p>
<p><strong>hashCode()与equals()的相关规定</strong></p>
<p>如果两个对象相等，则hashcode一定也是相同的</p>
<p>两个对象相等，对两个对象分别调用equals方法都返回true</p>
<p>两个对象有相同的hashcode值，它们也不一定是相等的</p>
<p><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></p>
<p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
<h3 id="8、值传递"><a href="#8、值传递" class="headerlink" title="8、值传递"></a>8、值传递</h3><h5 id="1-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#1-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="1.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>1.<strong>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</strong></h5><p>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p>
<h5 id="2-为什么-Java-中只有值传递"><a href="#2-为什么-Java-中只有值传递" class="headerlink" title="2.为什么 Java 中只有值传递"></a>2.<strong>为什么 Java 中只有值传递</strong></h5><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>
<p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p>
<p><strong>例1：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    swap(num1, num2);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 20</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//Snipaste_2024-02-02_15-31-57.jpg"></p>
<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 例2.</strong></p>
<p><strong>例2：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//Snipaste_2024-02-02_15-33-41.jpg"></p>
<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>
<p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p>
<p><strong>例3：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Student x, Student y)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure>

<p>交换之前：</p>
<p><img src="/img/loading.gif" data-original="/.com//Snipaste_2024-02-02_15-37-29.jpg"></p>
<p>交换之后：</p>
<p><img src="/img/loading.gif" data-original="/.com//Snipaste_2024-02-02_15-37-35.jpg"></p>
<p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p>
<p>下面再总结一下Java中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<h5 id="3-值传递和引用传递有什么区别"><a href="#3-值传递和引用传递有什么区别" class="headerlink" title="3.值传递和引用传递有什么区别"></a>3.值传递和引用传递有什么区别</h5><p><strong>值传递</strong>：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>
<p><strong>引用传递</strong>：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>
<p>Java基础知识点总结归纳，超级全面！（2021版）</p>
<p>Java程序员-张凯</p>
<p>于 2021-05-03 12:28:26 发布</p>
<p>阅读量7.8w<br> 收藏 1.2k</p>
<p>点赞数 270<br>文章标签： Java基础知识点 java Java基础知识点整理 Java基础知识点总结归纳<br>版权<br>凯哥今天看了网上好多关于Java基础知识点汇总的博客，but，感觉都不尽如人意，要么不全面，要么不准确，要么排版太乱了！</p>
<p>所以今天花了一天时间整理了一份Java基础知识点总结归纳，超级全面！希望对大家有帮助哈~</p>
<p>由于本文篇幅过长，博主为了方便大家阅读和收藏，特意将本文转成了一份PDF版的文档。</p>
<p>需要PDF版的朋友可以关注微信公众号：Java团长，发送“ 基础知识 ”即可获取哈~</p>
<p>一、Java概述<br>1、何为编程<br>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。</p>
<p>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</p>
<p>2、什么是Java<br>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p>
<p>3、jdk1.5之后的三大版本<br>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）<br>Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</p>
<p>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）<br>Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</p>
<p>Java ME（J2ME，Java 2 Platform Micro Edition，微型版）<br>Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</p>
<p>4、JVM、JRE和JDK的关系<br>JVM<br>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p>
<p>JRE<br>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p>
<p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
<p>JDK<br>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
<p>JVM&amp;JRE&amp;JDK关系图：</p>
<p>5、什么是跨平台性？原理是什么<br>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p>
<p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p>
<p>6、Java语言有哪些特点<br>简单易学（Java语言的语法与C语言和C++语言很接近）</p>
<p>面向对象（封装，继承，多态）</p>
<p>平台无关性（Java虚拟机实现平台无关性）</p>
<p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</p>
<p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</p>
<p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</p>
<p>安全性</p>
<p>7、什么是字节码？采用字节码的最大好处是什么<br>字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p>采用字节码的好处：</p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<p>先看下java中的编译器和解释器：</p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</p>
<p>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。</p>
<p>8、什么是Java程序的主类？应用程序和小程序的主类有何不同？<br>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p>
<p>9、Java应用程序与小程序之间有那些差别？<br>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p>
<p>10、Java和C++的区别<br>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p>
<p>都是面向对象的语言，都支持封装、继承和多态<br>Java不提供指针来直接访问内存，程序内存更加安全<br>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。<br>Java有自动内存管理机制，不需要程序员手动释放无用内存<br>11、Oracle JDK 和 OpenJDK 的对比<br>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；<br>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；<br>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；<br>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；<br>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；<br>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。<br>二、基础语法<br>1、数据类型</p>
<ol>
<li>Java有哪些数据类型<br>定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</li>
</ol>
<p>分类</p>
<p>基本数据类型<br>数值型<br>整数类型(byte,short,int,long)<br>浮点类型(float,double)<br>字符型(char)<br>布尔型(boolean)<br>引用数据类型<br>类(class)<br>接口(interface)<br>数组([])<br>Java基本数据类型图</p>
<ol start="2">
<li><p>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上<br>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p>
</li>
<li><p>用最有效率的方法计算 2 乘以 8<br>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p>
</li>
<li><p>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少<br>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p>
</li>
<li><p>float f&#x3D;3.4;是否正确<br>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。</p>
</li>
<li><p>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗<br>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p>
</li>
</ol>
<p>而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1 + 1);其中有隐含的强制类型转换。</p>
<p>2、编码<br>Java语言采用何种编码方案？有何特点？<br>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p>
<p>3、注释</p>
<ol>
<li>什么Java注释<br>定义：用于解释说明程序的文字</li>
</ol>
<p>分类</p>
<p>单行注释<br>格式： &#x2F;&#x2F; 注释文字<br>多行注释<br>格式： &#x2F;* 注释文字 <em>&#x2F;<br>文档注释<br>格式：&#x2F;</em>* 注释文字 *&#x2F;<br>作用</p>
<p>在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</p>
<p>注意事项：多行和文档注释都不能嵌套使用。</p>
<p>4、访问修饰符</p>
<ol>
<li>访问修饰符 public,private,protected,以及不写（默认）时的区别<br>定义：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</li>
</ol>
<p>分类</p>
<p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。<br>public : 对所有类可见。使用对象：类、接口、变量、方法</p>
<p>访问修饰符图</p>
<p>5、运算符<br>&amp;和&amp;&amp;的区别<br>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p>
<p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p>
<p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<p>6、关键字</p>
<ol>
<li><p>Java 有没有 goto<br>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p>
</li>
<li><p>final 有什么用？<br>用于修饰类、属性和方法；</p>
</li>
</ol>
<p>被final修饰的类不可以被继承<br>被final修饰的方法不可以被重写<br>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</p>
<ol start="3">
<li>final finally finalize区别<br>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。<br>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。<br>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</li>
<li>this关键字的用法<br>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</li>
</ol>
<p>this的用法在java中大体可以分为3种：</p>
<p>①. 普通的直接引用，this相当于是指向当前对象本身。</p>
<p>②. 形参与成员名字重名，用this来区分：</p>
<p>public Person(String name, int age) {<br>    this.name &#x3D; name;<br>    this.age &#x3D; age;<br>}<br>③. 引用本类的构造函数</p>
<p>class Person{<br>    private String name;<br>    private int age;</p>
<pre><code>public Person() &#123;
&#125;
 
public Person(String name) &#123;
    this.name = name;
&#125;
public Person(String name, int age) &#123;
    this(name);
    this.age = age;
&#125;
</code></pre>
<p>}</p>
<ol start="5">
<li>super关键字的用法<br>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</li>
</ol>
<p>super也有三种用法：</p>
<p>①. 普通的直接引用</p>
<p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p>
<p>②. 子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p>
<p>class Person{<br>    protected String name;</p>
<pre><code>public Person(String name) &#123;
    this.name = name;
&#125;
</code></pre>
<p>}</p>
<p>class Student extends Person{<br>    private String name;</p>
<pre><code>public Student(String name, String name1) &#123;
    super(name);
    this.name = name1;
&#125;
 
public void getInfo()&#123;
    System.out.println(this.name);      //Child
    System.out.println(super.name);     //Father
&#125;
</code></pre>
<p>}</p>
<p>public class Test {<br>    public static void main(String[] args) {<br>       Student s1 &#x3D; new Student(“Father”,”Child”);<br>       s1.getInfo();</p>
<pre><code>&#125;
</code></pre>
<p>}</p>
<p>③. 引用父类构造函数</p>
<p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。<br>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p>
<ol start="6">
<li>this与super的区别<br>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）<br>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）<br>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。<br>super()和this()均需放在构造方法内第一行。<br>尽管可以用this调用一个构造器，但却不能调用两个。<br>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。<br>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。<br>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li>
<li>static存在的主要意义<br>static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！</li>
</ol>
<p>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p>
<p>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p>
<ol start="8">
<li>static的独特之处<br>被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。<br>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</li>
</ol>
<p>在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。<br>static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！<br>被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p>
<ol start="9">
<li>static应用场景<br>因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。</li>
</ol>
<p>因此比较常见的static应用场景有：</p>
<p>修饰成员变量<br>修饰成员方法<br>静态代码块<br>修饰类【只能修饰内部类也就是静态内部类】<br>静态导包</p>
<ol start="10">
<li>static注意事项<br>静态只能访问静态。<br>非静态既可以访问非静态的，也可以访问静态的。<br>7、流程控制语句</li>
<li>break ,continue ,return 的区别及作用<br>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</li>
</ol>
<p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p>
<p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p>
<ol start="2">
<li>在 Java 中，如何跳出当前的多重嵌套循环<br>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</li>
</ol>
<p>public static void main(String[] args) {<br>    ok:<br>    for (int i &#x3D; 0; i &lt; 10; i++) {<br>        for (int j &#x3D; 0; j &lt; 10; j++) {<br>            System.out.println(“i&#x3D;” + i + “,j&#x3D;” + j);<br>            if (j &#x3D;&#x3D; 5) {<br>                break ok;<br>            }</p>
<pre><code>    &#125;
&#125;
</code></pre>
<p>}<br>三、面向对象<br>1、面向对象概述<br>面向对象和面向过程的区别<br>面向过程：</p>
<p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。</p>
<p>缺点：没有面向对象易维护、易复用、易扩展</p>
<p>面向对象：</p>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p>
<p>缺点：性能比面向过程低</p>
<p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p>
<p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p>
<p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p>
<p>2、面向对象三大特性</p>
<ol>
<li>面向对象的特征有哪些方面<br>面向对象的特征主要有以下几个方面：</li>
</ol>
<p>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<p>封装</p>
<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<p>继承</p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p>关于继承如下 3 点请记住：</p>
<p>子类拥有父类非 private 的属性和方法。<br>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>子类可以用自己的方式实现父类的方法。（以后介绍）。<br>多态</p>
<p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<p>其中Java 面向对象编程三大特性：封装 继承 多态</p>
<p>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p>
<p>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</p>
<p>关于继承如下 3 点请记住：</p>
<p>子类拥有父类非 private 的属性和方法。</p>
<p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
<p>子类可以用自己的方式实现父类的方法。</p>
<p>多态性：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p>
<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p>
<p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p>
<p>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；<br>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
<ol start="2">
<li>什么是多态机制？Java语言是如何实现多态的？<br>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</li>
</ol>
<p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p>
<p>多态的实现</p>
<p>Java实现多态有三个必要条件：继承、重写、向上转型。</p>
<p>继承：在多态中必须存在有继承关系的子类和父类。</p>
<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>
<p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>
<p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p>
<ol start="3">
<li>面向对象五大基本原则是什么（可选）<br>单一职责原则SRP(Single Responsibility Principle)<br>类的功能要单一，不能包罗万象，跟杂货铺似的。</li>
</ol>
<p>开放封闭原则OCP(Open－Close Principle)<br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</p>
<p>里式替换原则LSP(the Liskov Substitution Principle LSP)<br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</p>
<p>依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</p>
<p>接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p>
<p>3、类与接口</p>
<ol>
<li>抽象类和接口的对比<br>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</li>
</ol>
<p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p>相同点</p>
<p>接口和抽象类都不能实例化<br>都位于继承的顶端，用于被其他实现或继承<br>都包含抽象方法，其子类都必须覆写这些抽象方法</p>
<p>不同点</p>
<p>备注：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p>
<p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p>
<p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>
<p>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。<br>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</p>
<ol start="2">
<li><p>普通类和抽象类有哪些区别？<br>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类不能直接实例化，普通类可以直接实例化。</p>
</li>
<li><p>抽象类能使用 final 修饰吗？<br>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p>
</li>
<li><p>创建一个对象用什么关键字？对象实例与对象引用有何不同？<br>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</p>
</li>
</ol>
<p>4、变量与方法</p>
<ol>
<li>成员变量与局部变量的区别有哪些<br>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</li>
</ol>
<p>成员变量：方法外部，类内部定义的变量</p>
<p>局部变量：类的方法中的变量。</p>
<p>成员变量和局部变量的区别</p>
<p>作用域</p>
<p>成员变量：针对整个类有效。<br>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p>
<p>存储位置</p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。<br>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</p>
<p>生命周期</p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：当方法调用完，或者语句结束后，就自动释放。</p>
<p>初始值</p>
<p>成员变量：有默认初始值。</p>
<p>局部变量：没有默认初始值，使用前必须赋值。</p>
<p>使用原则</p>
<p>在使用变量时需要遵循的原则为：就近原则<br>首先在局部范围找，有就使用；接着在成员位置找。</p>
<ol start="2">
<li><p>在Java中定义一个不做事且没有参数的构造方法的作用<br>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
</li>
<li><p>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？<br>帮助子类做初始化工作。</p>
</li>
<li><p>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？<br>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
</li>
<li><p>构造方法有哪些特性？<br>名字与类名相同；</p>
</li>
</ol>
<p>没有返回值，但不能用void声明构造函数；</p>
<p>生成类的对象时自动执行，无需调用。</p>
<ol start="6">
<li>静态变量和实例变量区别<br>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</li>
</ol>
<p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p>
<ol start="7">
<li>静态变量与普通变量区别<br>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li>
</ol>
<p>还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</p>
<ol start="8">
<li>静态方法和实例方法有何不同？<br>静态方法和实例方法的区别主要体现在两个方面：</li>
</ol>
<p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。<br>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</p>
<ol start="9">
<li><p>在一个静态方法内调用一个非静态成员为什么是非法的？<br>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
</li>
<li><p>什么是方法的返回值？返回值的作用是什么？<br>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p>
</li>
</ol>
<p>5、内部类</p>
<ol>
<li><p>什么是内部类？<br>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。</p>
</li>
<li><p>内部类的分类有哪些<br>内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p>
</li>
</ol>
<p>静态内部类</p>
<p>定义在类内部的静态类，就是静态内部类。</p>
<p>public class Outer {</p>
<pre><code>private static int radius = 1;
 
static class StaticInner &#123;
    public void visit() &#123;
        System.out.println(&quot;visit outer static  variable:&quot; + radius);
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下：</p>
<p>Outer.StaticInner inner &#x3D; new Outer.StaticInner();<br>inner.visit();<br>成员内部类</p>
<p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>
<p>public class Outer {</p>
<pre><code>private static  int radius = 1;
private int count =2;

 class Inner &#123;
    public void visit() &#123;
        System.out.println(&quot;visit outer static  variable:&quot; + radius);
        System.out.println(&quot;visit outer   variable:&quot; + count);
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下：</p>
<p>Outer outer &#x3D; new Outer();<br>Outer.Inner inner &#x3D; outer.new Inner();<br>inner.visit();<br>局部内部类</p>
<p>定义在方法中的内部类，就是局部内部类。</p>
<p>public class Outer {</p>
<pre><code>private  int out_a = 1;
private static int STATIC_b = 2;
 
public void testFunctionClass()&#123;
    int inner_c =3;
    class Inner &#123;
        private void fun()&#123;
            System.out.println(out_a);
            System.out.println(STATIC_b);
            System.out.println(inner_c);
        &#125;
    &#125;
    Inner  inner = new Inner();
    inner.fun();
&#125;
public static void testStaticFunctionClass()&#123;
    int d =3;
    class Inner &#123;
        private void fun()&#123;
            // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量
            System.out.println(STATIC_b);
            System.out.println(d);
        &#125;
    &#125;
    Inner  inner = new Inner();
    inner.fun();
&#125;
</code></pre>
<p>}<br>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()，如下：</p>
<p> public static void testStaticFunctionClass(){<br>    class Inner {<br>    }<br>    Inner  inner &#x3D; new Inner();<br> }<br>匿名内部类</p>
<p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<p>public class Outer {</p>
<pre><code>private void test(final int i) &#123;
    new Service() &#123;
        public void method() &#123;
            for (int j = 0; j &lt; i; j++) &#123;
                System.out.println(&quot;匿名内部类&quot; );
            &#125;
        &#125;
    &#125;.method();
&#125;
</code></pre>
<p> }<br> &#x2F;&#x2F;匿名内部类必须继承或实现一个已有的接口<br> interface Service{<br>    void method();<br>}<br>除了没有名字，匿名内部类还有以下特点：</p>
<p>匿名内部类必须继承一个抽象类或者实现一个接口。<br>匿名内部类不能定义任何静态成员和静态方法。<br>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。<br>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。<br>匿名内部类创建方式：</p>
<p>new 类&#x2F;接口{<br>  &#x2F;&#x2F;匿名内部类实现部分<br>}</p>
<ol start="3">
<li>内部类的优点<br>我们为什么要使用内部类呢？因为它有以下优点：</li>
</ol>
<p>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！<br>内部类不为同一包的其他类所见，具有很好的封装性；<br>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。<br>匿名内部类可以很方便的定义回调。</p>
<ol start="4">
<li>内部类有哪些应用场景<br>一些多算法场合<br>解决一些非面向对象的语句块。<br>适当使用内部类，使得代码更加灵活和富有扩展性。<br>当某个类除了它的外部类，不再被其他的类使用时。</li>
<li>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？<br>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？</li>
</ol>
<p>先看这段代码：</p>
<p>public class Outer {</p>
<pre><code>void outMethod()&#123;
    final int a =10;
    class Inner &#123;
        void innerMethod()&#123;
            System.out.println(a);
        &#125;
 
    &#125;
&#125;
</code></pre>
<p>}<br>以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p>
<ol start="6">
<li><p>内部类相关，看程序说出运行结果<br>public class Outer {<br> private int age &#x3D; 12;</p>
<p> class Inner {<br> private int age &#x3D; 13;<br> public void print() {<br>     int age &#x3D; 14;<br>     System.out.println(“局部变量：” + age);<br>     System.out.println(“内部类变量：” + this.age);<br>     System.out.println(“外部类变量：” + Outer.this.age);<br> }<br> }</p>
<p> public static void main(String[] args) {<br> Outer.Inner in &#x3D; new Outer().new Inner();<br> in.print();<br> }</p>
</li>
</ol>
<p>}<br>运行结果：</p>
<p>局部变量：14<br>内部类变量：13<br>外部类变量：12<br>6、重写与重载</p>
<ol>
<li><p>构造器（constructor）是否可被重写（override）<br>构造器不能被继承，因此不能被重写，但可以被重载。</p>
</li>
<li><p>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？<br>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
</li>
</ol>
<p>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p>
<p>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</p>
<p>7、对象相等判断</p>
<ol>
<li>&#x3D;&#x3D; 和 equals 的区别是什么<br>&#x3D;&#x3D; : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址)</li>
</ol>
<p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。</p>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>
<p>举个例子：</p>
<p>public class test1 {<br>    public static void main(String[] args) {<br>        String a &#x3D; new String(“ab”); &#x2F;&#x2F; a 为一个引用<br>        String b &#x3D; new String(“ab”); &#x2F;&#x2F; b为另一个引用,对象的内容一样<br>        String aa &#x3D; “ab”; &#x2F;&#x2F; 放在常量池中<br>        String bb &#x3D; “ab”; &#x2F;&#x2F; 从常量池中查找<br>        if (aa &#x3D;&#x3D; bb) &#x2F;&#x2F; true<br>            System.out.println(“aa&#x3D;&#x3D;bb”);<br>        if (a &#x3D;&#x3D; b) &#x2F;&#x2F; false，非同一对象<br>            System.out.println(“a&#x3D;&#x3D;b”);<br>        if (a.equals(b)) &#x2F;&#x2F; true<br>            System.out.println(“aEQb”);<br>        if (42 &#x3D;&#x3D; 42.0) { &#x2F;&#x2F; true<br>            System.out.println(“true”);<br>        }<br>    }<br>}<br>说明：</p>
<p>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。<br>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</p>
<ol start="2">
<li>hashCode 与 equals (重要)<br>HashSet如何检查重复</li>
</ol>
<p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</p>
<p>hashCode和equals方法的关系</p>
<p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>
<p>hashCode()介绍</p>
<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<p>为什么要有 hashCode</p>
<p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p>hashCode()与equals()的相关规定</p>
<p>如果两个对象相等，则hashcode一定也是相同的</p>
<p>两个对象相等，对两个对象分别调用equals方法都返回true</p>
<p>两个对象有相同的hashcode值，它们也不一定是相等的</p>
<p>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</p>
<p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
<p>8、值传递</p>
<ol>
<li><p>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递<br>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p>
</li>
<li><p>为什么 Java 中只有值传递<br>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>
</li>
</ol>
<p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p>
<p>下面通过 3 个例子来给大家说明</p>
<p>example 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>



<pre><code>swap(num1, num2);
 
System.out.println(&quot;num1 = &quot; + num1);
System.out.println(&quot;num2 = &quot; + num2);
</code></pre>
<p>}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br></pre></td></tr></table></figure>

<p>}<br>结果：</p>
<p>a &#x3D; 20<br>b &#x3D; 10<br>num1 &#x3D; 10<br>num2 &#x3D; 20<br>解析：</p>
<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</p>
<p>example 2</p>
<pre><code>public static void main(String[] args) &#123;
    int[] arr = &#123; 1, 2, 3, 4, 5 &#125;;
    System.out.println(arr[0]);
    change(arr);
    System.out.println(arr[0]);
&#125;
 
public static void change(int[] array) &#123;
    // 将数组的第一个元素变为0
    array[0] = 0;
&#125;
</code></pre>
<p>结果：</p>
<p>1<br>0<br>解析：</p>
<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>
<p>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</p>
<p>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</p>
<p>example 3</p>
<p>public class Test {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">    Test.swap(s1, s2);</span><br><span class="line">    System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Student x, Student y)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>结果：</p>
<p>x:小李<br>y:小张<br>s1:小张<br>s2:小李<br>解析：</p>
<p>交换之前：</p>
<p>交换之后：</p>
<p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p>
<p>总结</p>
<p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p>
<p>下面再总结一下Java中方法参数的使用情况：</p>
<p>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》<br>一个方法可以改变一个对象参数的状态。<br>一个方法不能让对象参数引用一个新的对象。</p>
<ol start="3">
<li>值传递和引用传递有什么区别<br>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</li>
</ol>
<p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>
<h3 id="9、Java包"><a href="#9、Java包" class="headerlink" title="9、Java包"></a>9、Java包</h3><h5 id="1-JDK-中常用的包有哪些"><a href="#1-JDK-中常用的包有哪些" class="headerlink" title="1. JDK 中常用的包有哪些"></a>1. JDK 中常用的包有哪些</h5><ul>
<li>java.lang：这个是系统的基础类；</li>
<li>java.io：这里面是所有输入输出有关的类，比如文件操作等；</li>
<li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</li>
<li>java.net：这里面是与网络有关的类；</li>
<li>java.util：这个是系统辅助类，特别是集合类；</li>
<li>java.sql：这个是数据库操作的类。</li>
</ul>
<h5 id="2-import-java和javax有什么区别"><a href="#2-import-java和javax有什么区别" class="headerlink" title="2.import java和javax有什么区别"></a>2.import java和javax有什么区别</h5><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。</p>
<p>所以，实际上java和javax没有区别。这都是一个名字。</p>
<h2 id="四、IO流"><a href="#四、IO流" class="headerlink" title="四、IO流"></a>四、IO流</h2><h3 id="1、java-中-IO-流分为几种"><a href="#1、java-中-IO-流分为几种" class="headerlink" title="1、java 中 IO 流分为几种?"></a>1、java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<ul>
<li><p>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
</li>
<li><p>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
<p><img src="/img/loading.gif" data-original="/.com//aaaa.png" alt="aaaa"></p>
<p><img src="/img/loading.gif" data-original="/.com//aaaaaaaaaaaaaaa.png" alt="aaaaaaaaaaaaaaa"></p>
</li>
</ul>
<h3 id="2、Files的常用方法都有哪些？"><a href="#2、Files的常用方法都有哪些？" class="headerlink" title="2、Files的常用方法都有哪些？"></a>2、Files的常用方法都有哪些？</h3><ul>
<li>Files. exists()：检测文件路径是否存在。</li>
<li>Files. createFile()：创建文件。</li>
<li>Files. createDirectory()：创建文件夹。</li>
<li>Files. delete()：删除一个文件或目录。</li>
<li>Files. copy()：复制文件。</li>
<li>Files. move()：移动文件。</li>
<li>Files. size()：查看文件个数。</li>
<li>Files. read()：读取文件。</li>
<li>Files. write()：写入文件。</li>
</ul>
<h3 id="3、字节流和字符流的区别"><a href="#3、字节流和字符流的区别" class="headerlink" title="3、字节流和字符流的区别"></a>3、字节流和字符流的区别</h3><p>1.字节流读取的时候，读到一个字节就返回一个字节； 字符流使用了字节流读到一个或多个字节（中文对应的字节数是两个，在UTF-8码表中是3个字节）时。先去查指定的编码表，将查到的字符返回。<br>2.字节流可以处理所有类型数据，如：图片，MP3，AVI视频文件，而字符流只能处理字符数据。只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都用字节流。</p>
<h3 id="4、转换流"><a href="#4、转换流" class="headerlink" title="4、转换流"></a>4、转换流</h3><p>InputStreamReader 是字节流通向字符流的桥梁<br>OutputStreamWriter 是字符流通向字节流的桥梁<br>转换流可以将字节转成字符，原因在于，将获取到的字节通过查编码表获取到指定对应字符。<br>转换流的最强功能就是基于 字节流 + 编码表 。没有转换，没有字符流</p>
<h3 id="5、打印流"><a href="#5、打印流" class="headerlink" title="5、打印流"></a>5、打印流</h3><p>PrintWriter<br>PrintStream<br>注:<br>A:只操作目的地,不操作数据源<br>B:可以操作任意类型的数据<br>C:如果启用了自动刷新，在调用println(),printf(),format()方法的时候，能够换行并刷新<br>D:可以直接操作文件</p>
<h3 id="6、序列化流"><a href="#6、序列化流" class="headerlink" title="6、序列化流"></a>6、序列化流</h3><p>ObjectOutputStream序列化流<br>ObjectInputStream反序列化流<br>序列化：把对象作为一个整体按照流一样的方式传输或者存储。<br>反序列化：把网络中的流数据或者文件中的流数据还原成对象<br>主要方法有：<br>1.Object readObject();该方法抛出异常：ClassNotFountException。</p>
<ol start="2">
<li>void writeObject(Object)：被写入的对象必须实现一个接口：Serializable，否则就会抛出：NotSerializableException<br>3.如果实现了该接口，想解决黄线问题就生成一个随机的serialVersionUID号码</li>
</ol>
<p>7、综合小案例:  键盘录入数据保存到文件中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//创建键盘录入</span></span><br><span class="line">    InputStream is=System.in;</span><br><span class="line">    <span class="comment">//将字节流转换为字符流</span></span><br><span class="line">    InputStreamReader isr=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line">    <span class="comment">//高效字符流读取数据</span></span><br><span class="line">    BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">    <span class="comment">//打印流写入数据,第一个true表示如果文件中有内容就追加数据,第二个true表示启用自动刷新</span></span><br><span class="line">    PrintWriter pw=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="literal">true</span>),<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    String line=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;over&quot;</span>.equals(line))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//PrintWriter启用自动刷新</span></span><br><span class="line">        pw.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    pw.close();</span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="五、反射"><a href="#五、反射" class="headerlink" title="五、反射"></a>五、反射</h2><h3 id="1、什么是反射机制？"><a href="#1、什么是反射机制？" class="headerlink" title="1、什么是反射机制？"></a>1、什么是反射机制？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p><strong>静态编译和动态编译</strong></p>
<p><strong>静态编译：</strong>在编译时确定类型，绑定对象<br><strong>动态编译：</strong>运行时确定类型，绑定对象</p>
<h3 id="2、反射机制优缺点"><a href="#2、反射机制优缺点" class="headerlink" title="2、反射机制优缺点"></a>2、反射机制优缺点</h3><ul>
<li>优点： 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li>
</ul>
<h3 id="3、-反射机制的应用场景有哪些？"><a href="#3、-反射机制的应用场景有哪些？" class="headerlink" title="3、 反射机制的应用场景有哪些？"></a>3、 反射机制的应用场景有哪些？</h3><p>反射是框架设计的灵魂。</p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<h3 id="4、Java获取反射的三种方法"><a href="#4、Java获取反射的三种方法" class="headerlink" title="4、Java获取反射的三种方法"></a>4、Java获取反射的三种方法</h3><p>1.通过new对象实现反射机制</p>
<p>2.通过路径实现反射机制</p>
<p>3.通过类名实现反射机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Get</span> &#123;</span><br><span class="line">    <span class="comment">//获取反射机制三种方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//方式一(通过建立对象)</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">classobj1</span> <span class="operator">=</span> stu.getClass();</span><br><span class="line">        System.out.println(classobj1.getName());</span><br><span class="line">        <span class="comment">//方式二（所在通过路径-相对路径）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">classobj2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line">        System.out.println(classobj2.getName());</span><br><span class="line">        <span class="comment">//方式三（通过类名）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">classobj3</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(classobj3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、网络编程"><a href="#六、网络编程" class="headerlink" title="六、网络编程"></a>六、网络编程</h2><h3 id="1、网络协议是什么？"><a href="#1、网络协议是什么？" class="headerlink" title="1、网络协议是什么？"></a>1、网络协议是什么？</h3><p>在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p>
<h3 id="2、为什么要对网络协议分层？"><a href="#2、为什么要对网络协议分层？" class="headerlink" title="2、为什么要对网络协议分层？"></a>2、为什么要对网络协议分层？</h3><ul>
<li>简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。</li>
<li>灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。</li>
<li>易于实现和维护。</li>
<li>促进标准化工作。分开后，每层功能可以相对简单地被描述。</li>
</ul>
<p>网络协议分层的缺点： 功能可能出现在多个层里，产生了额外开销。</p>
<p>四层协议，五层协议和七层协议的关系如下：</p>
<ul>
<li>TCP&#x2F;IP是一个四层的体系结构，主要包括：应用层、运输层、网际层和网络接口层。</li>
<li>五层协议的体系结构主要包括：应用层、运输层、网络层，数据链路层和物理层。</li>
<li>OSI七层协议模型主要包括是：应用层（Application）、表示层（Presentation）、会话层（Session）、运输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</li>
</ul>
<p><img src="/img/loading.gif" data-original="/.com//20200316173310511.png" alt="20200316173310511">	</p>
<p>注：五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构。</p>
<h3 id="3、TCP-UDP协议"><a href="#3、TCP-UDP协议" class="headerlink" title="3、TCP&#x2F;UDP协议"></a>3、TCP&#x2F;UDP协议</h3><p><strong>UDP协议</strong></p>
<ul>
<li><p>用户数据报协议(User Datagram Protocol)</p>
</li>
<li><p>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
</li>
<li><p>由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</p>
</li>
<li><p>例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议</p>
</li>
</ul>
<p><strong>TCP协议</strong></p>
<ul>
<li><p>传输控制协议 (Transmission Control Protocol)</p>
</li>
<li><p>TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”</p>
</li>
<li><p>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠</p>
<p>第一次握手，客户端向服务器端发出连接请求，等待服务器确认</p>
<p>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求</p>
<p>第三次握手，客户端再次向服务器端发送确认信息，确认连接</p>
</li>
<li><p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等</p>
</li>
</ul>
<h3 id="4、UDP通信程序"><a href="#4、UDP通信程序" class="headerlink" title="4、UDP通信程序"></a>4、UDP通信程序</h3><h4 id="1、UDP发送数据"><a href="#1、UDP发送数据" class="headerlink" title="1、UDP发送数据"></a>1、UDP发送数据</h4><ul>
<li><p>Java中的UDP通信</p>
</li>
<li><p>UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念</p>
</li>
<li><p>Java提供了DatagramSocket类作为基于UDP协议的Socket</p>
</li>
<li><p>构造方法</p>
<p>|方法名|说明| |-|-| |DatagramSocket()|创建数据报套接字并将其绑定到本机地址上的任何可用端口| |DatagramPacket(byte[] buf,int len,InetAddress add,int port)|创建数据包,发送长度为len的数据包到指定主机的指定端口|</p>
</li>
<li><p>相关方法</p>
<p>|方法名|说明| |-|-| |void send(DatagramPacket p)|发送数据报包| |void close()|关闭数据报套接字| |void receive(DatagramPacket p)|从此套接字接受数据报包|</p>
</li>
<li><p>发送数据的步骤</p>
</li>
<li><p>创建发送端的Socket对象(DatagramSocket)</p>
</li>
<li><p>个创建数据，并把数据打包</p>
</li>
<li><p>调用DatagramSocket对象的方法发送数据</p>
</li>
<li><p>关闭发送端</p>
</li>
<li><p>代码演示</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="comment">// DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建数据，并把数据打包</span></span><br><span class="line">        <span class="comment">//DatagramPacket(byte[] buf, int length, InetAddress address, int port)</span></span><br><span class="line">        <span class="comment">//构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。</span></span><br><span class="line">        <span class="type">byte</span>[] bys = <span class="string">&quot;hello,udp,我来了&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys,bys.length,InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用DatagramSocket对象的方法发送数据</span></span><br><span class="line">        <span class="comment">//void send(DatagramPacket p) 从此套接字发送数据报包</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭发送端</span></span><br><span class="line">        <span class="comment">//void close() 关闭此数据报套接字</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、UDP接收数据"><a href="#2、UDP接收数据" class="headerlink" title="2、UDP接收数据"></a>2、UDP接收数据</h4><ul>
<li><p>接收数据的步骤</p>
</li>
<li><p>创建接收端的Socket对象(DatagramSocket)</p>
</li>
<li><p>创建一个数据包，用于接收数据</p>
</li>
<li><p>调用DatagramSocket对象的方法接收数据</p>
</li>
<li><p>解析数据包，并把数据在控制台显示</p>
</li>
<li><p>关闭接收端</p>
</li>
<li><p>构造方法</p>
<p>|方法名|说明| |-|-| |DatagramPacket(byte[] buf, int len)|创建一个DatagramPacket用于接收长度为len的数据包|</p>
</li>
<li><p>相关方法</p>
<p>|方法名|说明| |-|-| |byte[] getData()|返回数据缓冲区| |int getLength()|返回要发送的数据的长度或接收的数据的长度|</p>
</li>
<li><p>示例代码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">          <span class="comment">//创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">          <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//创建一个数据包，用于接收数据</span></span><br><span class="line">          <span class="type">byte</span>[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">          <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys, bys.length);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">          ds.receive(dp);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//解析数据包，并把数据在控制台显示</span></span><br><span class="line">          System.out.println(<span class="string">&quot;数据是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(), <span class="number">0</span>,                                             dp.getLength()));</span><br><span class="line">        &#125;</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、UDP通信程序练习"><a href="#3、UDP通信程序练习" class="headerlink" title="3、UDP通信程序练习"></a>3、UDP通信程序练习</h4><ul>
<li><p>案例需求</p>
<p>UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束</p>
<p>UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收</p>
</li>
<li><p>代码实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    UDP发送数据：</span></span><br><span class="line"><span class="comment">        数据来自于键盘录入，直到输入的数据是886，发送数据结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">//键盘录入数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="comment">//输入的数据是886，发送数据结束</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;886&quot;</span>.equals(s)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建数据，并把数据打包</span></span><br><span class="line">            <span class="type">byte</span>[] bys = s.getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys, bys.length, InetAddress.getByName(<span class="string">&quot;192.168.1.66&quot;</span>), <span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用DatagramSocket对象的方法发送数据</span></span><br><span class="line">            ds.send(dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭发送端</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    UDP接收数据：</span></span><br><span class="line"><span class="comment">        因为接收端不知道发送端什么时候停止发送，故采用死循环接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//创建一个数据包，用于接收数据</span></span><br><span class="line">            <span class="type">byte</span>[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys, bys.length);</span><br><span class="line">            <span class="comment">//调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">            ds.receive(dp);</span><br><span class="line">            <span class="comment">//解析数据包，并把数据在控制台显示</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(), <span class="number">0</span>, dp.getLength()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭接收端</span></span><br><span class="line"><span class="comment">//        ds.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、UDP三种通讯方式"><a href="#4、UDP三种通讯方式" class="headerlink" title="4、UDP三种通讯方式"></a>4、UDP三种通讯方式</h4><ul>
<li><p>单播</p>
<p>单播用于两个主机之间的端对端通信</p>
</li>
<li><p>组播</p>
<p>组播用于对一组特定的主机进行通信</p>
</li>
<li><p>广播</p>
<p>广播用于一个主机对整个局域网上所有主机上的数据通信</p>
</li>
</ul>
<h4 id="5、UDP组播实现"><a href="#5、UDP组播实现" class="headerlink" title="5、UDP组播实现"></a>5、UDP组播实现</h4><ul>
<li>实现步骤</li>
<li>发送端<ol>
<li>创建发送端的Socket对象(DatagramSocket)</li>
<li>创建数据，并把数据打包(DatagramPacket)</li>
<li>调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)</li>
<li>释放资源</li>
</ol>
</li>
<li>接收端<ol>
<li>创建接收端Socket对象(MulticastSocket)</li>
<li>创建一个箱子,用于接收数据</li>
<li>把当前计算机绑定一个组播地址</li>
<li>将数据接收到箱子中</li>
<li>解析数据包,并打印数据</li>
<li>释放资源</li>
</ol>
</li>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClinetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello 组播&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;224.0.1.0&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">// 2. 创建数据，并把数据打包(DatagramPacket)</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,address,port);</span><br><span class="line">        <span class="comment">// 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建接收端Socket对象(MulticastSocket)</span></span><br><span class="line">        <span class="type">MulticastSocket</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MulticastSocket</span>(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 2. 创建一个箱子,用于接收数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 3. 把当前计算机绑定一个组播地址,表示添加到这一组中.</span></span><br><span class="line">        ms.joinGroup(InetAddress.getByName(<span class="string">&quot;224.0.1.0&quot;</span>));</span><br><span class="line">        <span class="comment">// 4. 将数据接收到箱子中</span></span><br><span class="line">        ms.receive(dp);</span><br><span class="line">        <span class="comment">// 5. 解析数据包,并打印数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = dp.getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> dp.getLength();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,length));</span><br><span class="line">        <span class="comment">// 6. 释放资源</span></span><br><span class="line">        ms.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、UDP广播实现"><a href="#6、UDP广播实现" class="headerlink" title="6、UDP广播实现"></a>6、UDP广播实现</h4><ul>
<li>实现步骤</li>
<li>发送端<ol>
<li>创建发送端Socket对象(DatagramSocket)</li>
<li>创建存储数据的箱子,将广播地址封装进去</li>
<li>发送数据</li>
<li>释放资源</li>
</ol>
</li>
<li>接收端<ol>
<li>创建接收端的Socket对象(DatagramSocket)</li>
<li>创建一个数据包，用于接收数据</li>
<li>调用DatagramSocket对象的方法接收数据</li>
<li>解析数据包，并把数据在控制台显示</li>
<li>关闭接收端</li>
</ol>
</li>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">          <span class="comment">// 1. 创建发送端Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">// 2. 创建存储数据的箱子,将广播地址封装进去</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;广播 hello&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;255.255.255.255&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,address,port);</span><br><span class="line">        <span class="comment">// 3. 发送数据</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 2. 创建一个数据包，用于接收数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 3. 调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">        ds.receive(dp);</span><br><span class="line">        <span class="comment">// 4. 解析数据包，并把数据在控制台显示</span></span><br><span class="line">        <span class="type">byte</span>[] data = dp.getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> dp.getLength();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,length));</span><br><span class="line">        <span class="comment">// 5. 关闭接收端</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、TCP通信程序"><a href="#5、TCP通信程序" class="headerlink" title="5、TCP通信程序"></a>5、TCP通信程序</h3><h4 id="1、TCP发送数据"><a href="#1、TCP发送数据" class="headerlink" title="1、TCP发送数据"></a>1、TCP发送数据</h4><ul>
<li><p>Java中的TCP通信</p>
</li>
<li><p>Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。</p>
</li>
<li><p>Java为客户端提供了Socket类，为服务器端提供了ServerSocket类</p>
</li>
<li><p>构造方法</p>
<p>|方法名|说明| |-|-| |Socket(InetAddress address,int port)|创建流套接字并将其连接到指定IP指定端口号| |Socket(String host, int port)|创建流套接字并将其连接到指定主机上的指定端口号|</p>
</li>
<li><p>相关方法</p>
<p>|方法名|说明| |-|-| |InputStream getInputStream()|返回此套接字的输入流| |OutputStream getOutputStream()|返回此套接字的输出流|</p>
</li>
<li><p>示例代码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//TCP协议，发送数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建Socket对象</span></span><br><span class="line">        <span class="comment">//细节：在创建对象的同时会连接服务端</span></span><br><span class="line">        <span class="comment">//      如果连接不上，代码会报错</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.可以从连接通道中获取输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//写出数据</span></span><br><span class="line">        os.write(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、TCP接收数据"><a href="#2、TCP接收数据" class="headerlink" title="2、TCP接收数据"></a>2、TCP接收数据</h4><ul>
<li><p>构造方法</p>
<p>|方法名|说明| |-|-| |ServerSocket(int port)|创建绑定到指定端口的服务器套接字|</p>
</li>
<li><p>相关方法</p>
<p>|方法名|说明| |-|-| |Socket accept()|监听要连接到此的套接字并接受它|</p>
</li>
<li><p>注意事项</p>
</li>
</ul>
<ol>
<li>accept方法是阻塞的,作用就是等待客户端连接</li>
<li>客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接</li>
<li>针对客户端来讲,是往外写的,所以是输出流 针对服务器来讲,是往里读的,所以是输入流</li>
<li>read方法也是阻塞的</li>
<li>客户端在关流的时候,还多了一个往服务器写结束标记的动作</li>
<li>最后一步断开连接,通过四次挥手协议保证连接终止</li>
</ol>
<ul>
<li><p>三次握手和四次挥手</p>
</li>
<li><p>三次握手</p>
<p><img src="/img/loading.gif" data-original="/.com//image1.png" alt="image1">!](.&#x2F;assets&#x2F;image1.png)</p>
</li>
<li><p>四次挥手</p>
<p><img src="/img/loading.gif" data-original="/.com//image2.png" alt="image2">!](.&#x2F;assets&#x2F;image2.png)</p>
</li>
<li><p>示例代码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//TCP协议，接收数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象ServerSocker</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.监听客户端的链接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.从连接通道中获取输入流读取数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、TCP程序练习（传输中文）"><a href="#3、TCP程序练习（传输中文）" class="headerlink" title="3、TCP程序练习（传输中文）"></a>3、TCP程序练习（传输中文）</h4><p>发送端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//TCP协议，发送数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建Socket对象</span></span><br><span class="line">        <span class="comment">//细节：在创建对象的同时会连接服务端</span></span><br><span class="line">        <span class="comment">//      如果连接不上，代码会报错</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.可以从连接通道中获取输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//写出数据</span></span><br><span class="line">        os.write(<span class="string">&quot;你好你好&quot;</span>.getBytes());<span class="comment">//12字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//TCP协议，接收数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象ServerSocker</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.监听客户端的链接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.从连接通道中获取输入流读取数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = br.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、多线程"><a href="#七、多线程" class="headerlink" title="七、多线程"></a>七、多线程</h2><h3 id="1、线程和进程"><a href="#1、线程和进程" class="headerlink" title="1、线程和进程"></a>1、线程和进程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进程：</span><br><span class="line">	是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间。</span><br><span class="line">线程：</span><br><span class="line">	是进程中的一个执行路径，共享一个内存空间，线程之间可以自由切换，并发执行，一个进程最少有一个线程。</span><br><span class="line">	线程实际上是在进程基础之上的进一步划分，一个进程启动之后，里面的若干执行路径又可以划分成若干个线程。</span><br></pre></td></tr></table></figure>



<h3 id="2、线程调度"><a href="#2、线程调度" class="headerlink" title="2、线程调度"></a>2、线程调度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">分时调度</span><br><span class="line">	所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。</span><br><span class="line">	</span><br><span class="line">抢占式调度</span><br><span class="line">	优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），java使用的为抢占式调度。</span><br><span class="line">	CPU使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核心而言，某个时刻，只能执行一个线程，而CPU在多个线程间切换速度相对我们的感觉要快，看上去就是 在同一时刻运行，其实，多线程程序（基于一个CPU）并不能提高程序的运行速度，但能够提高程序的运行效率，让CPU使用率更高。</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">扩展：数据库服务器，上千线程使用数据库，数据库只有8个CPU，同时开启1k个连接，让1k个人操作他，8个CPU交替执行效率快，还是1k个人排队用8个CPU快?</span><br><span class="line">答：1k人排队用8个CPU效率更高，（A完成B开始，B完成C开始），缺少了切换的时间。</span><br></pre></td></tr></table></figure>

<h3 id="3、同步与异步"><a href="#3、同步与异步" class="headerlink" title="3、同步与异步"></a>3、同步与异步</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">之前谈的线程安全是同步，线程不安全是异步。</span><br><span class="line">同步：排队执行，效率低但是安全</span><br><span class="line">异步：同时执行，效率高但是数据不安全</span><br></pre></td></tr></table></figure>

<h3 id="4、并发与并行"><a href="#4、并发与并行" class="headerlink" title="4、并发与并行"></a>4、并发与并行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">并发：指两个or多个事件在 同一个时间段内 发生</span><br><span class="line">并行：指两个or多个事件在 同一时刻 发生（同时发生）</span><br></pre></td></tr></table></figure>

<h3 id="5、实现多线程的三种方式"><a href="#5、实现多线程的三种方式" class="headerlink" title="5、实现多线程的三种方式"></a>5、实现多线程的三种方式</h3><h4 id="1、继承Thread"><a href="#1、继承Thread" class="headerlink" title="1、继承Thread"></a>1、继承Thread</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread是Java提供的线程类，继承了该类的就是一个线程类。</span><br><span class="line"></span><br><span class="line">主线程和分支线程是并发执行的，谁在前谁在后  是随机的  抢占式分配</span><br><span class="line"></span><br><span class="line">编写一个类extends Thread，重写线程类的run方法，触发方式是调用Thread对象的start()方法启动任务</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由一个线程执行的方法，那么这个方法也会执行在这个线程里面。</span><br><span class="line">每个线程都有自己的栈空间，共用一份堆内存。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line"> System.out.println(i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadDemo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">MyThread</span> <span class="variable">my1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"> <span class="type">MyThread</span> <span class="variable">my2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="comment">// my1.run();</span></span><br><span class="line"><span class="comment">// my2.run();</span></span><br><span class="line"> <span class="comment">//void start() 导致此线程开始执⾏; Java虚拟机调⽤此线程的run⽅法</span></span><br><span class="line"> my1.start();</span><br><span class="line"> my2.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>两个⼩问题 为什么要重写run()⽅法？ </p>
<ul>
<li>因为run()是⽤来封装被线程执⾏的代码</li>
</ul>
</li>
<li><p>run()⽅法和start()⽅法的区别？</p>
<ul>
<li>run()：封装线程执⾏的代码，直接调⽤，相当于普通⽅法的调⽤ </li>
<li>start()：启动线程；然后由JVM调⽤此线程的run()⽅法</li>
</ul>
</li>
</ul>
<h4 id="2、实现Runnable接口"><a href="#2、实现Runnable接口" class="headerlink" title="2、实现Runnable接口"></a>2、实现Runnable接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">编写一个类implements Runnable接口，并实现run()方法</span><br><span class="line"></span><br><span class="line">实现Runnable与继承Thread相比有如下优势：</span><br><span class="line">1.通过创建任务，然后给线程分配的方式来实现的多线程，更适合多个线程同时执行相同任务的情况。即1个任务多个线程执行，很方便。</span><br><span class="line">2.可以避免单继承所带来的局限性。(最有优势的点)。Java中extends只能继承一个类，单继承，implements是实现接口，可以多实现，并且还可以extends一个类。</span><br><span class="line">3.任务与线程本身是分离的，提高了程序的健壮性。</span><br><span class="line">4.后续学习的线程池技术（管理的是任务而不是线程），只接受Runnable类型的任务，不接受Thread类型的线程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableDemo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">//创建MyRunnable类的对象</span></span><br><span class="line"> <span class="type">MyRunnable</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"> <span class="comment">//创建Thread类的对象，把MyRunnable对象作为构造⽅法的参数</span></span><br><span class="line"> <span class="comment">//Thread(Runnable target)</span></span><br><span class="line"><span class="comment">// Thread t1 = new Thread(my);</span></span><br><span class="line"><span class="comment">// Thread t2 = new Thread(my);</span></span><br><span class="line"> <span class="comment">//Thread(Runnable target, String name)</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">&quot;坦克&quot;</span>);</span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">&quot;⻜机&quot;</span>);</span><br><span class="line"> <span class="comment">//启动线程</span></span><br><span class="line"> t1.start();</span><br><span class="line"> t2.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、Callable接口"><a href="#3、Callable接口" class="headerlink" title="3、Callable接口"></a>3、Callable接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java中的第三种线程实现方式</span><br><span class="line">创建线程一般就继承Thread和实现Runnable，这两种方法创建的线程和主线程是一块执行的，两个一块走。</span><br><span class="line">Callable实现线程的话既可以两个一块走，也可以实现主线程等子线程执行完毕返回结果</span><br></pre></td></tr></table></figure>

<h5 id="1、Runnable与Callable"><a href="#1、Runnable与Callable" class="headerlink" title="1、Runnable与Callable"></a>1、Runnable与Callable</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">接口定义</span><br><span class="line">//Callable接口</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">	V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line">//Runnable接口</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">	public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、Callable使用步骤"><a href="#2、Callable使用步骤" class="headerlink" title="2、Callable使用步骤"></a>2、Callable使用步骤</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 编写类实现Callable接口 , 实现call方法</span><br><span class="line">    class XXX implements Callable&lt;T&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public &lt;T&gt; call() throws Exception &#123;</span><br><span class="line">        	return T;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">2. 创建FutureTask对象 , 并传入第一步编写的Callable类对象</span><br><span class="line">	FutureTask&lt;Integer&gt; future = new FutureTask&lt;&gt;(callable);</span><br><span class="line">3. 通过Thread,启动线程</span><br><span class="line">	new Thread(future).start();</span><br><span class="line">	</span><br><span class="line">Callable相对麻烦一点，实现Callable接口的类需要使用泛型，任务执行完毕以后进行return返回什么类型的结果给启动线程的人。</span><br><span class="line"></span><br><span class="line">FutureTask有get()方法获取线程执行的结果，但要知道，比如说主线程调用了线程A，线程A需要花10s完成某件事情并返回结果，那么主线程如果没调用get方法，它就不会等这10s，并发执行两个线程，但如果调了这个方法，主线程就会等这10s，等待线程A执行完毕，主线程获取结果之后再往下执行。</span><br><span class="line">还有一个get(long timeout,TimeUnit unit)，给一个最多能能带的时间，要是超时，算了不要了。</span><br><span class="line"></span><br><span class="line">FutureTask对象名.isDone()可以判断任务是否执行完毕</span><br><span class="line">FutureTask对象名.cancel(true)  取消任务，其返回值为true 取消成功，任务还没完成被干掉了。return FALSE的情况绝大多数是因为任务已经执行完毕，执行成功了，没有办法再取消了。</span><br><span class="line"></span><br><span class="line">该方法作为了解，用得并不多。</span><br></pre></td></tr></table></figure>

<h3 id="6、Thread类"><a href="#6、Thread类" class="headerlink" title="6、Thread类"></a>6、Thread类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">构造方法：</span><br><span class="line">Thread(Runnable target) 分配新的 Thread对象。  </span><br><span class="line">Thread(Runnable target, String name) 分配新的 Thread对象。不仅传一个任务，也可以传任务name。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常用方法：</span><br><span class="line">getName()   返回此线程名称</span><br><span class="line">getId()    返回此Thread的标识符</span><br><span class="line">getPriority()    返回此线程的优先级</span><br><span class="line">getPriority(int newPriority)    更改此线程的优先级，控制线程抢到时间片的几率  可以传入静态修饰的常量  MAX_PRIORITY(线程可以拥有的最大优先级)  MIN_PRIORITY(线程可以拥有的最低优先级)   NORM_PRIORITY(分配给线程的默认优先级)</span><br><span class="line">start()    此线程开始执行，Java虚拟机调用此线程的run方法。</span><br><span class="line">stop()    已过时，这种方式本质上不安全。比如 正在IO，停了，正在使用某些资源无法释放，资源依然被占用。</span><br><span class="line">那么怎么停止线程这一单独执行路径呢？可以设置变量作为标记，线程一直监听该变量的值，一旦变了，通知线程，线程自杀，run方法return 。</span><br><span class="line">sleep(long millis)    导致当前正在执行的线程休眠(暂时停止执行)指定的毫秒数。</span><br><span class="line">sleep(long millis,int nanos)    导致当前正在执行的线程休眠(暂时停止执行)指定的毫秒数加上指定的纳秒数。</span><br><span class="line">sleep很常见，比如想每个1秒输出一个数字，则sleep(1000)</span><br><span class="line">setDaemon(boolean on)    将此线程标记为守护线程(当所有用户线程全部死亡后，守护线程自动死亡，它依附于用户线程)or用户线程(主线程和子线程都称为用户线程，所有用户线程必须全部死亡，程序才会结束)</span><br></pre></td></tr></table></figure>

<h4 id="1、设置和获取线程名称"><a href="#1、设置和获取线程名称" class="headerlink" title="1、设置和获取线程名称"></a>1、设置和获取线程名称</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread类有一个static方法currentThread()获取当前线程，所以可以通过 类名.方法名 调用该方法。</span><br><span class="line">getName()方法返回线程名称</span><br><span class="line">构造时不传name也有默认name——Thread-0、Thread-1...</span><br><span class="line"></span><br><span class="line">也可以new出来接收一下，设置线程name,再start方法调用run</span><br></pre></td></tr></table></figure>

<h4 id="2、线程休眠"><a href="#2、线程休眠" class="headerlink" title="2、线程休眠"></a>2、线程休眠</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread类的static方法sleep，也是直接通过 类.方法名 方式调用。</span><br><span class="line">下图运行时会每隔一秒输出一个数字</span><br></pre></td></tr></table></figure>

<h4 id="3、线程阻塞-interrupt"><a href="#3、线程阻塞-interrupt" class="headerlink" title="3、线程阻塞 interrupt()"></a>3、线程阻塞 interrupt()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不只指的是线程休眠了 睡了，线程是一条执行路径，比如一个线程执行路径代码100行，可能有10行是读取某个文件，这个文件读取耗时1s，那么这1秒也是阻塞的，它停在那读文件，后面读完才会继续执行。</span><br><span class="line">可以把线程阻塞简单理解为所有比较耗时间的操作，比如常见的文件读取，会导致线程等待在那个位置，代码不会继续执行，除非文件读完。</span><br><span class="line">再比如说等待用户输入，用户不输入，代码就会等在那不会继续执行，线程阻塞 又称为耗时操作。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在需要杀死线程的代码块处调用 线程对象.interrupt()</span><br><span class="line">调用该方法会告知Thread该死亡了，Thread之后怎么办还是看Thread try到中断异常后如何处理的代码块。</span><br><span class="line">就会进入该线程run方法的try catch中断异常，然后怎么做是看程序员在catch异常后的catch块里写的什么操作，一般这个位置拿来释放资源(交代线程后事)，然后return，return即正常结束了run方法，Thread正常自杀。</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//s1-1709083445233-32.png" alt="s1"></p>
<p><img src="/img/loading.gif" data-original="/.com//s2-1709083445234-35.png" alt="s2"></p>
<p><img src="/img/loading.gif" data-original="/.com//s3-1709083445234-33.png" alt="s3"></p>
<h4 id="4、守护线程"><a href="#4、守护线程" class="headerlink" title="4、守护线程"></a>4、守护线程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程：分为守护线程和用户线程</span><br><span class="line">用户线程：当一个进程不包含任何的存活的用户线程时，进程结束。</span><br><span class="line">守护线程：守护用户线程的，当最后一个用户线程结束时，所有守护线程自动死亡。</span><br><span class="line"></span><br><span class="line">直接创建的线程都是用户线程，若想设置守护线程需要创建Thread对象之后，start之前调用setDaemon方法，实参为true。</span><br><span class="line">主线程输出到5，main方法还要结束，此时子线程又输出了一个6，这是在上一个中断线程的源码的基础上加了一个设置守护线程的方法。</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//a1-1709083445234-34.png" alt="a1"></p>
<h4 id="5、线程安全问题"><a href="#5、线程安全问题" class="headerlink" title="5、线程安全问题"></a>5、线程安全问题</h4><h4 id="1、线程不安全"><a href="#1、线程不安全" class="headerlink" title="1、线程不安全"></a>1、线程不安全</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">举个例子，不能一直空说大汉吃一碗面</span><br><span class="line">卖票，实现Runnable的任务类，类的方法就是对当前票数--，sleep是故意为了让它出线程不安全的问题，演示线程不安全的事，启动三个Thread，共同执行卖票这个任务。</span><br><span class="line"></span><br><span class="line">分析结果：单看逻辑，怎么都不会出现负数。出现负数是因为有可能A线程发现count为1(极端情况)进入while循环，还没进行count--操作，其他两个线程插足(抢到时间片)也通过count&gt;0进入线程，所以后面进行count--，出现了-1   -2</span><br></pre></td></tr></table></figure>

<h4 id="2、线程安全"><a href="#2、线程安全" class="headerlink" title="2、线程安全"></a>2、线程安全</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先明确线程不安全的原因：</span><br><span class="line">	多个线程同时执行，去同时操作一个数据，导致某个数据看到的和在自己使用时数据不一致，因为其看到的和使用的中间间隔代码执行时被其他线程插足了(其他线程进来把数据改了)，所以最终导致运行不符合预期。</span><br><span class="line">	</span><br><span class="line">很简单，就让某个线程在执行 看到的和使用时的数据 之间的代码块时，其他线程不插足，排队执行。</span><br><span class="line">大汉排队吃锅里的食物，每个人看到的和吃到嘴里的 不会有差异。</span><br><span class="line"></span><br><span class="line">关于线程同步，有三种不同的关于让线程排队执行的方式，都是通过上锁，加锁的方式。</span><br></pre></td></tr></table></figure>

<h5 id="1、实现线程安全1-同步代码块"><a href="#1、实现线程安全1-同步代码块" class="headerlink" title="1、实现线程安全1-同步代码块"></a>1、实现线程安全1-同步代码块</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">可以简单认为，被括住的代码块是排队执行的。</span><br><span class="line">格式</span><br><span class="line">	synchronized(锁对象)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">Java中任何对象都可以作为锁对象存在，可以认为任何对象都可以打锁标记。打锁标记我们不用管，是内存底层的机制。线程会观察锁对象是否打了锁的标记，如果被打了，说明有人正在执行，他就会等，一直等，一直看标记是不是解锁了。某个线程执行完毕后，解锁，其他人抢，抢到就上锁。一般回首掏比较nb，见下图的运行结果，大部分是Thread-0抢到了。</span><br><span class="line">注意：100个线程要上同一把锁才能实现排队的效果。</span><br><span class="line"></span><br><span class="line">下图就是在卖票的例子上加了一个private Object o = new Object()和synchronized  就实现了线程安全。 </span><br><span class="line">卖票的例子   就new了一个Ticket对象(任务)，所以线程用的是一个锁对象o。</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//a2-1709083445234-38.png" alt="a2">!](.&#x2F;assets&#x2F;a2.png)</p>
<p><img src="/img/loading.gif" data-original="/.com//a3-1709083445234-36.png" alt="a3">!](.&#x2F;assets&#x2F;a3.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有线程要共用一把锁，线程.start()方法会调用run方法，如果在run方法里new 锁对象，则成了每个线程都有自己独立的锁，就没有线程安全的说法了。如下图，还是会出现-1  -2</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//a4-1709083445234-37.png" alt="a4">!](.&#x2F;assets&#x2F;a4.png)</p>
<h5 id="2、实现线程安全2-同步方法"><a href="#2、实现线程安全2-同步方法" class="headerlink" title="2、实现线程安全2-同步方法"></a>2、实现线程安全2-同步方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">同步代码甚至可以以一行代码为单位进行加锁，但同步方法以方法为单位进行加锁。</span><br><span class="line">格式</span><br><span class="line">	给方法添加synchronized修饰词</span><br><span class="line"></span><br><span class="line">这里的锁就是任务Ticket对象，一个任务多个线程调用，才会安全。</span><br><span class="line">Runnable run = new Ticket();</span><br><span class="line">new Thread(run).start();</span><br><span class="line">new Thread(run).start();</span><br><span class="line">new Thread(run).start();</span><br><span class="line"></span><br><span class="line">同步方法用的是一个this这把锁，要是有多个同步方法，or有个同步代码是传的this为锁对象，则若有一个同步方法在执行，其他同步方法都执行不了(Thread-0上锁之后，其他Thread都不能执行别的同步方法)，都是排队的，因为上的是同一把锁。</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//b1-1709083445234-40.png" alt="b1">!](.&#x2F;assets&#x2F;b1.png)</p>
<p><img src="/img/loading.gif" data-original="/.com//b2-1709083445234-42.png" alt="b2">!](.&#x2F;assets&#x2F;b2.png)</p>
<h5 id="3、实现线程安全3-Lock锁"><a href="#3、实现线程安全3-Lock锁" class="headerlink" title="3、实现线程安全3-Lock锁"></a>3、实现线程安全3-Lock锁</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">同步代码块和同步方法都属于隐式锁，就是具体是怎么锁的我们不用管，只需把格式写好，它就自己锁，自己开，这就叫隐式锁。</span><br><span class="line">显式锁就是自己创建锁对象，自己上锁，自己解锁。</span><br><span class="line"></span><br><span class="line">在Ticket类里定义一个属性显式锁l</span><br><span class="line">private lock l = new ReentrantLock();</span><br><span class="line">在需要上锁的地方 l.lock()</span><br><span class="line">在需要解锁的地方 l.unlock()</span><br><span class="line"></span><br><span class="line">因为是new一个任务(Ticket)对象 所以用的是同一把显式锁l</span><br><span class="line"></span><br><span class="line">显式锁比隐式锁更好一些，更能体现程序员在控制 锁的概念</span><br><span class="line"></span><br><span class="line">while true里的代码如下，就是法1同步代码块的地方</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//b3-1709083445236-48.png" alt="b3">!](.&#x2F;assets&#x2F;b3.png)</p>
<h3 id="7、公平锁与非公平锁"><a href="#7、公平锁与非公平锁" class="headerlink" title="7、公平锁与非公平锁"></a>7、公平锁与非公平锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">公平锁</span><br><span class="line">	排队 先来先到，A线程先来等，那么解锁之后A线程先执行并上锁</span><br><span class="line">	</span><br><span class="line">非公平锁</span><br><span class="line">	一旦解锁，大家一起抢</span><br><span class="line">	</span><br><span class="line">Java里默认的，上述三种线程安全方法都是非公平锁。</span><br><span class="line"></span><br><span class="line">显式锁l里，fair参数为true，表示是公平锁，构造方法的实参：</span><br><span class="line">private lock l = new ReentrantLock(true)</span><br></pre></td></tr></table></figure>

<h3 id="8、线程死锁"><a href="#8、线程死锁" class="headerlink" title="8、线程死锁"></a>8、线程死锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">死锁  互相等待的一种僵局</span><br><span class="line"></span><br><span class="line">避免的话  在开发时，在任何有锁的方法(点播里的是给方法加synchronized修饰词)里尽量不要编写另一个带锁的方法</span><br></pre></td></tr></table></figure>

<h3 id="9、-悲观锁和乐观锁"><a href="#9、-悲观锁和乐观锁" class="headerlink" title="9、 悲观锁和乐观锁"></a>9、 悲观锁和乐观锁</h3><p><strong>synchronized和CAS的区别 :</strong></p>
<p><strong>相同点：</strong>在多线程情况下，都可以保证共享数据的安全性。</p>
<p><strong>不同点：</strong>synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每 次操作共享数据之前，都会上锁。（悲观锁）</p>
<p> cas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。</p>
<p> 如果别人修改过，那么我再次获取现在最新的值。</p>
<p> 如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁）</p>
<h3 id="10、生产者与消费者"><a href="#10、生产者与消费者" class="headerlink" title="10、生产者与消费者"></a>10、生产者与消费者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">食物类，为了让他在做菜时更容易出问题，设置name和taste之间sleep一会，执行设置name后，时间片被占，再次抢占到时间片时回来执行设置taste</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//c1-1709083445235-43.png" alt="c1">!](.&#x2F;assets&#x2F;c1.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">厨师   声明为线程，就做饭。</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//c2-1709083445235-46.png" alt="c2">!](.&#x2F;assets&#x2F;c2.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务员，因为厨师的run方法里的set方法sleep了100ms，所以这里也sleep一下。</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//c3-1709083445235-44.png" alt="c3">!](.&#x2F;assets&#x2F;c3.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main方法</span><br><span class="line">代码里写的是老干妈小米粥香辣味，运行结果是甜辣味。就说明出问题了，厨师刚生产设置了name，sleep 的时候，服务员线程把菜端走了，所以taste没有设置，还是之前的甜辣味。</span><br><span class="line">出现了两个线程进行协作时不协调的问题。</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//c4-1709083445235-45.png" alt="c4">!](.&#x2F;assets&#x2F;c4.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于这个问题，多数人认为可以给食物类的get set上锁，给方法加synchronized修饰词，都是用的this锁，所以厨师在做菜的时候，服务员不能端走，但厨师会一直回手掏，会出更大的问题，所以不能解决上述问题。</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//c5-1709083445235-47.png" alt="c5">!](.&#x2F;assets&#x2F;c5.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">	厨师做饭时，服务员睡着，厨师做完饭，叫醒服务员，服务员去上菜然后厨师睡着，服务员上完菜把盘子端回来再把厨师叫醒，服务员睡着...</span><br><span class="line"></span><br><span class="line">可以在上锁后(synchronized)再加以设置标记实现。</span><br><span class="line">给Food类加一个private boolean flag = true</span><br><span class="line">假设true表示可以生产</span><br><span class="line">flag判完设置为FALSE，确保不会连续执行第二次，一次做饭，一次端盘子，notifyAll是唤醒当前处于等待的所有线程，然后自己等待。</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//c6-1709083445236-49.png" alt="c6">!](.&#x2F;assets&#x2F;c6.png)</p>
<p><img src="/img/loading.gif" data-original="/.com//c7-1709083445236-51.png" alt="c7">!](.&#x2F;assets&#x2F;c7.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果   没有任何问题了</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/.com//c8-1709083445236-50.png" alt="c8">!](.&#x2F;assets&#x2F;c8.png)</p>
<p>线程的六种状态</p>
<ul>
<li>New</li>
</ul>
<p>​	刚被创建 尚未启动的线程处于此状态</p>
<ul>
<li>Runnable</li>
</ul>
<p>​	Java虚拟机中执行的线程处于此状态</p>
<ul>
<li>Blocked</li>
</ul>
<p>​	被阻塞等待监视器锁定的线程处于此状态</p>
<p>​	线程安全里提过上锁的概念，多个线程从一起执行到排队执行，当处于排队的时候就	处于Blocked状态，排完队进入Runnable状态</p>
<ul>
<li>Waiting</li>
</ul>
<p>​	无限期等待另一个线程执行特定操作的线程处于此状态 比如没有指定休眠时间的休		眠，一直睡，知道被唤醒则进入Runnable状态</p>
<ul>
<li>Timed_Waiting</li>
</ul>
<p>​	无限期等待另一个线程执行最多指定等待时间的操作的线程处于此状态 可以不用等别	人唤醒，毕竟是指定时间的，倒也可以被唤醒，醒了直接进入Runnable状态</p>
<ul>
<li>Terminated</li>
</ul>
<p>​	已退出的线程处于此状态</p>
<p><img src="/img/loading.gif" data-original="/.com//q1-1709083445237-52.png" alt="q1">!](.&#x2F;assets&#x2F;q1.png)</p>
<h3 id="11、线程池"><a href="#11、线程池" class="headerlink" title="11、线程池"></a>11、线程池</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建线程-&gt;创建任务-&gt;执行任务-&gt;销毁线程</span><br><span class="line">有时候创建任务和执行任务只占整个过程大概5%的时间，真正花时间的是创建线程和销毁线程。</span><br><span class="line"></span><br><span class="line">如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低 系统的效率，因为频繁创建线程和销毁线程需要时间. 线程池就是一个容纳多个线程的容器，池中的线程可以反复使用，省去了频繁创建线程对象的操作，节省了大量的时间和资源。</span><br><span class="line"></span><br><span class="line">合理设置线程池的长度也很有必要，依次领任务。如果是非定长线程池，见到任务来了没相应闲状态的线程，就会new一个Thread并且线程池长度+1了。既然能自动扩容也有自动清缓存，如果有多个线程一直处于闲，就销毁了。</span><br><span class="line"></span><br><span class="line">Java中自己主动使用线程池的还是少的，后端开发本来就是基于多线程的，已经有池缓存的概念了，不需要额外加线程池了。</span><br></pre></td></tr></table></figure>

<h5 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h5><ul>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ul>
<h3 id="12、volatitle关键字"><a href="#12、volatitle关键字" class="headerlink" title="12、volatitle关键字"></a>12、volatitle关键字</h3><p> 当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题</p>
<p> 1，堆内存是唯一的，每一个线程都有自己的线程栈。</p>
<p> 2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。</p>
<p> 3 ，在线程中，每一次使用是从变量的副本中获取的。</p>
<p><strong>Volatile关键字 :</strong> 强制线程每次在使用的时候，都会看一下共享区域最新的值</p>
<p><strong>Volatile解决：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;小路同学&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        t2.setName(<span class="string">&quot;小皮同学&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Money</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(Money.money == <span class="number">100000</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结婚基金已经不是十万了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Money.money = <span class="number">90000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized解决：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;小路同学&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        t2.setName(<span class="string">&quot;小皮同学&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.myvolatile2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Money</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.myvolatile2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span>  <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Money.lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Money.money != <span class="number">100000</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;结婚基金已经不是十万了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.myvolatile2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Money.lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Money.money = <span class="number">90000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、常用API"><a href="#八、常用API" class="headerlink" title="八、常用API"></a>八、常用API</h2><h3 id="1、String相关"><a href="#1、String相关" class="headerlink" title="1、String相关"></a>1、String相关</h3><h4 id="1、字符型常量和字符串常量的区别"><a href="#1、字符型常量和字符串常量的区别" class="headerlink" title="1、字符型常量和字符串常量的区别"></a>1、字符型常量和字符串常量的区别</h4><p>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符<br>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)<br>占内存大小：字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</p>
<h4 id="2、什么是字符串常量池？"><a href="#2、什么是字符串常量池？" class="headerlink" title="2、什么是字符串常量池？"></a>2、什么是字符串常量池？</h4><p>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p>
<h4 id="3、String-是最基本的数据类型吗？"><a href="#3、String-是最基本的数据类型吗？" class="headerlink" title="3、String 是最基本的数据类型吗？"></a>3、String 是最基本的数据类型吗？</h4><p>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p>
<p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars &#x3D; {‘你’,‘好’};</p>
<p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p>
<h4 id="4、String有哪些特性"><a href="#4、String有哪些特性" class="headerlink" title="4、String有哪些特性"></a>4、String有哪些特性</h4><p>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</p>
<p>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</p>
<p>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</p>
<h4 id="5、String为什么是不可变的吗？"><a href="#5、String为什么是不可变的吗？" class="headerlink" title="5、String为什么是不可变的吗？"></a>5、String为什么是不可变的吗？</h4><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>
<p>&#x2F;** The value is used for character storage. *&#x2F;<br>private final char value[];</p>
<h4 id="6、String真的是不可变的吗？"><a href="#6、String真的是不可变的吗？" class="headerlink" title="6、String真的是不可变的吗？"></a>6、String真的是不可变的吗？</h4><p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</p>
<ol>
<li>String不可变但不代表引用不可以变</li>
</ol>
<p>String str &#x3D; “Hello”;<br>str &#x3D; str + “ World”;<br>System.out.println(“str&#x3D;” + str);<br>结果：</p>
<p>str&#x3D;Hello World<br>解析：</p>
<p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p>
<ol start="2">
<li><p>通过反射是可以修改所谓的“不可变”对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符串&quot;Hello World&quot;， 并赋给引用s</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">// Hello World</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取String类中的value字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">valueFieldOfString</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">valueFieldOfString.setAccessible(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line"><span class="type">char</span>[] value = (<span class="type">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">value[<span class="number">5</span>] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">// Hello_World</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>结果：</p>
<p>s &#x3D; Hello World<br>s &#x3D; Hello_World<br>解析：</p>
<p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p>
<h4 id="7、是否可以继承-String-类"><a href="#7、是否可以继承-String-类" class="headerlink" title="7、是否可以继承 String 类"></a>7、是否可以继承 String 类</h4><p>String 类是 final 类，不可以被继承。</p>
<h4 id="8、String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#8、String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？"></a>8、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</h4><p>不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。</p>
<h4 id="9、String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#9、String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="9、String s &#x3D; new String(“xyz”);创建了几个字符串对象"></a>9、String s &#x3D; new String(“xyz”);创建了几个字符串对象</h4><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>; <span class="comment">//str1指向静态区</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">//str2指向堆上的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str2.equals(str4)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str4); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == <span class="string">&quot;hello&quot;</span>); <span class="comment">//false</span></span><br><span class="line">str2 = str1;</span><br><span class="line">System.out.println(str2 == <span class="string">&quot;hello&quot;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>


<h4 id="10、如何将字符串反转？"><a href="#10、如何将字符串反转？" class="headerlink" title="10、如何将字符串反转？"></a>10、如何将字符串反转？</h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">stringBuffer. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">stringBuilder. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure>



<h4 id="11、数组有没有-length-方法？String-有没有-length-方法"><a href="#11、数组有没有-length-方法？String-有没有-length-方法" class="headerlink" title="11、数组有没有 length()方法？String 有没有 length()方法"></a>11、数组有没有 length()方法？String 有没有 length()方法</h4><p>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</p>
<h4 id="12、String-类的常用方法都有那些？"><a href="#12、String-类的常用方法都有那些？" class="headerlink" title="12、String 类的常用方法都有那些？"></a>12、String 类的常用方法都有那些？</h4><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p>
<h4 id="13、在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#13、在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="13、在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>13、在使用 HashMap 的时候，用 String 做 key 有什么好处？</h4><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>
<h4 id="14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"><a href="#14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"></a>14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h4><p>可变性</p>
<p>String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p>
<p>线程安全性</p>
<p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p>性能</p>
<p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p>对于三者使用的总结</p>
<p>如果要操作少量的数据用 &#x3D; String</p>
<p>单线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuilder</p>
<p>多线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuffer</p>
<h3 id="2、Date相关"><a href="#2、Date相关" class="headerlink" title="2、Date相关"></a>2、Date相关</h3><h3 id="3、包装类相关"><a href="#3、包装类相关" class="headerlink" title="3、包装类相关"></a>3、包装类相关</h3><h4 id="1、自动装箱与拆箱"><a href="#1、自动装箱与拆箱" class="headerlink" title="1、自动装箱与拆箱"></a>1、自动装箱与拆箱</h4><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p>
<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p>
<h4 id="2、int-和-Integer-有什么区别"><a href="#2、int-和-Integer-有什么区别" class="headerlink" title="2、int 和 Integer 有什么区别"></a>2、int 和 Integer 有什么区别</h4><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。</p>
<p>Java 为每个原始类型提供了包装类型：</p>
<p>原始类型: boolean，char，byte，short，int，long，float，double</p>
<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
<h4 id="3、Integer-a-127-与-Integer-b-127相等吗？"><a href="#3、Integer-a-127-与-Integer-b-127相等吗？" class="headerlink" title="3、Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗？"></a>3、Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗？</h4><p>对于对象引用类型：&#x3D;&#x3D;比较的是对象的内存地址。<br>对于基本数据类型：&#x3D;&#x3D;比较的是值。</p>
<p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1&#x3D;&#x3D;b1的结果是false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    System.out.println(a == b); <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">    System.out.println(a == c); <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    System.out.println(b == c); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(a1 == b1); <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    System.out.println(a2 == b2); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">楞</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/03/01/Java%E5%9F%BA%E7%A1%80/">http://example.com/2024/03/01/Java基础/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">L1n</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/JavaSE_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/04/25/JavaWeb/" title="JavaWeb笔记"><img class="cover" src="/img/loading.gif" data-original="/img/JW_C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaWeb笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">楞</div><div class="author-info__description">心有所向, 无问东西</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Raehp" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhanghaolin406@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.csdn.net/ChengXuYuanQ?type=blog" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://www.youtube.com/channel/UC_YN18th7UBb0fJwRg4XpsQ" target="_blank" title="YouTube"><i class="fab fa-youtube"></i></a><a class="social-icon" href="https://www.google.com/" target="_blank" title="Google"><i class="fab fa-google"></i></a><a class="social-icon" href="https://stackoverflow.com/?newreg=6006dea233a64469a2962d9d8a8e7ea9" target="_blank" title="StackOverflow"><i class="fab fa-stack-overflow"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">平安喜樂，得偿所愿，祝你，也祝我</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java%E6%A6%82%E8%BF%B0"><span class="toc-text">一、Java概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81JVM%E3%80%81JRE%E5%92%8CJDK%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">1、JVM、JRE和JDK的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">2、什么是跨平台性？原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9"><span class="toc-text">Java语言有哪些特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E6%9C%80%E5%A4%A7%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">3、什么是字节码？采用字节码的最大好处是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Java%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4、Java和C++的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">二、基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1、数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.Java有哪些数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81switch-%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-byte-%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-long-%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-String-%E4%B8%8A"><span class="toc-text">2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BC%96%E7%A0%81"><span class="toc-text">2、编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E9%87%87%E7%94%A8%E4%BD%95%E7%A7%8D%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88%EF%BC%9F%E6%9C%89%E4%BD%95%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">Java语言采用何种编码方案？有何特点？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B3%A8%E9%87%8A"><span class="toc-text">3、注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">4、访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">5、运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">&amp;和&amp;&amp;的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">6、关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java-%E6%9C%89%E6%B2%A1%E6%9C%89-goto"><span class="toc-text">1. Java 有没有 goto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-final-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">2. final 有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-final-finally-finalize%E5%8C%BA%E5%88%AB"><span class="toc-text">3.final finally finalize区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">4. this关键字的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">5. super关键字的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-this%E4%B8%8Esuper%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">6. this与super的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-static%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E6%84%8F%E4%B9%89"><span class="toc-text">7. static存在的主要意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-static%E7%9A%84%E7%8B%AC%E7%89%B9%E4%B9%8B%E5%A4%84"><span class="toc-text">8. static的独特之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-static%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">9. static应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-static%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">10. static注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">7、流程控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81break-continue-return-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-text">1、break ,continue ,return 的区别及作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8-Java-%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%BD%93%E5%89%8D%E7%9A%84%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="toc-text">2. 在 Java 中，如何跳出当前的多重嵌套循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">三、面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">1、面向对象概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">面向对象和面向过程的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">2、面向对象三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2"><span class="toc-text">1. 面向对象的特征有哪些方面</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-text">抽象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java%E8%AF%AD%E8%A8%80%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%EF%BC%9F"><span class="toc-text">2. Java语言是如何实现多态的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">多态的实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="toc-text">3. 面向对象五大基本原则是什么（可选）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-text">3、类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">1.抽象类和接口的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2. 普通类和抽象类有哪些区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%83%BD%E4%BD%BF%E7%94%A8-final-%E4%BF%AE%E9%A5%B0%E5%90%97%EF%BC%9F"><span class="toc-text">3. 抽象类能使用 final 修饰吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">4. 创建一个对象用什么关键字？对象实例与对象引用有何不同？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-text">4、变量与方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">1. 成员变量与局部变量的区别有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-text">存储位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-text">初始值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-text">使用原则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8Java%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">2. 在Java中定义一个不做事且没有参数的构造方法的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E5%89%8D%E4%BC%9A%E5%85%88%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E5%85%B6%E7%9B%AE%E7%9A%84%E6%98%AF%EF%BC%9F"><span class="toc-text">3. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%8B%A5%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E6%94%B9%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">5. 构造方法有哪些特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%8C%BA%E5%88%AB"><span class="toc-text">6.静态变量和实例变量区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">5、内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F"><span class="toc-text">1. 什么是内部类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">2. 内部类的分类有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">3. 内部类的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%86%85%E9%83%A8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4. 内部类有哪些应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E8%AE%BF%E9%97%AE%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E8%A6%81%E5%8A%A0%E4%B8%8Afinal%EF%BC%9F"><span class="toc-text">5. 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD"><span class="toc-text">6、重写与重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88constructor%EF%BC%89%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%88override%EF%BC%89"><span class="toc-text">1. 构造器（constructor）是否可被重写（override）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89%E5%92%8C%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82%E9%87%8D%E8%BD%BD%E7%9A%84%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E6%A0%B9%E6%8D%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86%EF%BC%9F"><span class="toc-text">2. 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD"><span class="toc-text">7、对象相等判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1. &#x3D;&#x3D; 和 equals 的区别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-hashCode-%E4%B8%8E-equals-%E9%87%8D%E8%A6%81"><span class="toc-text">2. hashCode 与 equals (重要)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-text">8、值传递</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BD%93%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%A2%AB%E5%BD%93%E4%BD%9C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%8E%EF%BC%8C%E6%AD%A4%E6%96%B9%E6%B3%95%E5%8F%AF%E6%94%B9%E5%8F%98%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%B9%B6%E5%8F%AF%E8%BF%94%E5%9B%9E%E5%8F%98%E5%8C%96%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E9%87%8C%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-text">1.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-text">2.为什么 Java 中只有值传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">3.值传递和引用传递有什么区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81Java%E5%8C%85"><span class="toc-text">9、Java包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-JDK-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">1. JDK 中常用的包有哪些</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-import-java%E5%92%8Cjavax%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">2.import java和javax有什么区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81IO%E6%B5%81"><span class="toc-text">四、IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81java-%E4%B8%AD-IO-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D"><span class="toc-text">1、java 中 IO 流分为几种?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Files%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">2、Files的常用方法都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3、字节流和字符流的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">4、转换流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-text">5、打印流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="toc-text">6、序列化流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8F%8D%E5%B0%84"><span class="toc-text">五、反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">1、什么是反射机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2、反射机制优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">3、 反射机制的应用场景有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Java%E8%8E%B7%E5%8F%96%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">4、Java获取反射的三种方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">六、网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1、网络协议是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AF%B9%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-text">2、为什么要对网络协议分层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81TCP-UDP%E5%8D%8F%E8%AE%AE"><span class="toc-text">3、TCP&#x2F;UDP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81UDP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F"><span class="toc-text">4、UDP通信程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81UDP%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-text">1、UDP发送数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81UDP%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-text">2、UDP接收数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81UDP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F%E7%BB%83%E4%B9%A0"><span class="toc-text">3、UDP通信程序练习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81UDP%E4%B8%89%E7%A7%8D%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F"><span class="toc-text">4、UDP三种通讯方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81UDP%E7%BB%84%E6%92%AD%E5%AE%9E%E7%8E%B0"><span class="toc-text">5、UDP组播实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81UDP%E5%B9%BF%E6%92%AD%E5%AE%9E%E7%8E%B0"><span class="toc-text">6、UDP广播实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81TCP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F"><span class="toc-text">5、TCP通信程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81TCP%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-text">1、TCP发送数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81TCP%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-text">2、TCP接收数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81TCP%E7%A8%8B%E5%BA%8F%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BC%A0%E8%BE%93%E4%B8%AD%E6%96%87%EF%BC%89"><span class="toc-text">3、TCP程序练习（传输中文）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">七、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">1、线程和进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">2、线程调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-text">3、同步与异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-text">4、并发与并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">5、实现多线程的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BB%A7%E6%89%BFThread"><span class="toc-text">1、继承Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-text">2、实现Runnable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Callable%E6%8E%A5%E5%8F%A3"><span class="toc-text">3、Callable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81Runnable%E4%B8%8ECallable"><span class="toc-text">1、Runnable与Callable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81Callable%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-text">2、Callable使用步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Thread%E7%B1%BB"><span class="toc-text">6、Thread类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0"><span class="toc-text">1、设置和获取线程名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="toc-text">2、线程休眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E-interrupt"><span class="toc-text">3、线程阻塞 interrupt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">4、守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">5、线程安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-text">1、线程不安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">2、线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A81-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">1、实现线程安全1-同步代码块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A82-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-text">2、实现线程安全2-同步方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A83-Lock%E9%94%81"><span class="toc-text">3、实现线程安全3-Lock锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">7、公平锁与非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-text">8、线程死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81-%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">9、 悲观锁和乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">10、生产者与消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">11、线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">线程池的好处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81volatitle%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">12、volatitle关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%B8%B8%E7%94%A8API"><span class="toc-text">八、常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81String%E7%9B%B8%E5%85%B3"><span class="toc-text">1、String相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1、字符型常量和字符串常量的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-text">2、什么是字符串常量池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81String-%E6%98%AF%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="toc-text">3、String 是最基本的数据类型吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81String%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7"><span class="toc-text">4、String有哪些特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">5、String为什么是不可变的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81String%E7%9C%9F%E7%9A%84%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">6、String真的是不可变的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF-String-%E7%B1%BB"><span class="toc-text">7、是否可以继承 String 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81String-str-%E2%80%9Di%E2%80%9D%E4%B8%8E-String-str-new-String-%E2%80%9Ci%E2%80%9D-%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F"><span class="toc-text">8、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81String-s-new-String-%E2%80%9Cxyz%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-text">9、String s &#x3D; new String(“xyz”);创建了几个字符串对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F"><span class="toc-text">10、如何将字符串反转？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E6%95%B0%E7%BB%84%E6%9C%89%E6%B2%A1%E6%9C%89-length-%E6%96%B9%E6%B3%95%EF%BC%9FString-%E6%9C%89%E6%B2%A1%E6%9C%89-length-%E6%96%B9%E6%B3%95"><span class="toc-text">11、数组有没有 length()方法？String 有没有 length()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81String-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="toc-text">12、String 类的常用方法都有那些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E5%9C%A8%E4%BD%BF%E7%94%A8-HashMap-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%94%A8-String-%E5%81%9A-key-%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-text">13、在使用 HashMap 的时候，用 String 做 key 有什么好处？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81String%E5%92%8CStringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FString%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="toc-text">14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Date%E7%9B%B8%E5%85%B3"><span class="toc-text">2、Date相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9B%B8%E5%85%B3"><span class="toc-text">3、包装类相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-text">1、自动装箱与拆箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81int-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">2、int 和 Integer 有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Integer-a-127-%E4%B8%8E-Integer-b-127%E7%9B%B8%E7%AD%89%E5%90%97%EF%BC%9F"><span class="toc-text">3、Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/01/Spring5/" title="Spring5"><img src="/img/loading.gif" data-original="/img/S5_C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring5"/></a><div class="content"><a class="title" href="/2024/06/01/Spring5/" title="Spring5">Spring5</a><time datetime="2024-06-01T07:38:08.000Z" title="发表于 2024-06-01 15:38:08">2024-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/21/Vue3/" title="Vue3"><img src="/img/loading.gif" data-original="/img/V3-TT.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue3"/></a><div class="content"><a class="title" href="/2024/05/21/Vue3/" title="Vue3">Vue3</a><time datetime="2024-05-21T09:37:58.000Z" title="发表于 2024-05-21 17:37:58">2024-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/14/SpringCloud/" title="SpringCloud"><img src="/img/loading.gif" data-original="/img/SC_C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloud"/></a><div class="content"><a class="title" href="/2024/05/14/SpringCloud/" title="SpringCloud">SpringCloud</a><time datetime="2024-05-14T13:42:22.000Z" title="发表于 2024-05-14 21:42:22">2024-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/14/Netty/" title="Netty"><img src="/img/loading.gif" data-original="/img/TT_C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty"/></a><div class="content"><a class="title" href="/2024/05/14/Netty/" title="Netty">Netty</a><time datetime="2024-05-14T13:42:13.000Z" title="发表于 2024-05-14 21:42:13">2024-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/14/Nginx/" title="Nginx"><img src="/img/loading.gif" data-original="/img/N_C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx"/></a><div class="content"><a class="title" href="/2024/05/14/Nginx/" title="Nginx">Nginx</a><time datetime="2024-05-14T13:41:30.000Z" title="发表于 2024-05-14 21:41:30">2024-05-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/JavaSE_top.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 楞</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/%5Bobject%20Object%5D"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="L1n,L1n,L1n" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>