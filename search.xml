<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring5</title>
      <link href="/2024/06/01/Spring5/"/>
      <url>/2024/06/01/Spring5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1. Spring"></a>1. Spring</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><ul><li><p>Spring：春天</p></li><li><p>2002，首次推出了Spring的出行：interface21框架！</p></li><li><p>Spring框架即以interface21框架为基础，经过重新设计，并不断丰富其内涵，雨2004</p></li><li><p>年3月24日，发布了1.0正式版</p></li><li><p>Rod Johnson，SpringFarmework创始人</p></li><li><p>spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！</p></li><li><p>SSH：Struct2 + Spring + Hibernate （Spring没出来以前）</p></li><li><p>SSM：SpringMvc + Spring + Mybatis</p></li></ul><p>官网： <a href="https://spring.io/projects/spring-framework#overview">https://spring.io/projects/spring-framework#overview</a></p><p>GitHub：<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">6.1</span><span class="number">.8</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h2><ul><li>Spring 是一个开源的免费框架（容器）</li><li>Spring 是一公分轻量级的、非入侵式的框架</li><li>控制反转（IOC）、面向切面编程（AOP）</li><li>支持事务的处理，对框架整合的支持</li></ul><p>&#x3D;&#x3D;总结一句话：Spring就是一个轻量级的控制反转 （IOC）和面向切面编程 （AOP）的框架！&#x3D;&#x3D;</p><h2 id="1-3-组成"><a href="#1-3-组成" class="headerlink" title="1.3 组成"></a>1.3 组成</h2><p><img src="/.com//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MDgzNDQ3,size_16,color_FFFFFF,t_70.png" alt="20200524094945335.png (./../../../../Typora笔记/Spring5/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MDgzNDQ3,size_16,color_FFFFFF,t_70.png)"></p><h2 id="1-4-拓展"><a href="#1-4-拓展" class="headerlink" title="1.4 拓展"></a>1.4 拓展</h2><p>现代化的 Java开发 ，说白了就是基于Spring开发</p><p><img src="/.com//image-20240529194443896.png" alt="image-20240529194443896"></p><ul><li>Spring Boot<ul><li>一个快速开发的脚手架</li><li>基于SpringBoot可以快速的开发单个微服务</li><li>约定大于配置！</li></ul></li><li>Spring Cloud<ul><li>Spring Cloud 是基于SpringBoot 实现的</li></ul></li></ul><p>现在大多数都在使用SpringBoot开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMvc！承上启下的作用！</p><p>弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，人称 “配置地狱！”</p><h1 id="2-IOC理论推导"><a href="#2-IOC理论推导" class="headerlink" title="2. IOC理论推导"></a>2. IOC理论推导</h1><ol><li><p>UserDao接口</p></li><li><p>UserDaoImpl业务实现</p></li><li><p>UserService接口</p></li><li><p>UserServiceImpl业务实现</p></li></ol><p>UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDaoImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDaoImpl获取用户数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.raehp.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.raehp.dao.UserDaoImpl;</span><br><span class="line"><span class="keyword">import</span> org.raehp.dao.UserMySQLImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserMySqlDao</span>(); <span class="comment">// 每次如果业务变更 代码就要更改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserOracleDao</span>();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        </span><br><span class="line">        userService.getUser(); <span class="comment">// 每次业务变更，就要去更改业务实现类中的源代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240529204410333.png" alt="image-20240529204410333"></p><p>在我们之前的业务中，用户的需求可能会影响我们原来的代码。我们需要根据用户的需求去修改源代码！如果程序代码量十分大，修改一次的成本代价十分昂贵</p><p>我们使用一个set接口实现，已经发生了革命性的变化</p><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">        ((UserServiceImpl) userService).setUserDao(<span class="keyword">new</span> <span class="title class_">UserMySQLImpl</span>());</span><br><span class="line">        userService.getUser();  <span class="comment">// 不需要变更源代码 只需要更改这里的setUserDao的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240529204419740.png" alt="image-20240529204419740"></p><ul><li>之前是主动创建对象！控制权在程序员手上</li><li>使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！</li></ul><p>这种思想，本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低~可以更加专注的在业务的实现上！这是IOC的原型！</p><h2 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h2><p>控制反转IoC（Inversion of Control）是一种设计思想，DI（依赖注入）是实现IoC的一种方法，也有人认为DI知识IoC的另一种说法，没有Ioc的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p><p>采用XML的方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p><p><strong>控制反转是一种通过描述 (XML或注解) 并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是loC容器，其实现方法是依赖注入(DependencyIniection,Dl)</strong></p><h1 id="3-Hello-Srping"><a href="#3-Hello-Srping" class="headerlink" title="3. Hello Srping"></a>3. Hello Srping</h1><p>创建Hello.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在resources 下创建 <code>beans.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    使用Spring来创建对象，在Spring这些都成为Bean</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    类型 变量名 = new 类型()</span></span><br><span class="line"><span class="comment">    Hello hello = new Hello()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    id = 变量名</span></span><br><span class="line"><span class="comment">    class = new 的对象</span></span><br><span class="line"><span class="comment">    property 相当于给对象中的属性设置一个值！</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.raehp.pojo.Hello;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取Spring的上下文对象！</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 我们的对象现在都在Spring中的管理了，我们要使用，直接去里面取出来就可以了！</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) context.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考问题？"><a href="#思考问题？" class="headerlink" title="思考问题？"></a>思考问题？</h2><ul><li>Hello 对象是谁创建的？<ul><li>hello 对象是由Spring创建的</li></ul></li><li>Hello 对象的属性是怎么设置的？<ul><li>hello 对象的属性是由Sring容器设置的</li></ul></li></ul><p><strong>这个过程就叫控制反转：</strong></p><p>控制：谁来控制对象的创建，传统应用程序的对象室友程序本身控制创建的，使用Spring后，对象是由Spring来创建的</p><p>反转：程序本身不创建对象，而变成被动的接收对象</p><p>依赖注入：就是利用set方法进行注入的</p><p>IOC是一种编程思想：由主动的编程变成被动的接收</p><p>可以通过new ClassPathXmlApplicationContext 去浏览一下底层源码</p><h1 id="4-IOC容器创建的方式"><a href="#4-IOC容器创建的方式" class="headerlink" title="4. IOC容器创建的方式"></a>4. IOC容器创建的方式</h1><ol><li><p>使用无参构造创建对象，<strong>默认</strong>！</p></li><li><p>假设我们要使用有参构造创建对象</p><ol><li><p>下标赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--   使用下标赋值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;昊郝好&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>参数类型赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--   第二种：参数类型赋值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.pojo.User&quot;</span>&gt;</span>--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;郝昊好&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>参数名赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--   第三种：参数名赋值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;好昊郝昊郝&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><p>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！</p><h1 id="5-Spring-配置"><a href="#5-Spring-配置" class="headerlink" title="5. Spring 配置"></a>5. Spring 配置</h1><h2 id="5-1-别名"><a href="#5-1-别名" class="headerlink" title="5.1 别名"></a>5.1 别名</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--别名，如果添加了别名，我们也可以是使用别名获取到这个对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;userNew&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-2-Bean的配置"><a href="#5-2-Bean的配置" class="headerlink" title="5.2 Bean的配置"></a>5.2 Bean的配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">id：bean 的唯一标识符，也就是相当于我们学的对象名</span></span><br><span class="line"><span class="comment">class：bean 对象所对应的全限定名：包名 + 类型</span></span><br><span class="line"><span class="comment">name：也是别名，而且name 可以同时取多个别名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.raehp.pojo.User&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user2 u2,u3;u4&quot;</span>&gt;</span>// 可以用空格，；分割</span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;西部开源&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-3-import"><a href="#5-3-import" class="headerlink" title="5.3 import"></a>5.3 import</h2><p>import，一般用于团队开发使用，他可以将多个配置文件，导入合并为一个</p><p>假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类型需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的</p><ul><li>张三</li><li>李四</li><li>王五</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;base.xml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;base2.xml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;base3.xml&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用的时候，直接使用总的配置就可以了</p><h1 id="6-依赖注入"><a href="#6-依赖注入" class="headerlink" title="6. 依赖注入"></a>6. 依赖注入</h1><h2 id="6-1-构造器注入"><a href="#6-1-构造器注入" class="headerlink" title="6.1 构造器注入"></a>6.1 构造器注入</h2><p>前面已经说过了</p><h2 id="6-2-Set方式注入"><a href="#6-2-Set方式注入" class="headerlink" title="6.2 Set方式注入"></a>6.2 Set方式注入</h2><ul><li>依赖注入<ul><li>依赖：bean对象的创建依赖于容器</li><li>注入：bean对象中所有的属性，由容器来注入</li></ul></li></ul><p>【环境搭建】</p><ol><li><p>复杂类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>真实测试对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>application.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第一种普通值注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张某&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完善注入信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.pojo.Address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;河北&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第一种注入：普通值注入，value--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张某&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第二种注入，Bean注入，ref--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第三种注入：数组注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>石昊<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>石毅<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>石冠王<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>石骸仙帝<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第四种注入：集合注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbys&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>呸呸呸<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>哦哦哦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>呃呃呃<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第五种注入：Map注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;姓名&quot;</span> <span class="attr">value</span>=<span class="string">&quot;石昊&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;宝术&quot;</span> <span class="attr">value</span>=<span class="string">&quot;鲲鹏宝术，柳神法，朱雀宝术&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;能力&quot;</span> <span class="attr">value</span>=<span class="string">&quot;天生至尊骨&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;实力&quot;</span> <span class="attr">value</span>=<span class="string">&quot;祭道之上&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第六种注入：Set注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>请请请<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>呜呜呜<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>鹅鹅鹅<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>日日日<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第七种注入：null--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第八种注入：Properties注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;stuId&quot;</span>&gt;</span>202202093<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span>&gt;</span>郝亚涵<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;gender&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="6-3-拓展方式注入"><a href="#6-3-拓展方式注入" class="headerlink" title="6.3 拓展方式注入"></a>6.3 拓展方式注入</h2><p>我们可以使用p命令空间和c命令空间进行注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>          <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!--p命名空间注入，可以直接注入属性的值：property--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.pojo.User&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--c命名空间注入，构造器注入：construct-args--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;李四&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-4-Bean的作用域"><a href="#6-4-Bean的作用域" class="headerlink" title="6.4 Bean的作用域"></a>6.4 Bean的作用域</h2><table><thead><tr><th>作用域</th><th>描述</th></tr></thead><tbody><tr><td>singleton</td><td>在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。</td></tr><tr><td>prototype</td><td>每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</td></tr><tr><td>request</td><td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的Spring WebApplicationContext环境。</td></tr><tr><td>session</td><td>session同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅于web的Spring WebApplicationContext环境。</td></tr><tr><td>application</td><td>限定一个Bean的作用域为ServletContext的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。</td></tr></tbody></table><ol><li><p>单例模式（Spring默认机制）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.raehp.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>原型模式：每次从容器中get的时候，都会产生一个新对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.raehp.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>其余的request、session、application、这些只能在web开发中使用！</p></li></ol><h1 id="7-Bean的自动装配"><a href="#7-Bean的自动装配" class="headerlink" title="7. Bean的自动装配"></a>7. Bean的自动装配</h1><ul><li>自动装配是Spring满足bean依赖的一种方式</li><li>Spring会在上下文中自动寻找，并自动给给bean装配属性</li></ul><p>在Spring中有三种装配的方式</p><ol><li>在xml中显示的配置</li><li>在java中显示配置</li><li>饮食的自动装配bean【⭐⭐⭐⭐⭐】</li></ol><h2 id="7-1-测试"><a href="#7-1-测试" class="headerlink" title="7.1 测试"></a>7.1 测试</h2><p>环境搭建：一个人有两个动物</p><h2 id="7-2-ByName自动装配"><a href="#7-2-ByName自动装配" class="headerlink" title="7.2 ByName自动装配"></a>7.2 ByName自动装配</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">byName：会自动在容器上下文中寻找，和自己对象set方法后面的值对应的beanId</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.Dog&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.Cat&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.People&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;郝部长&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-3-ByType"><a href="#7-3-ByType" class="headerlink" title="7.3 ByType"></a>7.3 ByType</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">byType：会自动在容器上下文中寻找，和自己的对象属性类型相同的bean</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.Dog&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.Cat&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.People&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;郝部长&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小结：</p><ul><li>byName的时候，要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！</li><li>byType的时候，要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！</li></ul><h2 id="7-4-注解实现自动装配"><a href="#7-4-注解实现自动装配" class="headerlink" title="7.4 注解实现自动装配"></a>7.4 注解实现自动装配</h2><p>jdk1.5 支持的注解，Spring2.5就支持注解了</p><p>要使用注解须知：</p><ol><li>导入约束：context约束</li><li>&#x3D;&#x3D;配置注解的支持：context:annotion-config&#x2F;&#x3D;&#x3D;</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>@Autowired</strong></p><p>直接在属性上使用即可！也可以在set方式上使用</p><p>使用Autowired 我们可以不用编写set方法了，前提是你这个自动装配的属性在 IOC（Spring）容器中存在，且符合名字byName！</p><p>科普：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span>字段标记了这个注解，说明这个字段可以为<span class="literal">null</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">required</span><span class="params">()</span> defalut <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="comment">// 如果显示定义了Autowired用require属性为false，则说明这个对象可以为空</span></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果@Autowired 自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value&#x3D;”xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;cat11&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;dog222&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Resource 注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"><span class="meta">@Resource(value = &quot;cat2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Dog dog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>@Resource 和 @Autowired 的区别：</p><ul><li>都是用来自动装配的，都可以放在属性字段上</li><li>@Autowired 通过 byType 的方式实现，而且必须要求这个对象存在！【常用】</li><li>@Resource 默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错【常用】</li><li>执行顺序不同：@Autowired 通过byType的方式实现， @Resource 通过byName的方式实现</li></ul><h1 id="8-使用注解开发"><a href="#8-使用注解开发" class="headerlink" title="8. 使用注解开发"></a>8. 使用注解开发</h1><p>在spring 4之后，要使用注解开发，一定要确认aop包导入了</p><p><img src="/.com//image-20240531143328638.png" alt="image-20240531143328638"></p><p>使用注解要导入context 的约束</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>bean</p></li><li><p>属性如何注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于&lt;property name=&quot;name&quot; value=&quot;raehp&quot;&gt;</span></span><br><span class="line"><span class="meta">@Value(&quot;raehp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注解的衍生</p><p>@Component 有几个衍生注解，我们在web开发中，会按照mvc三层架构分层！</p><ul><li>dao 【@Reposity】</li><li>service 【@Service】</li><li>controller【@Controller】</li></ul></li></ol><p>​这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean</p><ol start="4"><li><p>自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="meta">@Autowired</span>：自动装配通过类型，名字</span><br><span class="line">    如果Autowired不能唯一自动装配上属性，则需要通过<span class="meta">@Qualifier(value=&quot;xxx&quot;)</span></span><br><span class="line">- <span class="meta">@Nullable</span>字段标记了这个注解，说明这个字段可以为<span class="literal">null</span></span><br><span class="line">- <span class="meta">@Resource</span>：自动装配通过名字。类型</span><br></pre></td></tr></table></figure></li><li><p>作用域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于&lt;property name=&quot;name&quot; value=&quot;raehp&quot;&gt;</span></span><br><span class="line"><span class="meta">@Value(&quot;raehp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>小结</p><p>xml于注解：</p><ul><li>xml更加万能，适用于任何场合！维护简单方便</li><li>注解不是自己类使用不了，维护相对复杂</li></ul><p>xml 与 注解最佳实践：</p><ul><li><p>xml用来管理bean</p></li><li><p>注解只负责完成属性的注入</p></li><li><p>我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul></li></ol><p></p><h1 id="9-使用Java的方式配置Spring"><a href="#9-使用Java的方式配置Spring" class="headerlink" title="9. 使用Java的方式配置Spring"></a>9. 使用Java的方式配置Spring</h1><p>我们现在要完全不适用Spring的xml配置了，全权交给Java来做！</p><p>JavaConfig 是Spring 的一个子项目，在Spring 4 之后，他成为了一个核心功能！</p><p><img src="/.com//image-20240531152029910.png" alt="image-20240531152029910"></p><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;kkkkkk&quot;)</span> <span class="comment">//注入属性值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.raehp.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;org.raehp.pojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 这个方法的名字，就相当于bean标签中的id属性</span></span><br><span class="line">    <span class="comment">// 这个方法的返回值，就相当于bean标签中的class属性</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(); <span class="comment">// 就是返回要注入到bean的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> junit.framework.Test;</span><br><span class="line"><span class="keyword">import</span> junit.framework.TestCase;</span><br><span class="line"><span class="keyword">import</span> junit.framework.TestSuite;</span><br><span class="line"><span class="keyword">import</span> org.raehp.config.JavaConfig;</span><br><span class="line"><span class="keyword">import</span> org.raehp.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        如果完全使用了配置类的方式去做，我们就只能通过 AnnotationConfig 上下文来获取容器，通过配置类的class对象加载！</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(JavaConfig.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;getUser&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-代理模式"><a href="#10-代理模式" class="headerlink" title="10. 代理模式"></a>10. 代理模式</h1><h2 id="10-1-静态代理"><a href="#10-1-静态代理" class="headerlink" title="10.1 静态代理"></a>10.1 静态代理</h2><p>角色分析：</p><ul><li>抽象角色：一般会使用接口活着抽象类来解决</li><li>真实角色：被代理的角色</li><li>代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作</li><li>客户：访问代理对象的人</li></ul><p><img src="/.com//image-20240531171723027.png" alt="image-20240531171723027"></p><p>代码步骤</p><ol><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 租客</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">rent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>真实角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 房东</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Host</span> <span class="keyword">implements</span> <span class="title class_">rent</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东出租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中介（代理）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">proxy</span> <span class="keyword">implements</span> <span class="title class_">rent</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">proxy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">proxy</span><span class="params">(Host host)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东出租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seeHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东带你看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fee</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收中介费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeHT</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;签合同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端访问代理角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 房东要租房子</span></span><br><span class="line">        <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Host</span>();</span><br><span class="line">        <span class="comment">// 代理，中介帮房东租房子，但是呢？代理一般会有一些附属操作</span></span><br><span class="line">        <span class="type">proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">proxy</span>(host);</span><br><span class="line">        <span class="comment">// 你不用面对房东，直接找中介租房即可！</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>代理模式的好处：</p><ul><li>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务</li><li>公共也就交代给代理角色！实现了业务的分工！</li><li>公共业务发生扩展的时候，方便集中管理！</li></ul><p>缺点：</p><ul><li>一个真实角色就会产生一个代理角色；代码量会翻倍开发效率会变低！</li></ul><h2 id="10-2-动态代理"><a href="#10-2-动态代理" class="headerlink" title="10.2 动态代理"></a>10.2 动态代理</h2><ul><li>动态代理和静态代理角色一样</li><li>动态代理的代理类是动态生成的，不是我们直接写好的</li><li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理<ul><li>基于接口 — JDK 动态代理 【我们在这里使用】</li><li>基于类：cglib</li><li>java字节码实现：javasist、</li></ul></li></ul><p>需要了解两个类：</p><ul><li>Proxy：代理</li><li>InvocationHandler：调用处理程序</li></ul><p>实现：</p><p>ProxyInvocationHandler类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动生成代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成得到代理类</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getTarget</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 处理代理实例，并返回结果</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log(method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了&quot;</span> + msg + <span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 真实角色</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="comment">// 代理角色，不存在</span></span><br><span class="line">        <span class="type">ProxyInvocationHandler</span> <span class="variable">pih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>();</span><br><span class="line">        pih.setTarget(userService); <span class="comment">// 设置要代理的对象</span></span><br><span class="line">        <span class="comment">// 动态生成代理类</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) pih.getTarget();</span><br><span class="line">        proxy.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用了query方法</span><br><span class="line">查询所有成员</span><br></pre></td></tr></table></figure><p>动态代理的好处：</p><ul><li>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务</li><li>公共也就交代给代理角色！实现了业务的分工！</li><li>公共业务发生扩展的时候，方便集中管理！</li><li>一个动态代理类代理的是一个接口，一般就是对应的一类义务</li><li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可</li></ul><h1 id="11-AOP"><a href="#11-AOP" class="headerlink" title="11. AOP"></a>11. AOP</h1><h2 id="11-1-什么是AOP"><a href="#11-1-什么是AOP" class="headerlink" title="11.1 什么是AOP"></a>11.1 什么是AOP</h2><p>AOP (Aspect Oriented Programming)意为:面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p><img src="/.com//image-20240601133611121.png" alt="image-20240601133611121"></p><p><img src="/.com//image-20240601133631538.png" alt="image-20240601133631538"></p><h2 id="11-2-AOP在Spring中的应用"><a href="#11-2-AOP在Spring中的应用" class="headerlink" title="11.2 AOP在Spring中的应用"></a>11.2 AOP在Spring中的应用</h2><p>&#x3D;&#x3D;提供声明式事务：允许用户自定义切面&#x3D;&#x3D;</p><p>横切关注点:跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存,事务等等 ..</p><ul><li>切面(ASPECT)：横切关注点 被模块化 的特殊对象。即，它是一个类.</li><li>通知(Advice)：切面必须要完成的工作。即，它是类中的一个方法。</li><li>目标(Target)：被通知对象。</li><li>代理(Proxy)：向目标对象应用通知之后创建的对象。</li><li>切入点(Pointcut)：切面通知 执行的“地点”的定义。</li><li>连接点(JointPoint)：与切入点匹配的执行点。</li></ul><p><img src="/.com//image-20240601133835027.png" alt="image-20240601133835027"></p><h2 id="11-3-使用Spring实现AOP"><a href="#11-3-使用Spring实现AOP" class="headerlink" title="11.3 使用Spring实现AOP"></a>11.3 使用Spring实现AOP</h2><h3 id="11-3-1-方式一：使用spring-的api接口"><a href="#11-3-1-方式一：使用spring-的api接口" class="headerlink" title="11.3.1 方式一：使用spring 的api接口"></a>11.3.1 方式一：使用spring 的api接口</h3><p>导入aop的依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.9</span><span class="number">.7</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Log类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(target.getClass().getName() + <span class="string">&quot;的&quot;</span> + method.getName() + <span class="string">&quot;方法运行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AfterLog类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AfterLog</span> <span class="keyword">implements</span> <span class="title class_">AfterReturningAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(target.getClass().getName() + <span class="string">&quot;的&quot;</span> + method.getName() + <span class="string">&quot;方法执行了&quot;</span> + <span class="string">&quot;返回了&quot;</span> + returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.log.Log&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.log.AfterLog&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.service.UserServiceImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    方式一：使用原生spring api 接口--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置aop：需要导入aop的约束--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        切入点： expression：表达式， execution(要执行的位置! * * * * *)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* org.raehp.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        执行环绕增加！--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="11-3-2-自定义类来实现aop"><a href="#11-3-2-自定义类来实现aop" class="headerlink" title="11.3.2 自定义类来实现aop"></a>11.3.2 自定义类来实现aop</h3><p>diyPointCut【主要是切面定义】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.diy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiyPointCut</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span> <span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span> <span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.service.UserServiceImpl&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.diy.DiyPointCut&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;point&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* org.raehp.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;point&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;point&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="11-3-3-使用注解配置aop"><a href="#11-3-3-使用注解配置aop" class="headerlink" title="11.3.3 使用注解配置aop"></a>11.3.3 使用注解配置aop</h3><p>application.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--    方式三：注解--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;AnnotationPointCut&quot;</span> class=<span class="string">&quot;org.raehp.Annotation.AnnotationPointCut&quot;</span> /&gt;</span><br><span class="line">&lt;!--    开启注解支持！ JDK（默认 proxy-target-class=<span class="string">&quot;false&quot;</span>） cglib（proxy-target-class=<span class="string">&quot;true&quot;</span>）--&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy /&gt;</span><br></pre></td></tr></table></figure><p>AnnotationPointCut</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用注解配置aop</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationPointCut</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* org.raehp.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span> <span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* org.raehp.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span> <span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-整合Mybatis"><a href="#12-整合Mybatis" class="headerlink" title="12. 整合Mybatis"></a>12. 整合Mybatis</h1><p>步骤：</p><ol><li>导入相关jar包<ul><li>junit</li><li>mybatis</li><li>mysql数据库</li><li>spring相关的</li><li>aop植入</li><li>mybatis-spring 【new】</li></ul></li><li>编写配置文件</li><li>测试</li></ol><p>导入maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="12-1-回忆mybatis"><a href="#12-1-回忆mybatis" class="headerlink" title="12.1 回忆mybatis"></a>12.1 回忆mybatis</h2><ol><li>编写实体类</li><li>编写核心配置文件</li><li>编写接口</li><li>编Mapper.xml</li><li>测试</li></ol><p>UserMapper.interface</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.raehp.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.raehp.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis-config.cml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.raehp.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/student&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.raehp.mapper.UserMapper&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.raehp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.raehp.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.raehp.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; userList = mapper.selectUser();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3</title>
      <link href="/2024/05/21/Vue3/"/>
      <url>/2024/05/21/Vue3/</url>
      
        <content type="html"><![CDATA[<h1 id="认识Vue3"><a href="#认识Vue3" class="headerlink" title="认识Vue3"></a>认识Vue3</h1><h2 id="1-Vue2-选项式-API-vs-Vue3-组合式API"><a href="#1-Vue2-选项式-API-vs-Vue3-组合式API" class="headerlink" title="1. Vue2 选项式 API vs Vue3 组合式API"></a>1. Vue2 选项式 API vs Vue3 组合式API</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count:0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    addCount()&#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">const count = ref(0)</span><br><span class="line">const addCount = ()=&gt; count.value++</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>代码量变少</li><li>分散式维护变成集中式维护</li></ol><h2 id="2-Vue3的优势"><a href="#2-Vue3的优势" class="headerlink" title="2. Vue3的优势"></a>2. Vue3的优势</h2><p><img src="/.com//01.png" alt="01"></p><h1 id="使用create-vue搭建Vue3项目"><a href="#使用create-vue搭建Vue3项目" class="headerlink" title="使用create-vue搭建Vue3项目"></a>使用create-vue搭建Vue3项目</h1><h2 id="1-认识create-vue"><a href="#1-认识create-vue" class="headerlink" title="1. 认识create-vue"></a>1. 认识create-vue</h2><blockquote><p>create-vue是Vue官方新的脚手架工具，底层切换到了 vite （下一代前端工具链），为开发提供极速响应</p></blockquote><p><img src="/.com//2.png" alt="2"></p><h2 id="2-使用create-vue创建项目"><a href="#2-使用create-vue创建项目" class="headerlink" title="2. 使用create-vue创建项目"></a>2. 使用create-vue创建项目</h2><blockquote><p>前置条件 - 已安装16.0或更高版本的Node.js</p></blockquote><p>执行如下命令，这一指令将会安装并执行 create-vue</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init vue@latest</span><br></pre></td></tr></table></figure><p><img src="/.com//3.png" alt="3"></p><h1 id="熟悉项目和关键文件"><a href="#熟悉项目和关键文件" class="headerlink" title="熟悉项目和关键文件"></a>熟悉项目和关键文件</h1><p><img src="/.com//4.png" alt="4"></p><h1 id="组合式API-setup选项"><a href="#组合式API-setup选项" class="headerlink" title="组合式API - setup选项"></a>组合式API - setup选项</h1><h2 id="1-setup选项的写法和执行时机"><a href="#1-setup选项的写法和执行时机" class="headerlink" title="1. setup选项的写法和执行时机"></a>1. setup选项的写法和执行时机</h2><p>写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    beforeCreate()&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>执行时机</p><blockquote><p>在beforeCreate钩子之前执行</p></blockquote><p><img src="/.com//5.png" alt="5"></p><h2 id="2-setup中写代码的特点"><a href="#2-setup中写代码的特点" class="headerlink" title="2. setup中写代码的特点"></a>2. setup中写代码的特点</h2><blockquote><p>在setup函数中写的数据和方法需要在末尾以对象的方式return，才能给模版使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line">      const message = &#x27;this is message&#x27;</span><br><span class="line">      const logMessage = ()=&gt;&#123;</span><br><span class="line">        console.log(message)</span><br><span class="line">      &#125;</span><br><span class="line">      // 必须return才可以</span><br><span class="line">      return &#123;</span><br><span class="line">        message,</span><br><span class="line">        logMessage</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-语法糖"><a href="#3-语法糖" class="headerlink" title="3. 语法糖"></a>3. <script setup>语法糖</h2><blockquote><p>script标签添加 setup标记，不需要再写导出语句，默认会添加导出语句</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  const message = &#x27;this is message&#x27;</span><br><span class="line">  const logMessage = ()=&gt;&#123;</span><br><span class="line">    console.log(message)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="组合式API-reactive和ref函数"><a href="#组合式API-reactive和ref函数" class="headerlink" title="组合式API - reactive和ref函数"></a>组合式API - reactive和ref函数</h1><h2 id="1-reactive"><a href="#1-reactive" class="headerlink" title="1. reactive"></a>1. reactive</h2><blockquote><p>接受<strong>对象类型数据</strong>的参数传入并返回一个响应式的对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"> // 导入</span><br><span class="line"> import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"> // 执行函数 传入参数 变量接收</span><br><span class="line"> const state = reactive(&#123;</span><br><span class="line">   msg:&#x27;this is msg&#x27;</span><br><span class="line"> &#125;)</span><br><span class="line"> const setSate = ()=&gt;&#123;</span><br><span class="line">   // 修改数据更新视图</span><br><span class="line">   state.msg = &#x27;this is new msg&#x27;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &#123;&#123; state.msg &#125;&#125;</span><br><span class="line">  &lt;button @click=&quot;setState&quot;&gt;change msg&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="2-ref"><a href="#2-ref" class="headerlink" title="2. ref"></a>2. ref</h2><blockquote><p>接收<strong>简单类型</strong>或者<strong>对象类型</strong>的数据传入并返回一个响应式的对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"> // 导入</span><br><span class="line"> import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"> // 执行函数 传入参数 变量接收</span><br><span class="line"> const count = ref(0)</span><br><span class="line"> const setCount = ()=&gt;&#123;</span><br><span class="line">   // 修改数据更新视图必须加上.value</span><br><span class="line">   count.value++</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;setCount&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="3-reactive-对比-ref"><a href="#3-reactive-对比-ref" class="headerlink" title="3. reactive 对比 ref"></a>3. reactive 对比 ref</h2><ol><li>都是用来生成响应式数据</li><li>不同点<ol><li>reactive不能处理简单类型的数据</li><li>ref参数类型支持更好，但是必须通过.value做访问修改</li><li>ref函数内部的实现依赖于reactive函数</li></ol></li><li>在实际工作中的推荐<ol><li>推荐使用ref函数，减少记忆负担，小兔鲜项目都使用ref</li></ol></li></ol><h1 id="组合式API-computed"><a href="#组合式API-computed" class="headerlink" title="组合式API - computed"></a>组合式API - computed</h1><blockquote><p>计算属性基本思想和Vue2保持一致，组合式API下的计算属性只是修改了API写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">// 导入</span><br><span class="line">import &#123;ref, computed &#125; from &#x27;vue&#x27;</span><br><span class="line">// 原始数据</span><br><span class="line">const count = ref(0)</span><br><span class="line">// 计算属性</span><br><span class="line">const doubleCount = computed(()=&gt;count.value * 2)</span><br><span class="line"></span><br><span class="line">// 原始数据</span><br><span class="line">const list = ref([1,2,3,4,5,6,7,8])</span><br><span class="line">// 计算属性list</span><br><span class="line">const filterList = computed(item=&gt;item &gt; 2)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>计算属性中不应该有 “副作用”<ul><li>比如异步请求 / 修改dom</li></ul></li><li>避免直接修改计算机属性的值<ul><li>计算属性应该是只读的，特殊情况下可以配置get set</li></ul></li></ul><h1 id="组合式API-watch"><a href="#组合式API-watch" class="headerlink" title="组合式API - watch"></a>组合式API - watch</h1><blockquote><p>作用：侦听一个或者多个数据的变化，数据变化时执行回调函数，</p><p>俩个额外参数： immediate控制立刻执行，deep开启深度侦听</p></blockquote><h2 id="1-侦听单个数据"><a href="#1-侦听单个数据" class="headerlink" title="1. 侦听单个数据"></a>1. 侦听单个数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  // 1. 导入watch</span><br><span class="line">  import &#123; ref, watch &#125; from &#x27;vue&#x27;</span><br><span class="line">  const count = ref(0)</span><br><span class="line">  // 2. 调用watch 侦听变化</span><br><span class="line">  watch(count, (newValue, oldValue)=&gt;&#123;</span><br><span class="line">    console.log(`count发生了变化，老值为$&#123;oldValue&#125;,新值为$&#123;newValue&#125;`)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="2-侦听多个数据"><a href="#2-侦听多个数据" class="headerlink" title="2. 侦听多个数据"></a>2. 侦听多个数据</h2><blockquote><p>侦听多个数据，第一个参数可以改写成数组的写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  // 1. 导入watch</span><br><span class="line">  import &#123; ref, watch &#125; from &#x27;vue&#x27;</span><br><span class="line">  const count = ref(0)</span><br><span class="line">  const name = ref(&#x27;cp&#x27;)</span><br><span class="line">  // 2. 调用watch 侦听变化</span><br><span class="line">  watch([count, name], ([newCount, newName],[oldCount,oldName])=&gt;&#123;</span><br><span class="line">    console.log(`count或者name变化了，[newCount, newName],[oldCount,oldName])</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-immediate"><a href="#3-immediate" class="headerlink" title="3. immediate"></a>3. immediate</h2><blockquote><p>在侦听器创建时立即出发回调，响应式数据变化之后继续执行回调</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  // 1. 导入watch</span><br><span class="line">  import &#123; ref, watch &#125; from &#x27;vue&#x27;</span><br><span class="line">  const count = ref(0)</span><br><span class="line">  // 2. 调用watch 侦听变化</span><br><span class="line">  watch(count, (newValue, oldValue)=&gt;&#123;</span><br><span class="line">    console.log(`count发生了变化，老值为$&#123;oldValue&#125;,新值为$&#123;newValue&#125;`)</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    immediate: true</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="4-deep"><a href="#4-deep" class="headerlink" title="4. deep"></a>4. deep</h2><blockquote><p>通过watch监听的ref对象默认是浅层侦听的，直接修改嵌套的对象属性不会触发回调执行，需要开启deep</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  // 1. 导入watch</span><br><span class="line">  import &#123; ref, watch &#125; from &#x27;vue&#x27;</span><br><span class="line">  const state = ref(&#123; count: 0 &#125;)</span><br><span class="line">  // 2. 监听对象state</span><br><span class="line">  watch(state, ()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;数据变化了&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  const changeStateByCount = ()=&gt;&#123;</span><br><span class="line">    // 直接修改不会引发回调执行</span><br><span class="line">    state.value.count++</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  // 1. 导入watch</span><br><span class="line">  import &#123; ref, watch &#125; from &#x27;vue&#x27;</span><br><span class="line">  const state = ref(&#123; count: 0 &#125;)</span><br><span class="line">  // 2. 监听对象state 并开启deep</span><br><span class="line">  watch(state, ()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;数据变化了&#x27;)</span><br><span class="line">  &#125;,&#123;deep:true&#125;)</span><br><span class="line">  const changeStateByCount = ()=&gt;&#123;</span><br><span class="line">    // 此时修改可以触发回调</span><br><span class="line">    state.value.count++</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="组合式API-生命周期函数"><a href="#组合式API-生命周期函数" class="headerlink" title="组合式API - 生命周期函数"></a>组合式API - 生命周期函数</h1><h2 id="1-选项式对比组合式"><a href="#1-选项式对比组合式" class="headerlink" title="1. 选项式对比组合式"></a>1. 选项式对比组合式</h2><p><img src="/./Vue3/6.png" alt="6"></p><h2 id="2-生命周期函数基本使用"><a href="#2-生命周期函数基本使用" class="headerlink" title="2. 生命周期函数基本使用"></a>2. 生命周期函数基本使用</h2><blockquote><ol><li>导入生命周期函数</li><li>执行生命周期函数，传入回调</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;scirpt setup&gt;</span><br><span class="line">import &#123; onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line">onMounted(()=&gt;&#123;</span><br><span class="line">  // 自定义逻辑</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-执行多次"><a href="#3-执行多次" class="headerlink" title="3. 执行多次"></a>3. 执行多次</h2><blockquote><p>生命周期函数执行多次的时候，会按照顺序依次执行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;scirpt setup&gt;</span><br><span class="line">import &#123; onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line">onMounted(()=&gt;&#123;</span><br><span class="line">  // 自定义逻辑</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">onMounted(()=&gt;&#123;</span><br><span class="line">  // 自定义逻辑</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="组合式API-父子通信"><a href="#组合式API-父子通信" class="headerlink" title="组合式API - 父子通信"></a>组合式API - 父子通信</h1><h2 id="1-父传子"><a href="#1-父传子" class="headerlink" title="1. 父传子"></a>1. 父传子</h2><blockquote><p>基本思想</p><ol><li>父组件中给子组件绑定属性</li><li>子组件内部通过props选项接收数据</li></ol></blockquote><p><img src="/./Vue3/7.png" alt="7"></p><h2 id="2-子传父"><a href="#2-子传父" class="headerlink" title="2. 子传父"></a>2. 子传父</h2><blockquote><p>基本思想</p><ol><li>父组件中给子组件标签通过@绑定事件</li><li>子组件内部通过 emit 方法触发事件</li></ol></blockquote><p><img src="/./Vue3/8.png" alt="8"></p><h1 id="组合式API-模版引用"><a href="#组合式API-模版引用" class="headerlink" title="组合式API - 模版引用"></a>组合式API - 模版引用</h1><blockquote><p>概念：通过 ref标识 获取真实的 dom对象或者组件实例对象</p></blockquote><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><blockquote><p>实现步骤：</p><ol><li>调用ref函数生成一个ref对象</li><li>通过ref标识绑定ref对象到标签</li></ol></blockquote><p><img src="/./Vue3/9.png" alt="9"></p><h2 id="2-defineExpose"><a href="#2-defineExpose" class="headerlink" title="2. defineExpose"></a>2. defineExpose</h2><blockquote><p>默认情况下在 <script setup>语法糖下组件内部的属性和方法是不开放给父组件访问的，可以通过defineExpose编译宏指定哪些属性和方法容许访问<br>说明：指定testMessage属性可以被访问到</p></blockquote><p><img src="/./Vue3/10.png" alt="10"></p><h1 id="组合式API-provide和inject"><a href="#组合式API-provide和inject" class="headerlink" title="组合式API - provide和inject"></a>组合式API - provide和inject</h1><h2 id="1-作用和场景"><a href="#1-作用和场景" class="headerlink" title="1. 作用和场景"></a>1. 作用和场景</h2><blockquote><p>顶层组件向任意的底层组件传递数据和方法，实现跨层组件通信</p></blockquote><p><img src="/./Vue3/11.png" alt="11"></p><h2 id="2-跨层传递普通数据"><a href="#2-跨层传递普通数据" class="headerlink" title="2. 跨层传递普通数据"></a>2. 跨层传递普通数据</h2><blockquote><p>实现步骤</p><ol><li>顶层组件通过 <code>provide</code> 函数提供数据</li><li>底层组件通过 <code>inject</code> 函数提供数据</li></ol></blockquote><p><img src="/./Vue3/12.png" alt="12"></p><h2 id="3-跨层传递响应式数据"><a href="#3-跨层传递响应式数据" class="headerlink" title="3. 跨层传递响应式数据"></a>3. 跨层传递响应式数据</h2><blockquote><p>在调用provide函数时，第二个参数设置为ref对象</p></blockquote><p><img src="/./Vue3/13.png" alt="13"></p><h2 id="4-跨层传递方法"><a href="#4-跨层传递方法" class="headerlink" title="4. 跨层传递方法"></a>4. 跨层传递方法</h2><blockquote><p>顶层组件可以向底层组件传递方法，底层组件调用方法修改顶层组件的数据</p></blockquote><p><img src="/./Vue3/14.png" alt="14"></p><h1 id="Vue3-3-新特性-defineOptions"><a href="#Vue3-3-新特性-defineOptions" class="headerlink" title="Vue3.3 新特性-defineOptions"></a>Vue3.3 新特性-defineOptions</h1><p>背景说明：</p><p>有 <script setup> 之前，如果要定义 props, emits 可以轻而易举地添加一个与 setup 平级的属性。 </p><p>但是用了 <script setup> 后，就没法这么干了 setup 属性已经没有了，自然无法添加与其平级的属性。</p><hr><p>为了解决这一问题，引入了 defineProps 与 defineEmits 这两个宏。但这只解决了 props 与 emits 这两个属性。</p><p>如果我们要定义组件的 name 或其他自定义的属性，还是得回到最原始的用法——再添加一个普通的 <script> 标签。</p><p>这样就会存在两个 <script> 标签。让人无法接受。</p><hr><p>所以在 Vue 3.3 中新引入了 defineOptions 宏。顾名思义，主要是用来定义 Options API 的选项。可以用 defineOptions 定义任意的选项， props, emits, expose, slots 除外（因为这些可以使用 defineXXX 来做到）</p><p><img src="/./Vue3/image-20230704082955748.png" alt="image-20230704082955748"></p><h1 id="Vue3-3新特性-defineModel"><a href="#Vue3-3新特性-defineModel" class="headerlink" title="Vue3.3新特性-defineModel"></a>Vue3.3新特性-defineModel</h1><p>在Vue3中，自定义组件上使用v-model, 相当于传递一个modelValue属性，同时触发 update:modelValue 事件</p><p><img src="/./Vue3/image-20230704083027349.png" alt="image-20230704083027349"></p><p>我们需要先定义 props，再定义 emits 。其中有许多重复的代码。如果需要修改此值，还需要手动调用 emit 函数。</p><p>于是乎 defineModel 诞生了。</p><p><img src="/./Vue3/image-20230704083056549.png" alt="image-20230704083056549"></p><p>生效需要配置 vite.config.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fileURLToPath, <span class="variable constant_">URL</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;node:url&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(&#123;</span><br><span class="line">      <span class="attr">script</span>: &#123;</span><br><span class="line">        <span class="attr">defineModel</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: <span class="title function_">fileURLToPath</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;./src&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="Vue3-状态管理-Pinia"><a href="#Vue3-状态管理-Pinia" class="headerlink" title="Vue3 状态管理 - Pinia"></a>Vue3 状态管理 - Pinia</h1><h2 id="1-什么是Pinia"><a href="#1-什么是Pinia" class="headerlink" title="1. 什么是Pinia"></a>1. 什么是Pinia</h2><p>Pinia 是 Vue 的专属的最新状态管理库 ，是 Vuex 状态管理工具的替代品<br><img src="/./Vue3/31.png" alt="image.png"></p><h2 id="2-手动添加Pinia到Vue项目"><a href="#2-手动添加Pinia到Vue项目" class="headerlink" title="2. 手动添加Pinia到Vue项目"></a>2. 手动添加Pinia到Vue项目</h2><p>后面在实际开发项目的时候，Pinia可以在项目创建时自动添加，现在我们初次学习，从零开始：</p><ol><li>使用 Vite 创建一个空的 Vue3项目</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init vite@latest</span><br></pre></td></tr></table></figure><ol start="2"><li>按照官方文档安装 pinia 到项目中</li></ol><h2 id="3-Pinia基础使用"><a href="#3-Pinia基础使用" class="headerlink" title="3. Pinia基础使用"></a>3. Pinia基础使用</h2><ol><li>定义store</li><li>组件使用store</li></ol><p><img src="/./Vue3/32.png" alt="image.png"></p><h2 id="4-getters实现"><a href="#4-getters实现" class="headerlink" title="4. getters实现"></a>4. getters实现</h2><p>Pinia中的 getters 直接使用 computed函数 进行模拟, 组件中需要使用需要把 getters return出去</p><p><img src="/./Vue3/33.png" alt="image.png"></p><h2 id="5-action异步实现"><a href="#5-action异步实现" class="headerlink" title="5. action异步实现"></a>5. action异步实现</h2><p>方式：异步action函数的写法和组件中获取异步数据的写法完全一致</p><ul><li><p>接口地址：<a href="http://geek.itheima.net/v1_0/channels">http://geek.itheima.net/v1_0/channels</a></p></li><li><p>请求方式：get</p></li><li><p>请求参数：无</p></li></ul><p><img src="/./Vue3/34.png" alt="image.png"></p><p>需求：在Pinia中获取频道列表数据并把数据渲染App组件的模板中<br><img src="/./Vue3/35.png" alt="image.png"></p><h2 id="6-storeToRefs工具函数"><a href="#6-storeToRefs工具函数" class="headerlink" title="6. storeToRefs工具函数"></a>6. storeToRefs工具函数</h2><p>使用storeToRefs函数可以辅助保持数据（state + getter）的响应式解构<br><img src="/./Vue3/36.png" alt="image.png"></p><h2 id="7-Pinia的调试"><a href="#7-Pinia的调试" class="headerlink" title="7. Pinia的调试"></a>7. Pinia的调试</h2><p>Vue官方的 dev-tools 调试工具 对 Pinia直接支持，可以直接进行调试<br><img src="/./Vue3/37.png" alt="image.png"></p><h2 id="8-Pinia持久化插件"><a href="#8-Pinia持久化插件" class="headerlink" title="8. Pinia持久化插件"></a>8. Pinia持久化插件</h2><p>官方文档：<a href="https://prazdevs.github.io/pinia-plugin-persistedstate/zh/">https://prazdevs.github.io/pinia-plugin-persistedstate/zh/</a></p><ol><li>安装插件 pinia-plugin-persistedstate</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i pinia-plugin-persistedstate</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 main.js</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> persist <span class="keyword">from</span> <span class="string">&#x27;pinia-plugin-persistedstate&#x27;</span></span><br><span class="line">...</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">createPinia</span>().<span class="title function_">use</span>(persist))</span><br></pre></td></tr></table></figure><ol start="3"><li>配置 store/counter.js</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; computed, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    doubleCount,</span><br><span class="line">    increment</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">persist</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>其他配置，看官网文档即可</li></ol></script></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2024/05/14/SpringCloud/"/>
      <url>/2024/05/14/SpringCloud/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty</title>
      <link href="/2024/05/14/Netty/"/>
      <url>/2024/05/14/Netty/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2024/05/14/Nginx/"/>
      <url>/2024/05/14/Nginx/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo</title>
      <link href="/2024/05/14/Dubbo/"/>
      <url>/2024/05/14/Dubbo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/2024/05/14/SpringSecurity/"/>
      <url>/2024/05/14/SpringSecurity/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>1、掌握Spring框架</p><p>2、掌握SpringBoot使用</p><p>3、掌握JavaWeb技术</p><h1 id="SpringSecurity简介"><a href="#SpringSecurity简介" class="headerlink" title="SpringSecurity简介"></a>SpringSecurity简介</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Spring 是非常流行和成功的 Java 应用开发框架，Spring Security 正是 Spring 家族中的成员。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。</p><p>正如你可能知道的关于安全方面的两个主要区域是“<strong>认证</strong>”和“<strong>授权</strong>”（或者访问控制），一般来说，Web 应用的安全性包括<strong>用户认证（Authentication）和用户授权</strong> <strong>（Authorization）</strong>两个部分，这两点也是 Spring Security 重要核心功能。</p><ul><li><strong>用户认证</strong>指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。<strong>通俗点说就是系统认为用户是否能登录</strong></li><li><strong>用户授权</strong>指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。<strong>通俗点讲就是系统判断用户是否有权限去做某些事情。</strong></li></ul><h2 id="同款产品对比"><a href="#同款产品对比" class="headerlink" title="同款产品对比"></a>同款产品对比</h2><h3 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h3><p>Spring 技术栈的组成部分。</p><p><img src="/.com//image-20240619143613134.png" alt="image-20240619143613134"></p><p>通过提供完整可扩展的认证和授权支持保护你的应用程序</p><p><a href="http://spring.io/projects/spring-security">http://spring.io/projects/spring-security</a></p><p><strong>SpringSecurity的特点：</strong></p><ul><li><p>和 Spring 无缝整合。</p></li><li><p>全面的权限控制。</p></li><li><p>专门为Web 开发而设计。</p><ul><li><p>旧版本不能脱离Web 环境使用。</p></li><li><p>新版本对整个框架进行了分层抽取，分成了核心模块和Web 模块。单独引入核心模块就可以脱离Web 环境。</p></li></ul></li><li><p>重量级。</p></li></ul><h3 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h3><p>Apache 旗下的轻量级权限控制框架。</p><p><img src="/.com//image-20240619143825995.png" alt="image-20240619143825995"></p><p>特点：</p><ul><li>轻量级。Shiro主张的理念是把复杂的事情变简单，针对性能又更高要求的互联网应用又更好的表现</li><li>通用性<ul><li>好处：不局限于Web环境，可以脱离Web环境</li><li>缺点：在Web环境下一些特定的需求需要手动编写代码制定</li></ul></li></ul><p>Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。</p><p>相对于 Shiro，在 SSM 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。</p><p>自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了自动化配置方案，可以使用更少的配置来使用 Spring Security。</p><p>因此，一般来说，常见的安全管理技术栈的组合是这样的：</p><ul><li><strong>SSM + Shiro</strong></li><li><strong>SpringBoot&#x2F;Spring Cloud + SpringSecurity</strong></li></ul><h1 id="SpringSecurity入门程序"><a href="#SpringSecurity入门程序" class="headerlink" title="SpringSecurity入门程序"></a>SpringSecurity入门程序</h1><ul><li><p>创建SpringBoot工程</p></li><li><p>引入spring-security的依赖</p><ul><li><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 编写controller类</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    package com.raehp.controller;</span><br><span class="line">    </span><br><span class="line">    import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">    import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">    import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">    </span><br><span class="line">    @RestController</span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    public class HelloSecurity &#123;</span><br><span class="line">    </span><br><span class="line">        @GetMapping(&quot;/hello&quot;)</span><br><span class="line">        public String hello() &#123;</span><br><span class="line">            return &quot;Hello Security!&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>访问localhost:8080&#x2F;test&#x2F;hello</p><ul><li><img src="/.com//image-20240619150001495.png" alt="image-20240619150001495"></li></ul></li></ul><p>默认用户名为：user</p><p>密码为：每运行一次 随机生成一个密码<img src="/.com//image-20240619150042953.png" alt="image-20240619150042953"></p><h1 id="SpringSecurity基本原理"><a href="#SpringSecurity基本原理" class="headerlink" title="SpringSecurity基本原理"></a>SpringSecurity基本原理</h1><p>SpringSecurity 本质是一个过滤器链： </p><p>从启动是可以获取到过滤器链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFil ter</span><br><span class="line">org.springframework.security.web.context.SecurityContextPersistenceFilter org.springframework.security.web.header.HeaderWriterFilter org.springframework.security.web.csrf.CsrfFilter org.springframework.security.web.authentication.logout.LogoutFilter org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter org.springframework.security.web.savedrequest.RequestCacheAwareFilter org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter org.springframework.security.web.authentication.AnonymousAuthenticationFilter org.springframework.security.web.session.SessionManagementFilter org.springframework.security.web.access.ExceptionTranslationFilter org.springframework.security.web.access.intercept.FilterSecurityInterceptor</span><br></pre></td></tr></table></figure><p>代码底层流程：重点看三个过滤器：</p><ul><li><p><strong>FilterSecurityInterceptor：</strong>是一个方法级的权限过滤器, 基本位于过滤链的最底部。</p><ul><li><pre><code class="java">public void invoke(FilterInvocation filterInvocation) throws IOException, ServletException &#123;        if (this.isApplied(filterInvocation) &amp;&amp; this.observeOncePerRequest) &#123;            filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());        &#125; else &#123;            if (filterInvocation.getRequest() != null &amp;&amp; this.observeOncePerRequest) &#123;                filterInvocation.getRequest().setAttribute(&quot;__spring_security_filterSecurityInterceptor_filterApplied&quot;, Boolean.TRUE);            &#125;            InterceptorStatusToken token = super.beforeInvocation(filterInvocation);            try &#123;                filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());            &#125; finally &#123;                super.finallyInvocation(token);            &#125;            super.afterInvocation(token, (Object)null);        &#125;    &#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  - super.beforeInvocation(fi) 表示查看之前的 filter 是否通过。</span><br><span class="line"></span><br><span class="line">  - fi.getChain().doFilter(fi.getRequest(), fi.getResponse());表示真正的调用后台的服务。</span><br><span class="line"></span><br><span class="line">- **ExceptionTranslationFilter：**是个异常过滤器，用来处理在认证授权过程中抛出的异常</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">            this.doFilter((HttpServletRequest)request, (HttpServletResponse)response, chain);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                chain.doFilter(request, response);</span><br><span class="line">            &#125; catch (IOException var7) &#123;</span><br><span class="line">                IOException ex = var7;</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125; catch (Exception var8) &#123;</span><br><span class="line">                Exception ex = var8;</span><br><span class="line">                Throwable[] causeChain = this.throwableAnalyzer.determineCauseChain(ex);</span><br><span class="line">                RuntimeException securityException = (AuthenticationException)this.throwableAnalyzer.getFirstThrowableOfType(AuthenticationException.class, causeChain);</span><br><span class="line">                if (securityException == null) &#123;</span><br><span class="line">                    securityException = (AccessDeniedException)this.throwableAnalyzer.getFirstThrowableOfType(AccessDeniedException.class, causeChain);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                if (securityException == null) &#123;</span><br><span class="line">                    this.rethrow(ex);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                if (response.isCommitted()) &#123;</span><br><span class="line">                    throw new ServletException(&quot;Unable to handle the Spring Security Exception because the response is already committed.&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                this.handleSpringSecurityException(request, response, chain, (RuntimeException)securityException);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><strong>UsernamePasswordAuthenticationFilter ：</strong>对&#x2F;login 的 POST 请求做拦截，校验表单中用户名，密码。</p><ul><li><pre><code class="java">public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;        if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123;            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());        &#125; else &#123;            String username = this.obtainUsername(request);            username = username != null ? username : &quot;&quot;;            username = username.trim();            String password = this.obtainPassword(request);            password = password != null ? password : &quot;&quot;;            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);            this.setDetails(request, authRequest);            return this.getAuthenticationManager().authenticate(authRequest);        &#125;    &#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## UserDetailService接口详解</span><br><span class="line"></span><br><span class="line">当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。 </span><br><span class="line"></span><br><span class="line">如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。接口定义如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package org.springframework.security.core.userdetails;</span><br><span class="line"></span><br><span class="line">public interface UserDetailsService &#123;</span><br><span class="line">    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>返回值：UserDetails</strong></p><p>这个类是系统默认的用户“<strong>主体</strong>”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示获取登录用户所有权限</span></span><br><span class="line">Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示获取密码</span></span><br><span class="line">String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示获取用户名</span></span><br><span class="line">String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示判断账户是否过期</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示判断账户是否被锁定</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示凭证&#123;密码&#125;是否过期</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示当前用户是否可用</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p><strong>UserDetails实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.security.core.userdetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetails</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240619160448835.png" alt="image-20240619160448835"></p><p>以后我们只需要使用 User 这个实体类即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(username, password, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, authorities);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法参数username:<ul><li>表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫 username，否则无法接收。</li></ul></li></ul><p><strong>步骤总结：</strong></p><ul><li>创建类继承UsernamePassowrdAuthenticationFilter,重写三个方法</li><li>创建类实现UserDetailService，编写查询数据过程，返回User对象</li></ul><p>这个User对象是安全框架提供对象</p><h2 id="PasswordEncoder接口讲解"><a href="#PasswordEncoder接口讲解" class="headerlink" title="PasswordEncoder接口讲解"></a>PasswordEncoder接口讲解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示把参数按照特定的解析规则进行解析</span></span><br><span class="line">String <span class="title function_">encode</span><span class="params">(CharSequence rawPassword)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回false。默认返回 false。</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">upgradeEncoding</span><span class="params">(String encodedPassword)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口实现类：</strong></p><p><img src="/.com//image-20240619161305432.png" alt="image-20240619161305432"></p><p>BCryptPasswordEncoder 是 Spring Security 官方推荐的密码解析器，平时多使用这个解析器。</p><p>BCryptPasswordEncoder 是对bcrypt 强散列方法的具体实现。是基于 Hash 算法实现的单向加密。可以通过 strength 控制加密强度，默认10.</p><p><strong>方法演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建密码解析器</span></span><br><span class="line">    <span class="type">BCryptPasswordEncoder</span> <span class="variable">bCryptPasswordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">atguigu</span> <span class="operator">=</span> bCryptPasswordEncoder.encode(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印加密之后的数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;加密之后数据：\t&quot;</span>+atguigu);</span><br><span class="line">    <span class="comment">//判断原字符加密后和加密之前是否匹配</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> bCryptPasswordEncoder.matches(<span class="string">&quot;atguigu&quot;</span>, atguigu);</span><br><span class="line"><span class="comment">// 打印比较结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;比较结果：\t&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot对Security的自动配置"><a href="#SpringBoot对Security的自动配置" class="headerlink" title="SpringBoot对Security的自动配置"></a>SpringBoot对Security的自动配置</h2><p><a href="https://docs.spring.io/spring-security/site/docs/5.3.4.RELEASE/reference/html5/#servlet-hello">https://docs.spring.io/spring-</a> <a href="https://docs.spring.io/spring-security/site/docs/5.3.4.RELEASE/reference/html5/#servlet-hello">security&#x2F;site&#x2F;docs&#x2F;5.3.4.RELEASE&#x2F;reference&#x2F;html5&#x2F;#servlet-hello</a></p><h1 id="Web权限方案"><a href="#Web权限方案" class="headerlink" title="Web权限方案"></a>Web权限方案</h1><h2 id="设置Security密码"><a href="#设置Security密码" class="headerlink" title="设置Security密码"></a>设置Security密码</h2><p>以下有三种方式可以配置username和password</p><ul><li>通过配置文件</li><li>通过配置类</li><li>自定义编写实现类</li></ul><h3 id="通过配置文件"><a href="#通过配置文件" class="headerlink" title="通过配置文件"></a>通过配置文件</h3><p>创建application.properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.security.user.name</span>=<span class="string">raehp</span></span><br><span class="line"><span class="attr">spring.security.user.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>运行启动类 访问controller 测试</p><h3 id="通过配置类"><a href="#通过配置类" class="headerlink" title="通过配置类"></a>通过配置类</h3><p>创建securitConfig配置类 标注@Configuration注解 让其继承 <code>WebSecurityConfigurerAdapter</code>类</p><p>并实现其中的<strong>configure</strong>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raehp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 将密码进行加密</span></span><br><span class="line">        <span class="type">BCryptPasswordEncoder</span> <span class="variable">bCryptPasswordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> bCryptPasswordEncoder.encode(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        auth.inMemoryAuthentication().withUser(<span class="string">&quot;raehp&quot;</span>).password(password).roles(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 因为configure中用到了PasswordEncoder来加密 所以这里要声明一个PasswordEncoder Bean否则会报错</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">password</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问控制层，输入账户密码验证通过</p><h3 id="自定义编写实现类"><a href="#自定义编写实现类" class="headerlink" title="自定义编写实现类"></a>自定义编写实现类</h3><ul><li>第一步、创建配置类，设置使用哪个userDetailService实现类</li><li>第二步、编写实现类，返回User对象，User对象有用户名密码和操作权限</li></ul><p>创建配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raehp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig2</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//声明使用哪个userDetailsService</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;  <span class="comment">// 指向service/MyUserService</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(password());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">password</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写实现类 创建 <code>service/MyUserService</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raehp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;userDetailsService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        List&lt;GrantedAuthority&gt; authos = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;role&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;raehp&quot;</span>,<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;123&quot;</span>),authos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行访问controller、测试通过</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><ul><li>引入相关依赖</li><li>创建数据库和表</li><li>创建对应的实体类</li><li>整合mybatis-plus，创建mapper接口 实现BaseMapper接口</li><li>在MyUserDetailService中调用mapper中的方法查询函数</li><li>数据库配置</li></ul><p>一、引入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis-plus--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--lombok 用来简化实体类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>二、创建数据库和表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">create table users(</span><br><span class="line"></span><br><span class="line">id bigint primary key auto_increment, username varchar(20) unique not null, password varchar(100)</span><br><span class="line">);</span><br><span class="line">-- 密码 atguigu</span><br><span class="line">insert into users values(1,&#x27;张san&#x27;,&#x27;$2a$10$2R/M6iU3mCZt3ByG7kwYTeeW0w7/UqdeXrb27zkBIizBvAven0/na&#x27;);</span><br><span class="line">-- 密码 atguigu</span><br><span class="line">insert into users values(2,&#x27;李si&#x27;,&#x27;$2a$10$2R/M6iU3mCZt3ByG7kwYTeeW0w7/UqdeXrb27zkBIizBvAven0/na&#x27;);</span><br><span class="line"></span><br><span class="line">create table role(</span><br><span class="line">id bigint primary key auto_increment, name varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into role values(1,&#x27;管理员&#x27;); insert into role values(2,&#x27;普通用户&#x27;);</span><br><span class="line"></span><br><span class="line">create table role_user(</span><br><span class="line">uid bigint, rid bigint</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into role_user values(1,1); insert into role_user values(2,2);</span><br><span class="line"></span><br><span class="line">create table menu(</span><br><span class="line">id bigint primary key auto_increment, name varchar(20),</span><br><span class="line">url varchar(100), parentid bigint, permission varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into menu values(1,&#x27;系统管理&#x27;,&#x27;&#x27;,0,&#x27;menu:system&#x27;); insert into menu values(2,&#x27;用户管理&#x27;,&#x27;&#x27;,0,&#x27;menu:user&#x27;);</span><br><span class="line"></span><br><span class="line">create table role_menu(</span><br><span class="line">mid bigint, rid bigint</span><br><span class="line">);</span><br><span class="line">insert into role_menu values(1,1);</span><br><span class="line">insert into role_menu values(2,1);</span><br><span class="line">insert into role_menu values(2,2);</span><br></pre></td></tr></table></figure><p>三、创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raehp.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Users</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer id;</span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="keyword">public</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四、创建mapper接口使其继承BaseMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raehp.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.raehp.pojo.Users;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Users&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>五、在MyUserDetailService中调用mapper中的方法查询函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raehp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.raehp.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.raehp.pojo.Users;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;userDetailsService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        QueryWrapper&lt;Users&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">        <span class="type">Users</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123; <span class="comment">//如果是空抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;GrantedAuthority&gt; authos = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;role&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(user.getUsername(),<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(user.getPassword()),authos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>六、数据库配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/xxx?serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">xxx</span></span><br></pre></td></tr></table></figure><h2 id="自定义登录页面"><a href="#自定义登录页面" class="headerlink" title="自定义登录页面"></a>自定义登录页面</h2><ul><li>编写配置类</li><li>创建相关文件</li></ul><p>第一步、在配置类实现相关配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       http.formLogin() <span class="comment">// 自定义自己编写的登录页面</span></span><br><span class="line">               .loginPage(<span class="string">&quot;/login.html&quot;</span>) <span class="comment">// 登录访问路径</span></span><br><span class="line">               .loginProcessingUrl(<span class="string">&quot;/user/login&quot;</span>) <span class="comment">// 登录访问路径，即表单提交时 提交到某个controller，这个路径不需要我们自己配置 security会帮我们配置好</span></span><br><span class="line">               .defaultSuccessUrl(<span class="string">&quot;/test/index&quot;</span>).permitAll() <span class="comment">// 登录成功后，跳转路径</span></span><br><span class="line">               .and().authorizeRequests()</span><br><span class="line">                   .antMatchers(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/test/hello&quot;</span>,<span class="string">&quot;/user/login&quot;</span>).permitAll() <span class="comment">// 设置那些路径可以直接访问，不需要认证</span></span><br><span class="line">               .anyRequest().authenticated()</span><br><span class="line">               .and().csrf().disable(); <span class="comment">// 关闭csrf防护 类似于跨域</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>第二步、创建相关的页面 <code>static/login.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.securitydemo1.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.securitydemo1.entity.Users;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.access.annotation.Secured;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.access.prepost.PostAuthorize;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.access.prepost.PostFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.access.prepost.PreAuthorize;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello security&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第三步、访问<code>localhost:8081/test/hello</code> 不会被拦截</p><p>访问<code>localhost:8081/test/index</code> 会跳转到login.html 页面 输入账户密码 登陆成功后 会访问到 <code>/test/index</code></p><h2 id="基于角色或权限进行访问控制"><a href="#基于角色或权限进行访问控制" class="headerlink" title="基于角色或权限进行访问控制"></a>基于角色或权限进行访问控制</h2><h3 id="hasAuthority方法"><a href="#hasAuthority方法" class="headerlink" title="hasAuthority方法"></a>hasAuthority方法</h3><blockquote><p>如果当前的主题具有指定的权限，则返回true，否则返回false（只针对某一个权限）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 在配置类设置当前访问地址有哪些权限</span><br><span class="line"><span class="comment">// 当前登录用户，只有具有admin权限才可以访问这个路径</span></span><br><span class="line">.antMatchers(<span class="string">&quot;/test/index&quot;</span>).hasAuthority(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 在UserDetatilsService中，给返回的User对象设置权限</span><br><span class="line">List&lt;GrantedAuthority&gt; auths =</span><br><span class="line">                AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin&quot;</span>);</span><br></pre></td></tr></table></figure><p>没有权限 访问后会返回<strong>（type &#x3D; “forbidden” status&#x3D;”403”）</strong></p><h3 id="hasAnyAuthority方法"><a href="#hasAnyAuthority方法" class="headerlink" title="hasAnyAuthority方法"></a>hasAnyAuthority方法</h3><blockquote><p>如果当前的主题有任何提供的角色（给定的作为一个逗号分割的字符串列表）的话，返回true</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 在配置类设置当前访问地址有哪些权限</span><br><span class="line"><span class="comment">// 当前登录用户，只有admin,manager权限才可以访问这个路径</span></span><br><span class="line">.antMatchers(<span class="string">&quot;/test/index&quot;</span>).hasAnyAuthority(<span class="string">&quot;admin,manager&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 在UserDetatilsService中，给返回的User对象设置权限</span><br><span class="line">List&lt;GrantedAuthority&gt; auths =</span><br><span class="line">                AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="hasRole方法"><a href="#hasRole方法" class="headerlink" title="hasRole方法"></a>hasRole方法</h3><blockquote><p>如果用户具备给定角色就允许访问，否则出现403，如果当前主体具有指定的角色，则返回true</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 在配置类设置当前访问地址那些角色可以访问</span><br><span class="line"><span class="comment">// 当前请求要sales角色才能访问</span></span><br><span class="line">.antMatchers(<span class="string">&quot;/test/index&quot;</span>).hasRole(<span class="string">&quot;sales&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 在UserDetatilsService中，给返回的User对象设置权限</span><br><span class="line">List&lt;GrantedAuthority&gt; auths =</span><br><span class="line">       AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin,ROLE_sales&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意：这里给User  -&gt; role权限时 要加 <code>ROLE_</code> 这是因为源码中自动帮我们添加了</p><p><img src="/.com//image-20240620181954110.png" alt="image-20240620181954110"></p><h3 id="hasAnyRole方法"><a href="#hasAnyRole方法" class="headerlink" title="hasAnyRole方法"></a>hasAnyRole方法</h3><blockquote><p>用户具备任意一个条件即可访问</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 在配置类设置当前访问地址那些角色可以访问</span><br><span class="line"><span class="comment">// 只要其中一个角色符合即可访问</span></span><br><span class="line">.antMatchers(<span class="string">&quot;/test/index&quot;</span>).hasAnyRole(<span class="string">&quot;sales,manager&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="number">2.</span> 在UserDetatilsService中，给返回的User对象设置权限</span><br><span class="line">List&lt;GrantedAuthority&gt; auths =</span><br><span class="line">       AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin,ROLE_manager&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="自定义403页面"><a href="#自定义403页面" class="headerlink" title="自定义403页面"></a>自定义403页面</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    在自定义配置中配置</span><br><span class="line">    <span class="comment">// 配置没有权限访问跳转自定义页面</span></span><br><span class="line">    http.exceptionHandling().accessDeniedPage(<span class="string">&quot;/unauth.html&quot;</span>);  <span class="comment">// /unauth.html为自定义的403页面</span></span><br><span class="line">    http.formLogin() <span class="comment">// 自定义自己编写的登录页面</span></span><br><span class="line">        ....;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解使用"><a href="#注解使用" class="headerlink" title="注解使用"></a>注解使用</h2><h3 id="Secured"><a href="#Secured" class="headerlink" title="@Secured"></a>@Secured</h3><blockquote><p>用户具有某个角色，可以访问方法</p></blockquote><ul><li>在启动类（或配置类）上添加<code>@EnableGlobalMethodSecurity(securedEnabled=true)</code></li><li>在controller上添加<code>@Secured</code> 注解设置角色</li><li>userDetailService方法设置当前登录用户角色</li></ul><p>第一步、<code>@EnableGlobalMethodSecurity(securedEnabled=true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.securitydemo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.securitydemo1.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true)</span>  <span class="comment">// 可以加在启动类上，也可以加在配置类上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Securitydemo1Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Securitydemo1Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二步、<code>@Secured</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;update&quot;)</span></span><br><span class="line"><span class="meta">@Secured(&#123;&quot;ROLE_sale&quot;,&quot;ROLE_manager&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello update&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步、userDetailService设置登录用户权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GrantedAuthority&gt; auths =</span><br><span class="line">             AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin,ROLE_manager&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="PreAuthorize"><a href="#PreAuthorize" class="headerlink" title="@PreAuthorize"></a>@PreAuthorize</h3><blockquote><p>方法执行之前校验</p></blockquote><ul><li>在启动类（或配置了）上添加<code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></li><li>在controller方法上添加PreAuthorize方法，可以将登录用户的 roles&#x2F;permissions 参数传到方法中。</li></ul><p>第一步、<code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.securitydemo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.securitydemo1.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Securitydemo1Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Securitydemo1Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步、<code>@PreAuthorize</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;update2&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello update2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PostAuthorize"><a href="#PostAuthorize" class="headerlink" title="@PostAuthorize"></a>@PostAuthorize</h3><blockquote><p>方法执行后校验</p></blockquote><ul><li>在启动类（或配置了）上添加<code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></li><li>在controller方法上添加<code>@PostAuthorize</code>注解，注解使用并不多，在方法执行后再进行权限验证，适合验证带有返回值的权限.</li></ul><p>第一步、<code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.securitydemo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.securitydemo1.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Securitydemo1Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Securitydemo1Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步、<code>@PostAuthorize</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;update3&quot;)</span></span><br><span class="line"><span class="meta">@PostAuthorize(&quot;hasAnyAuthority(&#x27;admins&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update3</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是方法执行后校验的！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello update3&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们访问这个请求并且提交后 会出现以下情况：</p><p><img src="/.com//image-20240622153659000.png" alt="image-20240622153659000"></p><p>没有权限访问，但是我们打开控制台发现 方法已经执行完毕</p><p><img src="/.com//image-20240622153650480.png" alt="image-20240622153650480"></p><h3 id="PostFilter"><a href="#PostFilter" class="headerlink" title="@PostFilter"></a>@PostFilter</h3><blockquote><p>权限验证之后对数据进行过滤</p></blockquote><ul><li>表达式中的 filterObject 引用的是方法返回值List 中的某一个元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;getAll&quot;)</span></span><br><span class="line"><span class="meta">@PostAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@PostFilter(&quot;filterObject.username == &#x27;admin1&#x27;&quot;)</span>  <span class="comment">// 代表只返回username是admin1的数据</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Users&gt; <span class="title function_">getAllUser</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Users&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Users</span>(<span class="number">11</span>,<span class="string">&quot;admin1&quot;</span>,<span class="string">&quot;6666&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Users</span>(<span class="number">21</span>,<span class="string">&quot;admin2&quot;</span>,<span class="string">&quot;888&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/.com//image-20240622154409760.png" alt="image-20240622154409760"></p><h3 id="PreFilter"><a href="#PreFilter" class="headerlink" title="@PreFilter"></a>@PreFilter</h3><blockquote><p>进入控制器之前对数据进行过滤</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;getTestPreFilter&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ROLE_管理员&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@PreFilter(value = &quot;filterObject.id%2==0&quot;)</span>  <span class="comment">// 返回id能被2整除的数据</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserInfo&gt; <span class="title function_">getTestPreFilter</span><span class="params">(<span class="meta">@RequestBody</span>List&lt;UserInfo&gt; list)</span> &#123;</span><br><span class="line">    list.forEach(t-&gt; &#123;</span><br><span class="line">System.out.println(t.getId()+<span class="string">&quot;\t&quot;</span>+t.getUsername());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户注销"><a href="#用户注销" class="headerlink" title="用户注销"></a>用户注销</h2><p>创建一个登录成功的页面 success.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">登录成功!</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/logout&quot;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在securityConfig中添加如下配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 退出url，退出成功后跳转的页面</span></span><br><span class="line">http.logout().logoutUrl(<span class="string">&quot;/logout&quot;</span>).logoutSuccessUrl(<span class="string">&quot;/test/hello&quot;</span>).permitAll();</span><br></pre></td></tr></table></figure><p>更新securityConfig 中登录成功后跳转的页面为success.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.defaultSuccessUrl(<span class="string">&quot;/success.html&quot;</span>).permitAll() <span class="comment">// 登录成功后，跳转路径</span></span><br></pre></td></tr></table></figure><p>类似于浏览器中的session</p><p>当我们登陆成功后，可以访问别的页面，但是当我们退出后就不能访问其他页面了</p><p>退出之前：</p><p><img src="/.com//image-20240622160958487.png" alt="image-20240622160958487"></p><p>退出之后：</p><p><img src="/.com//image-20240622161027483.png" alt="image-20240622161027483"></p><h2 id="基于数据库设置记住我"><a href="#基于数据库设置记住我" class="headerlink" title="基于数据库设置记住我"></a>基于数据库设置记住我</h2><p>第一步、创建数据库表(也可以不创建，设置配置文件时 可以帮我们创建)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `persistent_logins` (</span><br><span class="line">`username` varchar(64) NOT NULL,</span><br><span class="line">`series` varchar(64) NOT NULL,</span><br><span class="line">`token` varchar(64) NOT NULL,</span><br><span class="line">`last_used` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (`series`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>第二步、设置数据库配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql数据库配置</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/xxx?serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">xxx</span></span><br></pre></td></tr></table></figure><p>第三步、在安全配置类中编写数据库配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入数据源</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义PersistentTokenRepository容器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PersistentTokenRepository <span class="title function_">persistentTokenRepository</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">jdbcTokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">    jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line"><span class="comment">//        jdbcTokenRepository.setCreateTableOnStartup(true); 自动帮我们创建表，第一次执行会创建，后面执行要删掉</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步、修改安全配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">    ....</span><br><span class="line">.and().rememberMe().tokenRepository(persistentTokenRepository())</span><br><span class="line">.tokenValiditySeconds(<span class="number">60</span>) <span class="comment">// 设置有效时常，单位秒</span></span><br><span class="line">.userDetailsService(userDetailsService)</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//也可以写为</span></span><br><span class="line">http.rememberMe()</span><br><span class="line">.tokenRepository(tokenRepository)</span><br><span class="line">    .tokenValiditySeconds(<span class="number">60</span>) <span class="comment">// 设置有效时常，单位秒</span></span><br><span class="line">.userDetailsService(usersService);</span><br></pre></td></tr></table></figure><p>第五步、页面中设置记住密码复选框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里的name必须是remember-me--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> <span class="attr">title</span>=<span class="string">&quot;记住密码&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试 查询数据库</p><p><img src="/.com//image-20240622164854450.png" alt="image-20240622164854450"></p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 <strong>one-click attack</strong> 或者 <strong>session riding</strong>，通常缩写为 <strong>CSRF</strong> 或者 <strong>XSRF</strong>， 是一种挟制用户在当前已</p><p>登录的 Web 应用程序上执行非本意的操作的攻击方法。跟<a href="https://baike.baidu.com/item/%E8%B7%A8%E7%BD%91%E7%AB%99%E8%84%9A%E6%9C%AC">跨网站脚本</a>（XSS）相比，<strong>XSS</strong> 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p><p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品)。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><p>从 Spring Security 4.0 开始，默认情况下会启用CSRF 保护，以防止CSRF 攻击应用程序，Spring Security CSRF 会针对 PATCH，POST，PUT 和DELETE 方法进行防护。</p><p>参考尚硅谷**&#x3D;&#x3D;SpringSecurity-P19 CSRF&#x3D;&#x3D;**</p><h1 id="SpringSecurity微服务权限方案"><a href="#SpringSecurity微服务权限方案" class="headerlink" title="SpringSecurity微服务权限方案"></a>SpringSecurity微服务权限方案</h1><h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><h3 id="微服务由来"><a href="#微服务由来" class="headerlink" title="微服务由来"></a>微服务由来</h3><p>微服务最早由Martin Fowler 与 James Lewis 于 2014 年共同提出，微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是 HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。</p><h3 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h3><p>（1)微服务每个模块就相当于一个单独的项目，代码量明显减少，遇到问题也相对来说比较好解决。</p><p>（2）微服务每个模块都可以使用不同的存储方式（比如有的用 redis，有的用 mysql等），数据库也是单个模块对应自己的数据库。</p><p>（3）微服务每个模块都可以使用不同的开发技术，开发模式更灵活。</p><h3 id="微服务的本质"><a href="#微服务的本质" class="headerlink" title="微服务的本质"></a>微服务的本质</h3><p>（1）微服务，关键其实不仅仅是微服务本身，而是系统要提供一套基础的架构，这种架构使得微服务可以独立的部署、运行、升级，不仅如此，这个系统架构还让微服务与微服务之间在结构上“松耦合”，而在功能上则表现为一个统一的整体。这种所谓的“统一的整体”表现出来的是统一风格的界面，统一的权限管理，统一的安全策略，统一的上线过 程，统一的日志和审计方法，统一的调度方式，统一的访问入口等等。</p><p>（2）微服务的目的是有效的拆分应用，实现敏捷开发和部署。</p><h2 id="微服务认证于授权实现思路"><a href="#微服务认证于授权实现思路" class="headerlink" title="微服务认证于授权实现思路"></a>微服务认证于授权实现思路</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2024/05/14/Docker/"/>
      <url>/2024/05/14/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><h2 id="Docker为什么出现？"><a href="#Docker为什么出现？" class="headerlink" title="Docker为什么出现？"></a>Docker为什么出现？</h2><p>一款产品：开发 – 上线  两套环境！应用环境、应用配置</p><p>开发 — 运维。 问题：我在我的电脑上能运行 ！ 版本更新，导致服务器不可用！ 对一般运维来说，考研就是十分大？</p><p>环境配置是十分的麻烦，每一个机器都要部署混啊经（集群Redis、ES、Hadoop….） 费时费力</p><p>发布一个项目（jar + （Redis MySQL、jdk、ES）），项目能不能都带上环境安装打包？</p><p>之前在服务器配置一个应用的环境 Redis MySQL jdk ES hadoop ,配置超麻烦，不能跨平台</p><p>Windows，最后发布到Linux！</p><p>传统：开发jar，运维来做</p><p>现在：开发打包部署上线，一套流程做完</p><p>java – apk – 发布（应用商店） — 张三使用apk — 安装即可用</p><p>java — jar（环境）—- 打包项目带上环境（镜像）—（Docker仓库：商店） — 下载我们发布的镜像 — 直接运行即可</p><p>Dcoker 给以上的问题，提出了解决方案！</p><p><img src="/.com//image-20240526143926523.png" alt="image-20240526143926523"></p><p>Docker的思想就是来源于集装箱</p><p>JRE – 多个应用（端口冲突） — 原来都是交叉的！</p><p>Docker的核心思想：<strong>隔离</strong>， 打包装箱，每个箱子都是互相隔离的</p><p>Docker 通过 隔离机制，可以将这些服务器利用到极致！</p><p>本质：所有的技术都是出现了一些问题，我们需要去解决，才去学习！</p><h2 id="Docker的历史"><a href="#Docker的历史" class="headerlink" title="Docker的历史"></a>Docker的历史</h2><p>2010年，几个搞IT的年轻的人，就在美国成立了一家公司 &#x3D;&#x3D;dotCloud&#x3D;&#x3D;</p><p>做一些pass 的云计算服务！LXC有关的容器技术</p><p>他们将自己的技术（容器化技术）命名为：DOCKER</p><p>Docker问什么这么火？</p><p>在容器技术出来之前，我们都是使用虚拟机技术</p><p>虚拟机：在window中装一个Vmvare，通过这个软件我们可以虚拟出来一台或者多台电脑 -&gt; 笨重</p><p>虚拟机也是属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm：Linux centos 原生镜像（一个电脑！）隔离，需要开启多个虚拟机！ 大约个G  需要几分钟</span><br><span class="line">docker：隔离，镜像（最核心的环境 4m + jdk + mysql）十分的轻巧，运行镜像就可以了，小巧， 大约几M kb 秒级启动</span><br></pre></td></tr></table></figure><p>到现在，所有的开发人员必须要会使用Docker！</p><blockquote><p>聊聊Docker</p></blockquote><p>Docker是基于Go语言开发的！开源项目！</p><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p><img src="/.com//image-20240526154032396.png" alt="image-20240526154032396"></p><p>文档地址：<a href="https://docs.docker.com/">https://docs.docker.com/</a>  docker 的文档是超级详细的</p><p>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="Docker能干吗？"><a href="#Docker能干吗？" class="headerlink" title="Docker能干吗？"></a>Docker能干吗？</h2><blockquote><p>之前的虚拟机技术</p></blockquote><p><img src="/.com//image-20240526155907400.png" alt="image-20240526155907400"></p><p>虚拟机技术：</p><ol><li>资源占用十分多</li><li>冗余步骤多</li><li>启动很慢！</li></ol><blockquote><p>容器化技术</p></blockquote><p>&#x3D;&#x3D;容器化技术不是模拟一个完整的操作系统&#x3D;&#x3D;</p><p><img src="/.com//image-20240526160042401.png" alt="image-20240526160042401"></p><p>比较Docker和 虚拟机 技术的不同</p><ul><li>传统虚拟机，虚拟出一个硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li><li>容器内的应用直接运行在 宿主机的内容，容器是没有自己的内核的，有没有虚拟我们的硬件，所以就轻便了</li><li>每个容器间是互相隔离，每个容器内部都有一个属于自己的文件系统，互不影响</li></ul><blockquote><p>DevOps（开发、运维）</p></blockquote><ul><li><strong>应用更快速的交付和部署</strong><ul><li>传统：一堆帮助文档，安装程序</li><li>Docker：打包镜像发布测试，一键运行</li></ul></li><li><strong>更快捷的升级和扩缩容</strong><ul><li>使用了Docker之后，我们部署应用就和搭积木一样</li><li>项目打包为一个镜像，扩展 服务器 A ！ 服务器B</li></ul></li><li><strong>更简单的操作运维</strong><ul><li>在容器化之后，我们的开发，测试环境都是高度一致的</li></ul></li><li><strong>更高效的计算资源利用</strong><ul><li>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例，服务器的性能可以被压榨到机制</li></ul></li></ul><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><p><img src="/.com//image-20240526161155059.png" alt="image-20240526161155059"></p><p><strong>镜像（image）:</strong></p><p>docker镜像就好比是一个模板，可一个通过这个模板来创建服务，tomcat镜像 &#x3D;&#x3D;&gt; run &#x3D;&#x3D;&gt; romcat01容器（提供服务器），通过这个镜像就可以创建多个容器（最终服务运行或者项目运行就是在容器中的）</p><p><strong>容器（container）：</strong></p><p>Docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的</p><p>启动，停止，删除，基本命令</p><p>目前就可以把这个容器理解为就是一个简易的Linux系统</p><p><strong>仓库（respository）：</strong></p><p>仓库就是存放镜像的地方！</p><p>仓库分为共有仓库和私有仓库</p><p>Docker Hub（默认是国外的）</p><p>阿里云…都有容器服务器（配置镜像加速！）</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><blockquote><p>环境准备</p></blockquote><ol><li>需要会一点Linux</li><li>CentOS 7</li></ol><blockquote><p>环境查看</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统内核是 3.10 以上的</span></span><br><span class="line">[root@centos lib]# uname -r</span><br><span class="line">3.10.0-1160.el7.x86_64</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统版本</span></span><br><span class="line">[root@centos lib]# cat /etc/os-release</span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">ID_LIKE=&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID=&quot;7&quot;</span><br><span class="line">PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="line">ANSI_COLOR=&quot;0;31&quot;</span><br><span class="line">CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;</span><br><span class="line">HOME_URL=&quot;https://www.centos.org/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</span><br></pre></td></tr></table></figure><blockquote><p>安装</p></blockquote><p>帮助文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 删除旧版本的docker</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 需要的安装包</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 设置镜像仓库</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 推荐阿里云镜像</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新yum软件包索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 安装docker相关的 docker-ce 社区版  docker-ee 企业版</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. 启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6. 使用docker version 检查是否安装成功</span></span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240526164000121.png" alt="image-20240526164000121"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7. 运行hello-world</span></span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240526164040167.png" alt="image-20240526164040167"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">8. 查看下载的hello-world 镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240526164117963.png" alt="image-20240526164117963"></p><p>了解：卸载docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载依赖</span></span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除资源</span></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/var/lib/docker   docker的默认工作目录</span></span><br></pre></td></tr></table></figure><h2 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h2><p>1、登录阿里云</p><p><img src="/.com//image-20240526165037357.png" alt="image-20240526165037357"></p><p>2、找到镜像地址</p><p><img src="/.com//image-20240526165114875.png" alt="image-20240526165114875"></p><p>3、配置使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://wlv3qzui.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="回顾hello-world流程"><a href="#回顾hello-world流程" class="headerlink" title="回顾hello-world流程"></a>回顾hello-world流程</h2><p><img src="/.com//image-20240526165553649.png" alt="image-20240526165553649"></p><p><img src="/.com//image-20240526165638909.png" alt="image-20240526165638909"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><strong>Docker是怎么工作的？</strong></p><p>Docker 是一个 Client - Sever 结构的系统，Docker 的守护进程运行在主机上，通过Socket从客户端访问！</p><p>DockerServer 接收到 Docker-Client 的指令，就会执行这个命令！</p><p><img src="/.com//image-20240526171001757-1716714602685-1.png" alt="image-20240526171001757"></p><p><strong>Docker为什么比 VM 快？</strong></p><p>1、Docker 有着比虚拟机更少的抽象层</p><p>2、Docker 利用的是宿主机的内核， vm需要的是Guest OS</p><p><img src="/.com//image-20240526171300146.png" alt="image-20240526171300146"></p><p>所以说，新建一个容器时，docker不需要像虚拟机一样重新加载一个操作系统，避免引导，虚拟机是加载Guest OS，分钟级别的！ 而docker 是利用 宿主机的操作系统，省略了这个复杂的过程， 秒级！</p><p><img src="/.com//image-20240526171824087.png" alt="image-20240526171824087"></p><h1 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version# 查看docker的版本信息</span><br><span class="line">docker info# 显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker 命令 --help# 帮助命令</span><br></pre></td></tr></table></figure><p>帮助文档的地址：<a href="http://docs.docker.com/engine/reference/commandline/">http://docs.docker.com/engine/reference/commandline/</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><strong>docker images</strong> 查看所有本地主机上的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@centos docker]# docker images</span><br><span class="line">REPOSITORY    TAG              IMAGE ID       CREATED       SIZE</span><br><span class="line">hello-world   latest           feb5d9fea6a5   2 years ago   13.3kB</span><br><span class="line">rabbitmq      3.8-management   85e83aca5d60   2 years ago   249MB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释</span></span><br><span class="line">REPOSITORY镜像的仓库</span><br><span class="line">TAG镜像的标签</span><br><span class="line">IMAGE ID镜像的id</span><br><span class="line">CREATED镜像的创建时间</span><br><span class="line">SIZE镜像的大小</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项</span></span><br><span class="line">-a--all# 列出全部的镜像</span><br><span class="line">-q--quiet# 只显示镜像的id</span><br></pre></td></tr></table></figure><p><strong>docker search</strong> <strong>搜索镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@centos docker]# docker search mysql</span><br><span class="line">NAME              DESCRIPTION                                     STARS     OFFICIAL</span><br><span class="line">mysql             MySQL is a widely used, open-source relation…   15096     [OK]</span><br><span class="line">mariadb           MariaDB Server is a high performing open sou…   5757      [OK]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项，通过搜藏来过滤</span></span><br><span class="line">--filter=stars=3000#搜索出来的镜像就是stars大于3000的</span><br><span class="line"></span><br><span class="line">[root@centos docker]# docker search mysql --filter=stars=3000</span><br><span class="line">NAME      DESCRIPTION                                     STARS     OFFICIAL</span><br><span class="line">mysql     MySQL is a widely used, open-source relation…   15096     [OK]</span><br><span class="line">mariadb   MariaDB Server is a high performing open sou…   5757      [OK]</span><br></pre></td></tr></table></figure><p><strong>docker pull 下载镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载镜像 docker pull 镜像名[:tag]</span></span><br><span class="line"></span><br><span class="line">[root@centos docker]# docker pull mysql</span><br><span class="line">Using default tag: latest# 如果不写tag，默认就是latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Pull complete# 分层下载，docker image的核心，联合文件系统</span><br><span class="line">93619dbc5b36: Pull complete </span><br><span class="line">99da31dd6142: Pull complete </span><br><span class="line">626033c43d70: Pull complete </span><br><span class="line">37d5d7efb64e: Pull complete </span><br><span class="line">ac563158d721: Pull complete </span><br><span class="line">d2ba16033dad: Pull complete </span><br><span class="line">688ba7d5c01a: Pull complete </span><br><span class="line">00e060b6d11d: Pull complete </span><br><span class="line">1c04857f594f: Pull complete </span><br><span class="line">4d7cfa90e6ea: Pull complete </span><br><span class="line">e0431212d27d: Pull complete </span><br><span class="line">Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 # 签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest#真实地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等价</span></span><br><span class="line">docker pull mysql = docker pull docker.io/library/mysql:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本下载</span></span><br><span class="line">[root@centos docker]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Already exists </span><br><span class="line">93619dbc5b36: Already exists </span><br><span class="line">99da31dd6142: Already exists </span><br><span class="line">626033c43d70: Already exists </span><br><span class="line">37d5d7efb64e: Already exists </span><br><span class="line">ac563158d721: Already exists </span><br><span class="line">d2ba16033dad: Already exists </span><br><span class="line">0ceb82207cd7: Pull complete </span><br><span class="line">37f2405cae96: Pull complete </span><br><span class="line">e2482e017e53: Pull complete </span><br><span class="line">70deed891d42: Pull complete </span><br><span class="line">Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240526214926935.png" alt="image-20240526214926935"></p><p><strong>docker rmi 删除镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]# docker rmi -f 容器id     # 删除指定的容器</span><br><span class="line">[root@centos ~]# docker rmi -f 容器id 容器id 容器id  # 删除多个容器</span><br><span class="line">[root@centos ~]# docker rmi -f $(docker images -aq)# 删除全部的容器</span><br></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><p><strong>新建容器并启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">--name=&quot;Name&quot;容器名字tomcat01tomcat02，用来区分容器</span><br><span class="line">-d后台方式运行</span><br><span class="line">-it使用交互方式运行，进入容器查看内容</span><br><span class="line">-p指定容器的端口 -p  8080:8080</span><br><span class="line">-p  ip:主机端口:容器端口</span><br><span class="line">-p  主机端口:容器端口 (常用)</span><br><span class="line">-p  容器端口</span><br><span class="line">-P随机指定端口</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">[root@centos ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@3f5b8e23f1d4 /]# ls</span><br><span class="line">bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var dev  home  lib64  media opt  root  sbin  sys  usr</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从容器中退回主机</span></span><br><span class="line">[root@3f5b8e23f1d4 /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@centos ~]# ls</span><br></pre></td></tr></table></figure><p><strong>列出所有运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker ps 命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出当前正在运行的容器</span></span><br><span class="line">-a# 列出当前正在运行的容器 + 历史运行的容器</span><br><span class="line">-n=?# 显示最近创建的容器</span><br><span class="line">-q# 只显示容器的编号</span><br><span class="line"></span><br><span class="line">[root@centos ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                     COMMAND                   CREATED      STATUS          PORTS                                                                                                                                                 NAMES</span><br><span class="line">5d5a7963b3f0   rabbitmq:3.8-management   &quot;docker-entrypoint.s…&quot;   6 days ago   Up 27 minutes   4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, :::5672-&gt;5672/tcp, 15671/tcp, 15691-15692/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp, :::15672-&gt;15672/tcp   mq</span><br></pre></td></tr></table></figure><p><strong>退出容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit# 直接退出容器</span><br><span class="line">ctrl + P + Q # 容器不停止退出</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id# 删除指定的容器，不能删除正在运行的容器，如果想要强制删除 rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)# 删除所有容器</span><br><span class="line">docker ps -a -q|xargs docker rm# 删除所有容器</span><br></pre></td></tr></table></figure><p>启动和停止容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id# 启动容器</span><br><span class="line">docker restart 容器id# 重启容器</span><br><span class="line">docker stop 容器id# 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id# 强制停止当前容器</span><br></pre></td></tr></table></figure><h2 id="常用其他容器"><a href="#常用其他容器" class="headerlink" title="常用其他容器"></a>常用其他容器</h2><p><strong>后台启动容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker run -d 容器名</span></span><br><span class="line">[root@centos redis-6.2.6]# docker run -d centos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">问题docker ps, 发现 centos 停止了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常见的坑：docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span></span><br></pre></td></tr></table></figure><p><strong>查看日志命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker logs -tf --<span class="built_in">tail</span> 容器<span class="built_in">id</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[root@centos ~]<span class="comment"># docker run -d centos /bin/sh  -c &quot;while true;do echo Hello world;sleep 1 done&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[root@centos ~]<span class="comment"># docker ps</span></span></span><br><span class="line">CONTAINER ID   IMAGE                                                                   </span><br><span class="line">2ce591cce607   centos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示日志</span></span><br><span class="line"> -tf# 显示日志</span><br><span class="line"> --tail number# 要显示日志条数</span><br><span class="line">[root@centos ~]# docker logs -tf --tail 10 2ce591cce607</span><br></pre></td></tr></table></figure><p><strong>查看容器中进程的信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker top 容器<span class="built_in">id</span></span></span><br><span class="line"></span><br><span class="line">[root@centos ~]# docker top 2ce591cce607</span><br><span class="line">UID       PID       PPID       C       STIME       TTY       TIME</span><br><span class="line">root      117968    117942     11      15:12       ?         00:01:33</span><br></pre></td></tr></table></figure><p><strong>查看镜像的元数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker inspect 容器<span class="built_in">id</span></span></span><br><span class="line"></span><br><span class="line">[root@centos ~]# docker inspect 2ce591cce607</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;2ce591cce6075c6451509e91eff7de38b2857c8fcfa5d4dacd6165c05c940c63&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2024-05-27T07:12:19.884174673Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/bash&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;while true;do echo Hello world;sleep \ndone&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 117968,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2024-05-27T07:12:20.532921369Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/2ce591cce6075c6451509e91eff7de38b2857c8fcfa5d4dacd6165c05c940c63/resolv.conf&quot;,</span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/2ce591cce6075c6451509e91eff7de38b2857c8fcfa5d4dacd6165c05c940c63/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/2ce591cce6075c6451509e91eff7de38b2857c8fcfa5d4dacd6165c05c940c63/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/2ce591cce6075c6451509e91eff7de38b2857c8fcfa5d4dacd6165c05c940c63/2ce591cce6075c6451509e91eff7de38b2857c8fcfa5d4dacd6165c05c940c63-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;/unruffled_driscoll&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;bridge&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                22,</span><br><span class="line">                96</span><br><span class="line">            ],</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;CgroupnsMode&quot;: &quot;host&quot;,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: [],</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: false,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: [],</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;,</span><br><span class="line">                &quot;/sys/devices/virtual/powercap&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/8c55fba1de00516af51357fa3ae5e329e1f8f643a99be6acefd4731c79ae4e10-init/diff:/var/lib/docker/overlay2/015eb7654a41a085bc2adffc51084320625e07c8c27a4294d4282ad2bb2e455d/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/8c55fba1de00516af51357fa3ae5e329e1f8f643a99be6acefd4731c79ae4e10/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/8c55fba1de00516af51357fa3ae5e329e1f8f643a99be6acefd4731c79ae4e10/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/8c55fba1de00516af51357fa3ae5e329e1f8f643a99be6acefd4731c79ae4e10/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mounts&quot;: [],</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;2ce591cce607&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: true,</span><br><span class="line">            &quot;AttachStderr&quot;: true,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/bash&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;while true;do echo Hello world;sleep \ndone&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;centos&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;org.label-schema.build-date&quot;: &quot;20210915&quot;,</span><br><span class="line">                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;c130e7dc19cc8ab332a905d77617f0e570612ab7fbd39edf7566c2ab8bb1c13b&quot;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/c130e7dc19cc&quot;,</span><br><span class="line">            &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;b7f7d69fa3909968e943c291025ef1341dd9a0998ef72d5b898ad1f358c2556a&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;38d99f61733789fc265364f73b526614e6ef4a1ec05292ee181b73e40ab80669&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;b7f7d69fa3909968e943c291025ef1341dd9a0998ef72d5b898ad1f358c2556a&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;DriverOpts&quot;: null,</span><br><span class="line">                    &quot;DNSNames&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>进入当前正在运行的程序</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令</span></span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">[root@centos ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE   COMMAND   CREATED   STATUS</span><br><span class="line">PORTS   NAMES</span><br><span class="line">2ce591cce607   centos   &quot;/bin/bash -c &#x27;while…&quot;   43 minutes ago   Up 43 minutes</span><br><span class="line">nruffled_driscoll</span><br><span class="line">[root@centos ~]# docker exec -it 2ce591cce607 /bin/bash</span><br><span class="line">[root@2ce591cce607 /]# ls</span><br><span class="line">bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var</span><br><span class="line">dev  home  lib64  media       opt  root  sbin  sys  usr</span><br><span class="line">[root@2ce591cce607 /]# ps -ef</span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0 11 07:11 ?        00:05:12 /bin/bash -c while true;do echo Hello world;sl</span><br><span class="line">root       1321 111994  0 07:56 pts/0    00:00:00 ps -ef</span><br><span class="line">root     111994      0  0 07:56 pts/0    00:00:00 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line">[root@centos ~]# docker attach 2ce591cce607</span><br><span class="line">正在执行当前的代码...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span><span class="comment"># 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker attach<span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span></span><br></pre></td></tr></table></figure><p><strong>从容器中拷贝文件到主机上</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令</span></span><br><span class="line">docker cp 容器id:容器内的路径地址 主机内的地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">[root@centos ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@bad7fcbc86d5 /]# [root@centos ~]# ls</span><br><span class="line">anaconda-ks.cfg       itcast                             rabbitmq  公共  音乐</span><br><span class="line">bashrc                itphp                              rrrr      模板  桌面</span><br><span class="line">Doc                   itraehp                            shellDir  视频</span><br><span class="line">docker.java           jdk-17_linux-x64_bin.tar.gz        test      图片</span><br><span class="line">i                     myenv                              test2     文档</span><br><span class="line">initial-setup-ks.cfg  mysql-apt-config_0.8.12-1_all.deb  test.txt  下载</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入docker 容器内部</span></span><br><span class="line">[root@bad7fcbc86d5 home]# docker attach bad7fcbc86d5</span><br><span class="line">[root@bad7fcbc86d5 home]# ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在任意位置创建文件</span></span><br><span class="line">[root@bad7fcbc86d5 home]# touch docker.java</span><br><span class="line">[root@bad7fcbc86d5 home]# ls</span><br><span class="line">docker.java</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出到主机</span></span><br><span class="line">[root@bad7fcbc86d5 home]# exit</span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在主机中查看是否有这个文件</span></span><br><span class="line">[root@centos home]# ls</span><br><span class="line">raehp  tomcat</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将这个文件拷贝到主机来</span></span><br><span class="line">[root@centos ~]# docker cp bad7fcbc86d5:/home/docker.java /home</span><br><span class="line">                                               Successfully copied 1.54kB to /home</span><br><span class="line">[root@centos ~]# cd /home</span><br><span class="line">[root@centos home]# ls</span><br><span class="line">docker.java  raehp  tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝是一个手动过程， 未来会使用 -v 卷的技术，可以实现，自动同步</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/.com//image-20240527162115591.png" alt="image-20240527162115591"></p><p><strong>命令大全</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">当前shell下 attach连接指定运行的镜像</span></span><br><span class="line">  build       Build an image from a Dockerfile # 通过Dockerfile定制镜像</span><br><span class="line">  commit      Create a new image from a container&#x27;s changes #提交当前容器为新的镜像</span><br><span class="line">  cp          Copy files/folders between a container and the local filesystem #拷贝文件</span><br><span class="line">  create      Create a new container #创建一个新的容器</span><br><span class="line">  diff        Inspect changes to files or directories on a container&#x27;s filesystem #查看docker容器的变化</span><br><span class="line">  events      Get real time events from the server # 从服务获取容器实时时间</span><br><span class="line">  exec        Run a command in a running container # 在运行中的容器上运行命令</span><br><span class="line">  export      Export a container&#x27;s filesystem as a tar archive #导出容器文件系统作为一个tar归档文件[对应import]</span><br><span class="line">  history     Show the history of an image # 展示一个镜像形成历史</span><br><span class="line">  images      List images #列出系统当前的镜像</span><br><span class="line">  import      Import the contents from a tarball to create a filesystem image #从tar包中导入内容创建一个文件系统镜像</span><br><span class="line">  info        Display system-wide information # 显示全系统信息</span><br><span class="line">  inspect     Return low-level information on Docker objects #查看容器详细信息</span><br><span class="line">  kill        Kill one or more running containers # kill指定docker容器</span><br><span class="line">  load        Load an image from a tar archive or STDIN #从一个tar包或标准输入中加载一个镜像[对应save]</span><br><span class="line">  login       Log in to a Docker registry #</span><br><span class="line">  logout      Log out from a Docker registry</span><br><span class="line">  logs        Fetch the logs of a container</span><br><span class="line">  pause       Pause all processes within one or more containers</span><br><span class="line">  port        List port mappings or a specific mapping for the container</span><br><span class="line">  ps          List containers</span><br><span class="line">  pull        Pull an image or a repository from a registry</span><br><span class="line">  push        Push an image or a repository to a registry</span><br><span class="line">  rename      Rename a container</span><br><span class="line">  restart     Restart one or more containers</span><br><span class="line">  rm          Remove one or more containers</span><br><span class="line">  rmi         Remove one or more images</span><br><span class="line">  run         Run a command in a new container</span><br><span class="line">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">  search      Search the Docker Hub for images</span><br><span class="line">  start       Start one or more stopped containers</span><br><span class="line">  stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">  stop        Stop one or more running containers</span><br><span class="line">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line">  top         Display the running processes of a container</span><br><span class="line">  unpause     Unpause all processes within one or more containers</span><br><span class="line">  update      Update configuration of one or more containers</span><br><span class="line">  version     Show the Docker version information</span><br><span class="line">  wait        Block until one or more containers stop, then print their exit codes</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041</span><br></pre></td></tr></table></figure><h2 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h2><blockquote><p>&#x3D;&#x3D;安装nginx&#x3D;&#x3D;</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、搜索镜像 search</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、下载镜像 pull</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3、运行测试</span> </span><br><span class="line">[root@centos home]# docker images</span><br><span class="line">REPOSITORY    TAG              IMAGE ID       CREATED       SIZE</span><br><span class="line">nginx         latest           605c77e624dd   2 years ago   141MB</span><br><span class="line">hello-world   latest           feb5d9fea6a5   2 years ago   13.3kB</span><br><span class="line">centos        latest           5d0da3dc9764   2 years ago   231MB</span><br><span class="line">rabbitmq      3.8-management   85e83aca5d60   2 years ago   249MB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 后台运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name 给容器起名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 宿主机端口:容器内部端口</span></span><br><span class="line">[root@centos ~]# docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line">be685b0ee0bc1b8a1bd2f7c365f12591b48f7a2de19e04bf9b20f4b85083034a</span><br><span class="line">[root@centos ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                     COMMAND                   CREATED         STATUS         PORTS                                                                                                                                                 NAMES</span><br><span class="line">be685b0ee0bc   nginx                     &quot;/docker-entrypoint.…&quot;   9 seconds ago   Up 8 seconds   0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp                                                                                                                 nginx01</span><br><span class="line">5d5a7963b3f0   rabbitmq:3.8-management   &quot;docker-entrypoint.s…&quot;   6 days ago      Up 6 hours     4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, :::5672-&gt;5672/tcp, 15671/tcp, 15691-15692/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp, :::15672-&gt;15672/tcp   mq</span><br><span class="line">[root@centos ~]# curl localhost:3344</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span></span><br><span class="line">[root@centos ~]# docker exec -it nginx01 /bin/bash</span><br><span class="line">root@be685b0ee0bc:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@be685b0ee0bc:/# cd /etc/nginx/</span><br><span class="line">root@be685b0ee0bc:/etc/nginx# ls</span><br><span class="line">conf.d  fastcgi_params  mime.types  modules  nginx.conf  scgi_params  uwsgi_params</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240527164936680.png" alt="image-20240527164936680"></p><p>思考问题：我们每次改动nginx配置文件，都需要进入容器内部？十分的烦恼，我要是可以在容器外部提供一个映射路径，达到容器修改文件名，容器内部就可以自动修改？-v 数据卷！ </p><blockquote><p>&#x3D;&#x3D;安装tomcat&#x3D;&#x3D;</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">官方使用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们之前的启动都是后台，停止了容器之后，容器还是可以查到， docker run -it --<span class="built_in">rm</span> 一般用来测试，用完就删除</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载再启动</span></span><br><span class="line">docker pull tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动运行</span></span><br><span class="line">docker run -it -p 3355:8080 --name tomcat01 tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试访问没有问题</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span></span><br><span class="line">[root@centos ~]# docker exec -it tomcat01 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现问题：1、Linux命令少了 2、没有webapps阿里云镜像的原因，默认是最小镜像，所有不必要的都剔除掉</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保证最小可运行的环境！</span></span><br></pre></td></tr></table></figure><p>思考问题：我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？我要是可以再容器外部提供一个映射路径，webapps 我们再外部放置项目，就自动同步到内部就好了！</p><blockquote><p>&#x3D;&#x3D;部署es + kibana&#x3D;&#x3D;</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 暴露的端口特别多</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 十分的耗内存</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 的数据一般要放到安全目录！挂载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> --net somenetwork ？ 网络配置</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 elasticsearch</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动了就卡住了 docker stats 查看cpu的状态</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 是十分耗内存的，1.x G</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 docker stats 状态</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试一下 es 是否运行成功</span></span><br><span class="line">[root@centos ~]# curl localhost:9200</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;6b6447c883a6&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;MfrSvagNQ82YqYGYdVA9RQ&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;7.6.2&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;docker&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.4.0&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赶紧关闭 增加内存的限制</span></span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240527200924500.png" alt="image-20240527200924500"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓紧关闭 增加内存限制 -e 属性</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xms512m&quot; elasticsearch:7.6.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 docker stats</span></span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240527201857693.png" alt="image-20240527201857693"></p><p>问：使用kibana连接es？思考网络如何才能连接过去！</p><p><img src="/.com//image-20240527202047389.png" alt="image-20240527202047389"></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><ul><li>portainer（先用这个）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure><ul><li>Rancher（CI&#x2F;CD再用）</li></ul><p><strong>什么是portainer？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure><p>访问测试：ip:8088</p><p><img src="/.com//image-20240527204554877.png" alt="image-20240527204554877"></p><p><img src="/.com//image-20240527204643129.png" alt="image-20240527204643129"></p><p>进入之后的面板</p><p><img src="/.com//image-20240527204720785.png" alt="image-20240527204720785"></p><p>可视化面板基本上不会使用</p><h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><p>镜像原理之联合文件系统</p><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p>镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p><p>所有应用，直接打包docker镜像，就可以直接跑起来！</p><p><strong>如何得到镜像</strong></p><ul><li>从远程仓库下载</li><li>别人拷贝给你</li><li>自己制作一个镜像 DockerFile</li></ul><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><blockquote><p>UnionFs （联合文件系统）</p></blockquote><p>UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像<br>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><blockquote><p>Docker镜像加载原理</p></blockquote><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br><strong>boots(boot file system）</strong>主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel, Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加載器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。<br><strong>rootfs（root file system)</strong>,在 bootfs之上。包含的就是典型 Linux系统中的&#x2F;dev,&#x2F;proc,&#x2F;bin,&#x2F;etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。</p><p><img src="/.com//image-20240527210108226.png" alt="image-20240527210108226"></p><p>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</p><p><img src="/.com//image-20240527210132048.png" alt="image-20240527210132048"></p><p>对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs.</p><p>虚拟机是分钟级别，容器是秒级！</p><h2 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h2><blockquote><p>分层的镜像</p></blockquote><p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载</p><p><img src="/.com//image-20240527210142658.png" alt="image-20240527210142658"></p><p><strong>思考：为什么Docker镜像要采用这种分层的结构呢？</strong></p><p>最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</p><p>查看镜像分层的方式可以通过docker image inspect 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">➜  / docker image inspect redis          </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:f9b9909726890b00d2098081642edf32e5211b7ab53563929a47f250bcdc1d7c&quot;,</span><br><span class="line">        &quot;RepoTags&quot;: [</span><br><span class="line">            &quot;redis:latest&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;RepoDigests&quot;: [</span><br><span class="line">            &quot;redis@sha256:399a9b17b8522e24fbe2fd3b42474d4bb668d3994153c4b5d38c3dafd5903e32&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;Parent&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2020-05-02T01:40:19.112130797Z&quot;,</span><br><span class="line">        &quot;Container&quot;: &quot;d30c0bcea88561bc5139821227d2199bb027eeba9083f90c701891b4affce3bc&quot;,</span><br><span class="line">        &quot;ContainerConfig&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;d30c0bcea885&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;ExposedPorts&quot;: &#123;</span><br><span class="line">                &quot;6379/tcp&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,</span><br><span class="line">                &quot;GOSU_VERSION=1.12&quot;,</span><br><span class="line">                &quot;REDIS_VERSION=6.0.1&quot;,</span><br><span class="line">                &quot;REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.0.1.tar.gz&quot;,</span><br><span class="line">                &quot;REDIS_DOWNLOAD_SHA=b8756e430479edc162ba9c44dc89ac394316cd482f2dc6b91bcd5fe12593f273&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;#(nop) &quot;,</span><br><span class="line">                &quot;CMD [\&quot;redis-server\&quot;]&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ArgsEscaped&quot;: true,</span><br><span class="line">            &quot;Image&quot;: &quot;sha256:704c602fa36f41a6d2d08e49bd2319ccd6915418f545c838416318b3c29811e0&quot;,</span><br><span class="line">            &quot;Volumes&quot;: &#123;</span><br><span class="line">                &quot;/data&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;/data&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: [</span><br><span class="line">                &quot;docker-entrypoint.sh&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;DockerVersion&quot;: &quot;18.09.7&quot;,</span><br><span class="line">        &quot;Author&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;ExposedPorts&quot;: &#123;</span><br><span class="line">                &quot;6379/tcp&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,</span><br><span class="line">                &quot;GOSU_VERSION=1.12&quot;,</span><br><span class="line">                &quot;REDIS_VERSION=6.0.1&quot;,</span><br><span class="line">                &quot;REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.0.1.tar.gz&quot;,</span><br><span class="line">                &quot;REDIS_DOWNLOAD_SHA=b8756e430479edc162ba9c44dc89ac394316cd482f2dc6b91bcd5fe12593f273&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;redis-server&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ArgsEscaped&quot;: true,</span><br><span class="line">            &quot;Image&quot;: &quot;sha256:704c602fa36f41a6d2d08e49bd2319ccd6915418f545c838416318b3c29811e0&quot;,</span><br><span class="line">            &quot;Volumes&quot;: &#123;</span><br><span class="line">                &quot;/data&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;/data&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: [</span><br><span class="line">                &quot;docker-entrypoint.sh&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: null</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">        &quot;Os&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;Size&quot;: 104101893,</span><br><span class="line">        &quot;VirtualSize&quot;: 104101893,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/adea96bbe6518657dc2d4c6331a807eea70567144abda686588ef6c3bb0d778a/diff:/var/lib/docker/overlay2/66abd822d34dc6446e6bebe73721dfd1dc497c2c8063c43ffb8cf8140e2caeb6/diff:/var/lib/docker/overlay2/d19d24fb6a24801c5fa639c1d979d19f3f17196b3c6dde96d3b69cd2ad07ba8a/diff:/var/lib/docker/overlay2/a1e95aae5e09ca6df4f71b542c86c677b884f5280c1d3e3a1111b13644b221f9/diff:/var/lib/docker/overlay2/cd90f7a9cd0227c1db29ea992e889e4e6af057d9ab2835dd18a67a019c18bab4/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;RootFS&quot;: &#123;</span><br><span class="line">            &quot;Type&quot;: &quot;layers&quot;,</span><br><span class="line">            &quot;Layers&quot;: [</span><br><span class="line">                &quot;sha256:c2adabaecedbda0af72b153c6499a0555f3a769d52370469d8f6bd6328af9b13&quot;,</span><br><span class="line">                &quot;sha256:744315296a49be711c312dfa1b3a80516116f78c437367ff0bc678da1123e990&quot;,</span><br><span class="line">                &quot;sha256:379ef5d5cb402a5538413d7285b21aa58a560882d15f1f553f7868dc4b66afa8&quot;,</span><br><span class="line">                &quot;sha256:d00fd460effb7b066760f97447c071492d471c5176d05b8af1751806a1f905f8&quot;,</span><br><span class="line">                &quot;sha256:4d0c196331523cfed7bf5bafd616ecb3855256838d850b6f3d5fba911f6c4123&quot;,</span><br><span class="line">                &quot;sha256:98b4a6242af2536383425ba2d6de033a510e049d9ca07ff501b95052da76e894&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Metadata&quot;: &#123;</span><br><span class="line">            &quot;LastTagTime&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>理解：</strong></p><p>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p><p>举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，<br>就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。</p><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点.</p><p><img src="/.com//image-20240527210207852.png" alt="image-20240527210207852"></p><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。</p><p><img src="/.com//image-20240527210220354.png" alt="image-20240527210220354"></p><p>上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件<br>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版。</p><p><img src="/.com//image-20240527210224255.png" alt="image-20240527210224255"></p><p>文种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中</p><p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统</p><p>Linux上可用的存储引撃有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的<br>件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。</p><p>Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW [1]。</p><p>下图展示了与系统显示相同的三层镜像。所有镜像层堆并合井，对外提供统一的视图。</p><p><img src="/.com//image-20240527210232825.png" alt="image-20240527210232825"></p><blockquote><p>特点</p></blockquote><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！</p><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p><p><img src="/.com//image-20240527211028173.png" alt="image-20240527211028173"></p><p>如何提交一个自己的镜像</p><h2 id="Commit镜像"><a href="#Commit镜像" class="headerlink" title="Commit镜像"></a>Commit镜像</h2><p>创建镜像的第一种方式   下面初始dokcerfile是第二种</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器作为一个新的副本</span><br><span class="line"></span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名[:TAG]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、启动一个默认的tomcat</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、发现这个默认的tomcat 是没有webaoos应用， 镜像的原因，官方的镜像默认 webapps 下面是没有文件的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3、我们自己拷贝进去了基本的文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4、将我们操作过的容器通过commit命令提交为一个镜像！我们以后就使用我们修改过的镜像</span></span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240527212945980.png" alt="image-20240527212945980"></p><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h2><p><strong>docker的理念回顾</strong></p><p>将应用和环境打包成一个镜像</p><p>数据？如果数据都在容器中，那么我们容器删除，数据也就会丢失！&#x3D;&#x3D;需求：数据可以持久化&#x3D;&#x3D;</p><p>MYSQL，容器删了，删库跑路！&#x3D;&#x3D;需求：MySQL数据可以存储在本地&#x3D;&#x3D;</p><p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p><p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！</p><p><img src="/.com//image-20240528085618939.png" alt="image-20240528085618939"></p><p><strong>总结一句话：容器的持久化和同步！荣期间也是可以数据共享的</strong></p><h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><blockquote><p>方式一：直接使用命令来挂载 -v</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">[root@centos ~]# docker run -it -v /home/ceshi:/home centos /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动起来之后 我们可以使用 docker inspect 容器<span class="built_in">id</span> 来查看</span></span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240528090206167.png" alt="image-20240528090206167"></p><p><strong>测试文件的同步</strong></p><p><img src="/.com//image-20240528090236812.png" alt="image-20240528090236812"></p><p>再来测试：</p><ol><li>停止容器</li><li>宿主机上修改文件</li><li>启动容器</li><li>容器内的数据依旧是同步的！</li></ol><p><img src="/.com//image-20240528090333951.png" alt="image-20240528090333951"></p><p>好处：以后修改数据在本地修改即可，容器会自动同步</p><h2 id="实战：安装MySQL"><a href="#实战：安装MySQL" class="headerlink" title="实战：安装MySQL"></a>实战：安装MySQL</h2><p>思考：MySQL数据的持久化的问题！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取镜像</span></span><br><span class="line">[root@centos ~]# docker pull mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行容器，需要做数据挂载！  <span class="comment"># 安装启动mysql，需要配置密码</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">官方测试： docker run --name some-muysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">-d 后台运行</span><br><span class="line">-p 端口映射</span><br><span class="line">-v 卷挂载</span><br><span class="line">-e 环境配置</span><br><span class="line">--name</span><br><span class="line"></span><br><span class="line">[root@centos ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动成功之后，我们在本地使用第三方工具 来测试一下</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接到容器内的数据库 端口为3310 --- 3310 和容器内的3306映射，这个时候就可以连上了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在本地测试创建一个数据库，查看我们映射的路径是否ok？</span></span><br></pre></td></tr></table></figure><p>假设我们将容器删除</p><p><img src="/.com//image-20240528092200610.png" alt="image-20240528092200610"></p><p>发现，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能！</p><h2 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匿名挂载</span></span><br><span class="line">-v 容器内路径</span><br><span class="line">[root@centos ~]# docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">产看所有的匿名挂载</span></span><br><span class="line">[root@centos ~]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     0cf0dd8b2ba0b2ccf746624d1568c1875a8219e5def3fe39210225df7866b3a7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具名挂载</span></span><br><span class="line">[root@centos ~]# docker run -d -P --name nginx02 -v jvming-nginx:/etc/nginx nginx</span><br><span class="line">915b6bd502a4c36471dcd21b6383fe29d1deaf9043d082317f2f37588f9efca3</span><br><span class="line">[root@centos ~]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     jvming-nginx  # 具名挂载</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 -v 卷名:容器内路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看一下这个卷的数据</span></span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240528105634536.png" alt="image-20240528105634536"></p><p>所有的docker容器内的卷，没有制定法规目录的情况下都是在 <code>/var/lib/docker/volumes/xxx/_data</code></p><p>我们通过具名挂载可以方便的找到我们的一个卷，大多是情况在使用的 <code>具名挂载</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如何确定是具名挂载还是匿名挂载，还是指定路径挂载</span></span><br><span class="line">-v 容器内路径# 匿名挂载</span><br><span class="line">-v 卷名:容器内路径# 具名挂载</span><br><span class="line">-v /宿主机路径:容器内路径# 指定路径挂载</span><br></pre></td></tr></table></figure><p>拓展：；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 -v 容器内路径：rorw改变读写权限</span></span><br><span class="line">ro readonly  # 只读</span><br><span class="line">rw readwrite # 可读可写</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一旦设置了这个容器权限，柔佛能勾起对我们挂在出来的内容就有限定了！</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ro 只要看到ro 就说明这个路径只能x通过宿主机来操作，容器内部是无法操作的</span></span><br></pre></td></tr></table></figure><h2 id="初始dockerFile"><a href="#初始dockerFile" class="headerlink" title="初始dockerFile"></a>初始dockerFile</h2><p>构建镜像的第二种方式 第一种为commit</p><p>Dockerfile 就是用来构建docker 镜像的构建文件！命令脚本</p><p>通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令都是一层！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个dockerfile文件，名字可以随机，简易 Dockerfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件中的内容， 指令(大写)，参数</span></span><br><span class="line">FORM centos</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line">CMD echo &quot;----end-----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里的每个命令，就是镜像的一层</span></span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240528144915494.png" alt="image-20240528144915494"></p><p>这里的<code>-f dockerfile1</code> 是指 通过这个文件构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动自己的容器</span></span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240528145612778.png" alt="image-20240528145612778"></p><p>这个卷和外部一定是同步的</p><p><img src="/.com//image-20240528145504155.png" alt="image-20240528145504155"></p><h2 id="数据卷容器（持久化）"><a href="#数据卷容器（持久化）" class="headerlink" title="数据卷容器（持久化）"></a>数据卷容器（持久化）</h2><p>多个mysql数据同步！</p><p><img src="/.com//image-20240528153106458.png" alt="image-20240528153106458"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动三个容器，通过刚才写的镜像启动</span></span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240528153853943.png" alt="image-20240528153853943"></p><p><img src="/.com//image-20240528153941063.png" alt="image-20240528153941063"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos home]# docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 myslq:5.7</span><br><span class="line"></span><br><span class="line">[root@centos home]# docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 myslq:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个时候，可以实现两个容器数据同步！</span></span><br></pre></td></tr></table></figure><p><strong>结论</strong></p><p>容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。</p><p>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！</p><h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><h2 id="Dockerfile介绍"><a href="#Dockerfile介绍" class="headerlink" title="Dockerfile介绍"></a>Dockerfile介绍</h2><p>dockerfile是用来构建docker镜像的文件！命令参数脚本！</p><p>构建步骤：</p><ol><li>编写一个dockerfilr文件</li><li>docker build 构建成为一个镜像</li><li>docker run 运行镜像</li><li>docker push 发布镜像 （DockerHub、阿里云镜像仓库！）</li></ol><p>官方步骤：</p><p><img src="/.com//image-20240528165342969.png" alt="image-20240528165342969"></p><p><img src="/.com//image-20240528165527204.png" alt="image-20240528165527204"></p><h2 id="DockerFile构建"><a href="#DockerFile构建" class="headerlink" title="DockerFile构建"></a>DockerFile构建</h2><p><strong>基础知识：</strong></p><ol><li>每个保留关键字（指令）都是必须是大写字母</li><li>执行从上到下顺序执行</li><li>#表示注释</li><li>每个指令都会创建提交一个新的镜像层，并提交！</li></ol><p><img src="/.com//image-20240528165940824.png" alt="image-20240528165940824"></p><p>dockerfile是面向开发的，我们以后要发布项目，做镜像就要编写dockerfile文件</p><p>Docker镜像主键成为企业交付的标准，必须要掌握！</p><p>步骤：开发、部署、运维、缺一不可</p><p>DockerFile：构建文件定义了一切的步骤，源代码</p><p>DockerImages：通过DockerFIle构建生成的镜像，最终发布和运行的产品！</p><p>Docker容器：容器就是镜像运行起来提供服务器</p><h2 id="Docker指令"><a href="#Docker指令" class="headerlink" title="Docker指令"></a>Docker指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM# 基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER# 镜像是谁写的，姓名+邮箱</span><br><span class="line">RUN# 镜像构建的时候需要运行的命令</span><br><span class="line">ADD# 步骤：tomcat镜像，这个tomcat压缩包！添加内容</span><br><span class="line">WORKDIR# 镜像的工作目录</span><br><span class="line">VOLUME# 挂载的目录</span><br><span class="line">EXPOSE# 保留端口配置</span><br><span class="line">CMD# 指定这个容器启动时候要运行的命令，只有最后一条可以生效，可被替代</span><br><span class="line">ENTRYPOINT# 指定这个容器启动时要运行的命令，可以追加命令</span><br><span class="line">ONBUILD# 当构建一个被继承的 DockerFile 这个时候就会运行 ONBUILD 的指令</span><br><span class="line">COPY# 类似ADD，将我们的文件拷贝到镜像中</span><br><span class="line">ENV# 构建的时候设置环境变量</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240528171402939.png" alt="image-20240528171402939"></p><h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><p>​自己写一个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入home 目录 创建dockerfile目录 创建 mydockerfile</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 创建mydockerfile</span></span><br><span class="line">vim mydockerfile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 编辑</span></span><br><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER raehp&lt;2012256884@qq.com&gt;  # 创建人、邮箱</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local # 默认进入的目录</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools # 安装vim net-tools  默认的centos镜像是没有这个两个的</span><br><span class="line"></span><br><span class="line">EXPOSE 80 # 暴露的端口</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;---end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 构建 docker build -f dockerfile名称 -t 镜像名:版本号 .   <span class="string">&quot;.&quot;</span> 代表在当前目录创建</span></span><br><span class="line">docker build -f mydockerfile -t mycentos:1.0 .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 测试运行</span></span><br><span class="line">docker run -it mycentos:1.0</span><br></pre></td></tr></table></figure><p>对比：与原生的centos对别</p><p><strong>原生</strong></p><p><img src="/.com//image-20240528193303700.png" alt="image-20240528193303700"></p><p><strong>修改后</strong></p><p><img src="/.com//image-20240528193230558.png" alt="image-20240528193230558"></p><p>我们可以列出本地进行的变更历史</p><p><img src="/.com//image-20240528193515702.png" alt="image-20240528193515702"></p><p>这样我们拿到一个新的镜像，可以研究一下他是怎么做的？</p><blockquote><p>CMD和ENTRYPOINT 区别</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD# 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT# 指定这个容器启动的时候要运行的命令，可以追加命令</span><br></pre></td></tr></table></figure><p>测试<code>CMD</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 创建docker-cmd-test</span></span><br><span class="line">vim docker-cmd-test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 编辑内容</span></span><br><span class="line">FROM centos</span><br><span class="line">CMD [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3 构成镜像</span></span><br><span class="line">docker build -f docker-cmd-test -t cmdtest .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 运行镜像</span></span><br><span class="line">docker run -it 2b06f9641629</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5 结果</span></span><br><span class="line">.  ..  .dockerenv  bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6 项追加一个 -l 命令</span></span><br><span class="line">[root@centos dockerfile]# docker run -it 2b06f9641629 -l</span><br><span class="line">docker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmd的情况下， -l 替换了 CMD [<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>] 命令， -l 不是命令，所以报错</span></span><br></pre></td></tr></table></figure><p>测试<code>ENTRYPOINT</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 创建docker-entrypoint-test</span></span><br><span class="line">vim docker-entrypoint-test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 编辑内容</span></span><br><span class="line">FROM centos</span><br><span class="line">ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 构成镜像</span></span><br><span class="line">docker build -f docker-entrypoint-test -t entrypointtest .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 运行镜像</span></span><br><span class="line">docker run -it a58b53c50da3074</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. 结果</span></span><br><span class="line">[root@centos dockerfile]# docker run -it a58b53c50da3074</span><br><span class="line">.  ..  .dockerenv  bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6. 项追加一个 -l 命令</span></span><br><span class="line">[root@centos dockerfile]# docker run -it a58b53c50da3074 -l</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x.   1 root root   6 May 28 12:02 .</span><br><span class="line">drwxr-xr-x.   1 root root   6 May 28 12:02 ..</span><br><span class="line">-rwxr-xr-x.   1 root root   0 May 28 12:02 .dockerenv</span><br><span class="line">lrwxrwxrwx.   1 root root   7 Nov  3  2020 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x.   5 root root 360 May 28 12:02 dev</span><br><span class="line">drwxr-xr-x.   1 root root  66 May 28 12:02 etc</span><br><span class="line">drwxr-xr-x.   2 root root   6 Nov  3  2020 home</span><br><span class="line">lrwxrwxrwx.   1 root root   7 Nov  3  2020 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx.   1 root root   9 Nov  3  2020 lib64 -&gt; usr/lib64</span><br><span class="line">drwx------.   2 root root   6 Sep 15  2021 lost+found</span><br><span class="line">drwxr-xr-x.   2 root root   6 Nov  3  2020 media</span><br><span class="line">drwxr-xr-x.   2 root root   6 Nov  3  2020 mnt</span><br><span class="line">drwxr-xr-x.   2 root root   6 Nov  3  2020 opt</span><br><span class="line">dr-xr-xr-x. 237 root root   0 May 28 12:02 proc</span><br><span class="line">dr-xr-x---.   2 root root 162 Sep 15  2021 root</span><br><span class="line">drwxr-xr-x.  11 root root 163 Sep 15  2021 run</span><br><span class="line">lrwxrwxrwx.   1 root root   8 Nov  3  2020 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x.   2 root root   6 Nov  3  2020 srv</span><br><span class="line">dr-xr-xr-x.  13 root root   0 May 28 00:33 sys</span><br><span class="line">drwxrwxrwt.   7 root root 171 Sep 15  2021 tmp</span><br><span class="line">drwxr-xr-x.  12 root root 144 Sep 15  2021 usr</span><br><span class="line">drwxr-xr-x.  20 root root 262 Sep 15  2021 var</span><br></pre></td></tr></table></figure><h2 id="Tomcat镜像"><a href="#Tomcat镜像" class="headerlink" title="Tomcat镜像"></a>Tomcat镜像</h2><p>1、准备镜像 tomcat的压缩包 jdk的压缩包</p><p><img src="/.com//image-20240529093128574.png" alt="image-20240529093128574"></p><p>2、编写dockerfile 文件，官方命名<code>Dockerfile</code> build 的时候 会自动寻找这个文件 ，就不需要写 -f 了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@centos tomcat]# cat Dockerfile </span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER raehp&lt;2012256884@qq.com&gt;</span><br><span class="line"> </span><br><span class="line">COPY readme.txt /usr/local/readme.txt</span><br><span class="line"> </span><br><span class="line">ADD jdk-8u73-linux-x64.tar.gz /usr/local/</span><br><span class="line">ADD apache-tomcat-9.0.37.tar.gz /usr/local/</span><br><span class="line"> </span><br><span class="line">RUN yum -y install vim</span><br><span class="line"> </span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"> </span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_73</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.37</span><br><span class="line">ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.37</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"> </span><br><span class="line">EXPOSE 8080</span><br><span class="line"> </span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.37/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.37/bin/logs/catalina.out</span><br></pre></td></tr></table></figure><p>3、构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker build -t diytomcat .</span></span><br></pre></td></tr></table></figure><p>4、 启动镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> docker run -d -p 3344:8080 --name xiaofantomcat1 -v /home/xiaofan/build/tomcat/test:/usr/local/apache-tomcat-9.0.37/webapps/test -v /home/xiaofan/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.37/logs diytomcat</span></span><br></pre></td></tr></table></figure><p>5、 访问镜像</p><p>6、 发布项目</p><p>在本地编写web.xml 和 index.jsp </p><p><img src="/.com//image-20240529102948037.png" alt="image-20240529102948037"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;2.4&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;hello. xiaofan&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Hello World!&lt;br/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">System.out.println(<span class="string">&quot;-----my test web logs------&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>发现：项目部署成功， 可以直接访问ok！</p><p>我们以后开发的步骤：需要掌握Dockerfile的编写！ 我们之后的一切都是使用docker进行来发布运行的！</p><p><img src="/.com//image-20240529102910881.png" alt="image-20240529102910881"></p><h2 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h2><blockquote><p>&#x3D;&#x3D;DockerHub&#x3D;&#x3D;</p></blockquote><p>1、地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>2、 登录docker hub 账号</p><p>3、 在docker 中登录 docker hub  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login -u dockerhub账号</span><br></pre></td></tr></table></figure><p>4、 先使用tag命令修改镜像名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送镜像的规范是：</span></span><br><span class="line">docker push  注册docker用户名/REPOSITORY:TAG </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以使用tag 更改镜像名称</span></span><br><span class="line">[root@localhost ~]# docker tag nginx:v1 llxxyy/nginx-io:v1</span><br></pre></td></tr></table></figure><p>5、 push 到 docker hub</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker push llxxyy/nginx-io:v1</span><br><span class="line">The push refers to repository [docker.io/llxxyy/nginx-io]</span><br><span class="line">833a0f6a6ff9: Pushed </span><br><span class="line">10bfe402500e: Pushed </span><br><span class="line">d43641d7d594: Mounted from library/nginx </span><br><span class="line">c2adabaecedb: Mounted from library/nginx </span><br><span class="line">v1: digest: sha256:67dcdae5578c0374019cc899731543cfd7c48fe5780e84233a258f2bf7d2ceda size: 1155</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure><p>6、 有镜像了</p><p><img src="/.com//image-20240529110958900.png" alt="image-20240529110958900"></p><blockquote><p>&#x3D;&#x3D;阿里云镜像服务上&#x3D;&#x3D;</p></blockquote><p>1、登录阿里云</p><p>2、找到容器镜像服务</p><p>3、创建命名空间 (注意：免费的只能创建3个命名空间)</p><p><img src="/.com//image-20240529112234682.png" alt="image-20240529112234682"></p><p>4、创建容器镜像</p><p><img src="/.com//image-20240529112302333.png" alt="image-20240529112302333"></p><p>5、 浏览阿里云</p><p><img src="/.com//image-20240529112502389.png" alt="image-20240529112502389"></p><p>6、docker 命令行登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login --username=xxx registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="/.com//image-20240529113525972.png" alt="image-20240529113525972"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2024/05/14/RabbitMQ/"/>
      <url>/2024/05/14/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>高性能的异步通讯组件</p><p><img src="/.com//image-20240520142216935.png" alt="image-20240520142216935"></p><ul><li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li><li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li></ul><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发微信可以同时与多个人收发微信，但是往往响应会有延迟。</p><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><ul><li>消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。<br>其主要用途：不同进程Process&#x2F;线程Thread之间通信。</li></ul><p>为什么会产生消息队列？有几个原因：</p><ul><li>不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；</li><li>不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列；</li></ul><h1 id="初识MQ"><a href="#初识MQ" class="headerlink" title="初识MQ"></a>初识MQ</h1><h2 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h2><p>之前说过，我们现在基于OpenFeign的调用都属于是同步调用，那么这种方式存在哪些问题呢？<br>举个例子，我们以昨天留给大家作为作业的<strong>余额支付功能</strong>为例来分析，首先看下整个流程：<br><img src="/.com//image-20240520144211998.png" alt="image-20240520144211998"><br>目前我们采用的是基于OpenFeign的同步调用，也就是说业务执行流程是这样的：</p><ul><li>支付服务需要先调用用户服务完成余额扣减</li><li>然后支付服务自己要更新支付流水单的状态</li><li>然后支付服务调用交易服务，更新业务订单状态为已支付</li></ul><p>三个步骤依次执行。<br>这其中就存在3个问题：<br><strong>第一</strong>，<strong>拓展性差</strong><br>我们目前的业务相对简单，但是随着业务规模扩大，产品的功能也在不断完善。<br>在大多数电商业务中，用户支付成功后都会以短信或者其它方式通知用户，告知支付成功。假如后期产品经理提出这样新的需求，你怎么办？是不是要在上述业务中再加入通知用户的业务？<br>某些电商项目中，还会有积分或金币的概念。假如产品经理提出需求，用户支付成功后，给用户以积分奖励或者返还金币，你怎么办？是不是要在上述业务中再加入积分业务、返还金币业务？<br>…..<br>最终你的支付业务会越来越臃肿：<br><img src="/.com//image-20240520144157149.png" alt="image-20240520144157149"><br>也就是说每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动，不符合开闭原则，拓展性不好。</p><p><strong>第二</strong>，<strong>性能下降</strong><br>由于我们采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和：<br><img src="/.com//image-20240520144148565.png" alt="image-20240520144148565"><br>假如每个微服务的执行时长都是50ms，则最终整个业务的耗时可能高达300ms，性能太差了。</p><p><strong>第三，级联失败</strong><br>由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。<br>这其实就是同步调用的<strong>级联失败</strong>问题。</p><p>但是大家思考一下，我们假设用户余额充足，扣款已经成功，此时我们应该确保支付流水单更新为已支付，确保交易成功。毕竟收到手里的钱没道理再退回去吧。</p><p>因此，这里不能因为短信通知、更新订单状态失败而回滚整个事务。</p><p>综上，同步调用的方式存在下列问题：</p><ul><li>拓展性差</li><li>性能下降</li><li>级联失败</li></ul><p>而要解决这些问题，我们就必须用<strong>异步调用</strong>的方式来代替<strong>同步调用</strong>。</p><h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li>消息发送者：投递消息的人，就似乎原来的调用方</li><li>消息代理：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ul><p><img src="/.com//image-20240520145112147.png" alt="image-20240520145112147"></p><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。<br>这样，发送消息的人和接收消息的人就完全解耦了。</p><p>支付服务不再同步调度业务关联度低的服务，而是发送消息通知到Broker(消息通知)</p><p><img src="/.com//image-20240520145705239.png" alt="image-20240520145705239"></p><p>除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。</p><p>假如产品经理提出了新的需求，比如要在支付成功后更新用户积分。支付代码完全不用变更，而仅仅是让积分服务也订阅消息即可：</p><p><img src="/.com//image-20240520145610754.png" alt="image-20240520145610754"></p><p>优势：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li></ul><p>缺点：</p><ul><li>完全依赖于Broker的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul><h2 id="MQ技术选型"><a href="#MQ技术选型" class="headerlink" title="MQ技术选型"></a>MQ技术选型</h2><p>MQ（Message  Queue）， 中文是消息队列，字面看来就是存放消息的队列，也就是异步调用中的Broker</p><p>以下是比较常见的MQ</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><ul><li>追求可用性：Kafka、 RocketMQ 、RabbitMQ</li><li>追求可靠性：RabbitMQ、RocketMQ</li><li>追求吞吐能力：RocketMQ、Kafka</li><li>追求消息低延迟：RabbitMQ、Kafka</li></ul><p>据统计，目前国内消息队列使用最多的还是RabbitMQ，再加上其各方面都比较均衡，稳定性也好，因此我们课堂上选择RabbitMQ来学习。</p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：<br><a href="https://www.rabbitmq.com/">Messaging that just works — RabbitMQ</a><br>接下来，我们就学习它的基本概念和基础用法。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们同样基于Docker来安装RabbitMQ，使用下面的命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">要先执行</span><br><span class="line">docker network create hmall</span><br><span class="line">再执行</span><br><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=raehp \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123456 \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network hmall \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>如果拉取镜像困难的话，可以使用课前资料给大家准备的镜像，利用docker load命令加载：<br><img src="/.com//image-20240520155103703.png" alt="image-20240520155103703"></p><p>可以看到在安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>安装完成后，我们访问 <a href="http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。">http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。</a><br>登录后即可看到管理控制台总览页面：<br><img src="/.com//image-20240520155110997.png" alt="image-20240520155110997"></p><p>RabbitMQ对应的架构如图：<br><img src="/.com//image-20240520155123904.png" alt="image-20240520155123904"><br>其中包含几个概念：</p><ul><li><code>publisher</code>：生产者，也就是发送消息的一方</li><li><code>consumer</code>：消费者，也就是消费消息的一方</li><li><code>queue</code>：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li><code>exchange</code>：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li><code>virtual host</code>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><p>上述这些东西都可以在RabbitMQ的管理控制台来管理，下一节我们就一起来学习控制台的使用。</p><h2 id="收发消息"><a href="#收发消息" class="headerlink" title="收发消息"></a>收发消息</h2><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>我们打开Exchanges选项卡，可以看到已经存在很多交换机：<br><img src="/.com//image-20240520155133970.png" alt="image-20240520155133970"><br>我们点击任意交换机，即可进入交换机详情页面。仍然会利用控制台中的publish message 发送一条消息：<br><img src="/.com//image-20240520155141618.png" alt="image-20240520155141618"><br><img src="/.com//image-20240520155152119.png" alt="image-20240520155152119"><br>这里是由控制台模拟了生产者发送的消息。由于没有消费者存在，最终消息丢失了，这样说明交换机没有存储消息的能力。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>我们打开<code>Queues</code>选项卡，新建一个队列：<br><img src="/.com//image-20240520155201355.png" alt="image-20240520155201355"><br>命名为<code>hello.queue1</code>：<br><img src="/.com//image-20240520155214384.png" alt="image-20240520155214384"><br>再以相同的方式，创建一个队列，密码为<code>hello.queue2</code>，最终队列列表如下：<br><img src="/.com//image-20240520155223193.png" alt="image-20240520155223193"><br>此时，我们再次向<code>amq.fanout</code>交换机发送一条消息。会发现消息依然没有到达队列！！<br>怎么回事呢？<br>发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定。</p><h3 id="绑定关系"><a href="#绑定关系" class="headerlink" title="绑定关系"></a>绑定关系</h3><p>点击<code>Exchanges</code>选项卡，点击<code>amq.fanout</code>交换机，进入交换机详情页，然后点击<code>Bindings</code>菜单，在表单中填写要绑定的队列名称：<br><img src="/.com//image-20240520155230452.png" alt="image-20240520155230452"><br>相同的方式，将hello.queue2也绑定到改交换机。<br>最终，绑定结果如下：<br><img src="/.com//image-20240520155239459.png" alt="image-20240520155239459"></p><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>再次回到exchange页面，找到刚刚绑定的<code>amq.fanout</code>，点击进入详情页，再次发送一条消息：<br><img src="/.com//image-20240520155248841.png" alt="image-20240520155248841"><br>回到<code>Queues</code>页面，可以发现<code>hello.queue</code>中已经有一条消息了：<br><img src="/.com//image-20240520155257118.png" alt="image-20240520155257118"><br>点击队列名称，进入详情页，查看队列详情，这次我们点击get message：<br><img src="/.com//image-20240520155304753.png" alt="image-20240520155304753"><br>可以看到消息到达队列了：<br><img src="/.com//image-20240520155311743.png" alt="image-20240520155311743"><br>这个时候如果有消费者监听了MQ的<code>hello.queue1</code>或<code>hello.queue2</code>队列，自然就能接收到消息了。</p><h2 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a>数据隔离</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>点击<code>Admin</code>选项卡，首先会看到RabbitMQ控制台的用户管理界面：<br><img src="/.com//image-20240520155320670.png" alt="image-20240520155320670"><br>这里的用户都是RabbitMQ的管理或运维人员。目前只有安装RabbitMQ时添加的<code>itheima</code>这个用户。仔细观察用户表格中的字段，如下：</p><ul><li><code>Name</code>：<code>itheima</code>，也就是用户名</li><li><code>Tags</code>：<code>administrator</code>，说明<code>itheima</code>用户是超级管理员，拥有所有权限</li><li><code>Can access virtual host</code>： <code>/</code>，可以访问的<code>virtual host</code>，这里的<code>/</code>是默认的<code>virtual host</code></li></ul><p>对于小型企业而言，出于成本考虑，我们通常只会搭建一套MQ集群，公司内的多个不同项目同时使用。这个时候为了避免互相干扰， 我们会利用<code>virtual host</code>的隔离特性，将不同项目隔离。一般会做两件事情：</p><ul><li>给每个项目创建独立的运维账号，将管理权限分离。</li><li>给每个项目创建不同的<code>virtual host</code>，将每个项目的数据隔离。</li></ul><p>比如，我们给黑马商城创建一个新的用户，命名为<code>hmall</code>：<br><img src="/.com//image-20240520155328522.png" alt="image-20240520155328522"><br>你会发现此时hmall用户没有任何<code>virtual host</code>的访问权限：<br><img src="/.com//image-20240520155334413.png" alt="image-20240520155334413"><br>别急，接下来我们就来授权。</p><h3 id="virtual-host"><a href="#virtual-host" class="headerlink" title="virtual host"></a>virtual host</h3><p>我们先退出登录：<br><img src="/.com//image-20240520155341439.png" alt="image-20240520155341439"><br>切换到刚刚创建的hmall用户登录，然后点击<code>Virtual Hosts</code>菜单，进入<code>virtual host</code>管理页：<br><img src="/.com//image-20240520155350166.png" alt="image-20240520155350166"><br>可以看到目前只有一个默认的<code>virtual host</code>，名字为 <code>/</code>。<br> 我们可以给黑马商城项目创建一个单独的<code>virtual host</code>，而不是使用默认的<code>/</code>。<br><img src="/.com//image-20240520155358050.png" alt="image-20240520155358050"><br>创建完成后如图：<br><img src="/.com//image-20240520155404868.png" alt="image-20240520155404868"><br>由于我们是登录<code>hmall</code>账户后创建的<code>virtual host</code>，因此回到<code>users</code>菜单，你会发现当前用户已经具备了对<code>/hmall</code>这个<code>virtual host</code>的访问权限了：<br><img src="/.com//image-20240520155411548.png" alt="image-20240520155411548"></p><p>此时，点击页面右上角的<code>virtual host</code>下拉菜单，切换<code>virtual host</code>为 <code>/hmall</code>：<br><img src="/.com//image-20240520155417859.png" alt="image-20240520155417859"><br>然后再次查看queues选项卡，会发现之前的队列已经看不到了：<br><img src="/.com//image-20240520155428123.png" alt="image-20240520155428123"><br>这就是基于<code>virtual host </code>的隔离效果。</p><h1 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h1><p>将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互。并且<code>RabbitMQ</code>官方也提供了各种不同语言的客户端。<br>但是，RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<br><a href="https://spring.io/projects/spring-amqp">Spring AMQP</a><br>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><p><img src="/.com//image-20240520170801607.png" alt="image-20240520170801607"></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>在之前的案例中，我们都是经过交换机发送消息到队列，不过有时候为了测试方便，我们也可以直接向队列发送消息，跳过交换机。<br>在入门案例中，我们就演示这样的简单模型，如图：</p><p><img src="/.com//image-20240520165849635.png" alt="image-20240520165849635"></p><p>也就是：</p><ul><li>publisher直接发送消息到队列</li><li>消费者监听并处理队列中的消息</li></ul><p>:::warning<br><strong>注意</strong>：这种模式一般测试使用，很少在生产中使用。<br>:::</p><p>为了方便测试，我们现在控制台新建一个队列：<strong>simple.queue</strong><br><img src="/.com//image-20240520165929119.png" alt="image-20240520165929119"><br>添加成功：<br><img src="/.com//image-20240520165935935.png" alt="image-20240520165935935"><br>接下来，我们就可以利用Java代码收发消息了。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><img src="/.com//image-20240520170133872.png" alt="image-20240520170133872"></p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><p>创建maven工程 引入 amqp的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mq-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>publisher<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>首先配置MQ的地址，在publisher的application.xml中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raehp.publisher.amqp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;This is my first time using Spring AMQP!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h3><p>首先配置MQ的地址，在consumer的application.xml中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>在consumer下创建一个类，用于接收数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raehp.consumer.listeners;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQlistener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span> <span class="comment">// 绑定接收消息的队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到消息: &#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WorkQueues模型"><a href="#WorkQueues模型" class="headerlink" title="WorkQueues模型"></a>WorkQueues模型</h2><p>Work queues，任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。<br><img src="/.com//1687261956699-4b3c9999-ee86-4dda-a795-1ea5f4f9eef3.jpeg"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。<br>此时就可以使用work 模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><p>接下来，我们就来模拟这样的场景。<br>首先，我们在控制台创建一个新的队列，命名为<code>work.queue</code>：<br><img src="/.com//image-20240520173536027.png" alt="image-20240520173536027"></p><h3 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。<br>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息，每20毫秒发送一次，相当于每秒发送50条消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息接收-1"><a href="#消息接收-1" class="headerlink" title="消息接收"></a>消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这两消费者，都设置了<code>Thead.sleep</code>，模拟任务耗时：</p><ul><li>消费者1 sleep了20毫秒，相当于每秒钟处理50个消息</li><li>消费者2 sleep了200毫秒，相当于每秒处理5个消息</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。<br>最终结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.869555300</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_1】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.884518</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.907454400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.953332100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.997867300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.042178700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_3】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.086478800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.087476600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.132578300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.175851200</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.218533400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.261322900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_5】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.287003700</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_20】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.304412400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.349950100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.394533900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.439876500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.482937800</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_7】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.488977100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.526409300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.572148</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.618264800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.660780600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_9】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.689189300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.705261</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.746927300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.789835</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.834393100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.875312100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_11】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.889969500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_48】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.920702500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_13】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.090725900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_15】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.293060600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_17】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.493748</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_19】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.696635100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_21】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.896809700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_23】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.099533400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_25】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.301446400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_27】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.504999100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_29】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.705702500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_31】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.906601200</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_33】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.108118500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_35】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.308945400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_37】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.511547700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_39】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.714038400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_41】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.916192700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_43】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.116286400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_45】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.318055100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_47】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.520656400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_49】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.723106700</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到消费者1和消费者2竟然每人消费了25条消息：</p><ul><li>消费者1很快完成了自己的25条消息</li><li>消费者2却在缓慢的处理自己的25条消息。</li></ul><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。没有充分利用每一个消费者的能力，最终消息处理的耗时远远超过了1秒。这样显然是有问题的。</p><h3 id="能者多劳"><a href="#能者多劳" class="headerlink" title="能者多劳"></a>能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>再次测试，发现结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.659664200</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_1】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.680610</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.703625</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_3】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.724330100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.746651100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_5】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.768401400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.790511400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_7】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.812559800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.834500600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_9】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.857438800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.880379600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_11】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.899327100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.922828400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_13】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.945617400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.968942500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_15】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.992215400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.013325600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_17】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.035687100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.058188</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_19】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.081208400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_20】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.103406200</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_21】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.123827300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.146165100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_23】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.168828300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.191769500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_25】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.214839100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.238998700</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_27】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.259772600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.284131800</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_29】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.306190600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.325315800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_31】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.347012500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.368508600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_33】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.391785100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.416383800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_35】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.439019</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.461733900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_37】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.485990</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.509219900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_39】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.523683400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.547412100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_41】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.571191800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.593024600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_43】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.616731800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.640317</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_45】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.663111100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.686727</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_47】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.709266500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_48】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.725884900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_49】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.746299900</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。<br>正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h2><p>在之前的两个测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：<br><img src="/.com//1687264784359-de7cbc4a-ec60-461d-a6a4-3474ba52e0d0.jpeg"><br>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li><li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li><li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定。</li><li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><p>交换机的类型有四种：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li></ul><p>课堂中，我们讲解前面的三种交换机模式。</p><h2 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。<br>在广播模式下，消息发送流程是这样的：<br><img src="/.com//image-20240520222901247.png" alt="image-20240520222901247"></p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：<br><img src="/.com//image-20240520222907104.png" alt="image-20240520222907104"></p><ul><li>创建一个名为<code> hmall.fanout</code>的交换机，类型是<code>Fanout</code></li><li>创建两个队列<code>fanout.queue1</code>和<code>fanout.queue2</code>，绑定到交换机<code>hmall.fanout</code></li></ul><h3 id="声明队列和交换机"><a href="#声明队列和交换机" class="headerlink" title="声明队列和交换机"></a>声明队列和交换机</h3><p>在控制台创建队列<code>fanout.queue1</code>:<br><img src="/.com//image-20240520222912266.png" alt="image-20240520222912266"><br>在创建一个队列<code>fanout.queue2</code>：<br><img src="/.com//image-20240520222916940.png" alt="image-20240520222916940"><br>然后再创建一个交换机：<br><img src="/.com//image-20240520222922258.png" alt="image-20240520222922258"><br>然后绑定两个队列到交换机：<br><img src="/.com//image-20240520222929038.png" alt="image-20240520222929038"><br><img src="/.com//image-20240520222933949.png" alt="image-20240520222933949"></p><h3 id="消息发送-2"><a href="#消息发送-2" class="headerlink" title="消息发送"></a>消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息接收-2"><a href="#消息接收-2" class="headerlink" title="消息接收"></a>消息接收</h3><p>在consumer服务的MQlistener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><h2 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h2><ul><li>每一个Queue都与Exchange设置一个BindingKey</li><li>发布者发送消息时，指定消息的RoutingKey</li><li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列</li></ul><p><img src="/.com//image-20240521085503107.png" alt="image-20240521085503107"></p><p>创建一个交换机 并与Queues绑定</p><p><img src="/.com//image-20240521085604427.png" alt="image-20240521085604427"></p><p>案例：</p><p><img src="/.com//image-20240521085629898.png" alt="image-20240521085629898"></p><h3 id="消息发送-3"><a href="#消息发送-3" class="headerlink" title="消息发送"></a>消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sendDirectQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 发送的队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sendMessage</span> <span class="operator">=</span> <span class="string">&quot;Everyone can recerive this message.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;blue&quot;</span>, sendMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息接收-3"><a href="#消息接收-3" class="headerlink" title="消息接收"></a>消息接收</h3><p>在consumer服务的MQlistener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1收到了 direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2收到了 direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a>Topic交换机</h2><p>TopicExchange与DirectExchange类似，区别在于routingKey可以是多个单词的列表，并且以 <code>.</code> 分割</p><p>Queue与TopicExchange指定BIndingKey时可以使用通配符：</p><p><img src="/.com//image-20240521091114153.png" alt="image-20240521091114153"></p><p>案例：</p><p><img src="/.com//image-20240521091135017.png" alt="image-20240521091135017"></p><h3 id="消息发送-4"><a href="#消息发送-4" class="headerlink" title="消息发送"></a>消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sendTopicQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 发送的队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sendMessage</span> <span class="operator">=</span> <span class="string">&quot;This is a Topic message.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, sendMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息接收-4"><a href="#消息接收-4" class="headerlink" title="消息接收"></a>消息接收</h3><p>在consumer服务的MQlistener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1收到了 topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2收到了 topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>Topic交换机接收的消息RoutingKEy可以时多个单词，以 <code>.</code> 分割</li><li>Topic交换机与队列帮i当时的bindingKey可以指定通配符</li><li>#：代表0或多个单词</li><li>*：代表1个单词</li></ul><h2 id="声明队列和交换机-1"><a href="#声明队列和交换机-1" class="headerlink" title="声明队列和交换机"></a>声明队列和交换机</h2><p>在之前我们都是基于RabbitMQ控制台来创建队列、交换机。但是在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。在这个过程中是很容易出现错误的。<br>因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。</p><h3 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h3><p>SpringAMQP提供了一个Queue类，用来创建队列：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689945200636-5f4a823f-6f36-4088-9b67-7b9b3ae48079.png#averageHue=%23f9fcf7&clientId=uf6195e90-5366-4&from=paste&height=241&id=u2a7bba30&originHeight=269&originWidth=930&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=42392&status=done&style=none&taskId=uf1b5d62e-4e09-4ba8-a011-f8345dac005&title=&width=833.6134275631213" alt="image.png"></p><p>SpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687181804385-c500bc13-9f81-4071-ad8a-598fa5f57d97.png#averageHue=%23f8f8f7&clientId=u0fe93ba5-a0ba-4&from=paste&height=379&id=Qewqz&originHeight=470&originWidth=1469&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=23466&status=done&style=none&taskId=u357861af-c5aa-43c4-aafd-97dadaf8714&title=&width=1185.0755922629864" alt="image.png"><br><img src="/.com//BaiduNetdiskDownload/RabbitMQ/01.MQ%E5%9F%BA%E7%A1%80/assets/image-20210717165552676.png">我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689945421476-fe44bf9a-d6eb-4f51-af02-374359c8e70b.png#averageHue=%23f8f7f5&clientId=uf6195e90-5366-4&from=paste&height=278&id=uae4334fe&originHeight=310&originWidth=781&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34426&status=done&style=none&taskId=uc1b7bc5b-68b9-4ce9-afe5-9eb733e8f4b&title=&width=700.0560074481696" alt="image.png"><br>而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689945503733-13d2179c-f586-4de5-b18c-d3b5749f1f96.png#averageHue=%23dcab6a&clientId=uf6195e90-5366-4&from=paste&height=145&id=u91096ccd&originHeight=162&originWidth=659&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=16128&status=done&style=none&taskId=u1da153f0-6e86-45b2-900b-8f83e489358&title=&width=590.7002674882763" alt="image.png"></p><h3 id="fanout示例"><a href="#fanout示例" class="headerlink" title="fanout示例"></a>fanout示例</h3><p>在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;hmall.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="direct示例"><a href="#direct示例" class="headerlink" title="direct示例"></a>direct示例</h3><p>direct模式由于要绑定多个KEY，会非常麻烦，每一个Key都要编写一个binding：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Direct类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;hmall.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithRed</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithBlue</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2WithRed</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2WithYellow</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基于注解声明"><a href="#基于注解声明" class="headerlink" title="基于注解声明"></a>基于注解声明</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>例如，我们同样声明Direct模式的交换机和队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是简单多了。<br>再试试Topic模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h2><p>Spring的消息发送代码接收的消息体是一个Object：<br><img src="/.com//image-20240521105722969.png" alt="image-20240521105722969"><br>而在数据传输时，它会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。<br>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="测试默认转换器"><a href="#测试默认转换器" class="headerlink" title="测试默认转换器"></a>测试默认转换器</h3><p>1）创建测试队列<br>首先，我们在consumer服务中声明一个新的配置类：<br><img src="/.com//image-20240521105736799.png" alt="image-20240521105736799"><br>利用@Bean的方式创建一个队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">objectQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;object.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里我们先不要给这个队列添加消费者，我们要查看消息体的格式。</p><p>重启consumer服务以后，该队列就会被自动创建出来了：<br><img src="/.com//image-20240521105745602.png" alt="image-20240521105745602"></p><p>2）发送消息<br>我们在publisher模块的SpringAmqpTest中新增一个消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;object.queue&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息后查看控制台：<br><img src="/.com//image-20240521105755148.png" alt="image-20240521105755148"><br>可以看到消息格式非常不友好。</p><h3 id="配置JSON转换器"><a href="#配置JSON转换器" class="headerlink" title="配置JSON转换器"></a>配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在<code>publisher</code>和<code>consumer</code>两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。</p><p>配置消息转换器，在<code>publisher</code>和<code>consumer</code>两个服务的启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息转换器中添加的messageId可以便于我们将来做幂等性判断。</p><p>此时，我们到MQ控制台<strong>删除</strong><code>object.queue</code>中的旧的消息。然后再次执行刚才的消息发送的代码，到MQ的控制台查看消息结构：<br><img src="/.com//image-20240521105804121.png" alt="image-20240521105804121"></p><h3 id="消费者接收Object"><a href="#消费者接收Object" class="headerlink" title="消费者接收Object"></a>消费者接收Object</h3><p>我们在consumer服务中定义一个新的消费者，publisher是用Map发送，那么消费者也一定要用Map接收，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;object.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(Map&lt;String, Object&gt; msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到object.queue消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在昨天的练习作业中，我们改造了余额支付功能，在支付成功后利用RabbitMQ通知交易服务，更新业务订单状态为已支付。<br>但是大家思考一下，如果这里MQ通知失败，支付服务中支付流水显示支付成功，而交易服务中的订单状态却显示未支付，数据出现了不一致。<br>此时前端发送请求查询支付状态时，肯定是查询交易服务状态，会发现业务订单未支付，而用户自己知道已经支付成功，这就导致用户体验不一致。</p><p>因此，这里我们必须尽可能确保MQ消息的可靠性，即：消息应该至少被消费者处理1次<br>那么问题来了：</p><ul><li><strong>我们该如何确保MQ消息的可靠性</strong>？</li><li><strong>如果真的发送失败，有没有其它的兜底方案？</strong></li></ul><p>这些问题，在今天的学习中都会找到答案。</p><h1 id="发送者的可靠性"><a href="#发送者的可靠性" class="headerlink" title="发送者的可靠性"></a>发送者的可靠性</h1><p>首先，我们一起分析一下消息丢失的可能性有哪些。<br>消息从发送者发送消息，到消费者处理消息，需要经过的流程是这样的：<br><img src="/.com//1687334552247-cab38ab5-ae63-4f06-9ece-e9f244e3c170.jpeg"><br>消息从生产者到消费者的每一步都可能导致消息丢失：</p><ul><li>发送消息时丢失：<ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code></li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li>MQ导致消息丢失：<ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li>消费者处理消息时：<ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p>综上，我们要解决消息丢失问题，保证MQ的可靠性，就必须从3个方面入手：</p><ul><li>确保生产者一定把消息发送到MQ</li><li>确保MQ不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ul><p>这一章我们先来看如何确保生产者一定能把消息发送到MQ。</p><h2 id="生产者重试机制"><a href="#生产者重试机制" class="headerlink" title="生产者重试机制"></a>生产者重试机制</h2><p>首先第一种情况，就是生产者发送消息时，出现了网络故障，导致与MQ的连接中断。</p><p>为了解决这个问题，SpringAMQP提供的消息发送时的重试机制。即：当<code>RabbitTemplate</code>与MQ连接超时后，多次重试。</p><p>修改<code>publisher</code>模块的<code>application.yaml</code>文件，添加下面的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure><p>我们利用命令停掉RabbitMQ服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop mq</span><br></pre></td></tr></table></figure><p>然后测试发送一条消息，会发现会每隔1秒重试1次，总共重试了3次。消息发送的超时重试机制配置成功了！</p><p><strong>注意</strong>：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。<br>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p><h2 id="生产者确认机制"><a href="#生产者确认机制" class="headerlink" title="生产者确认机制"></a>生产者确认机制</h2><p>一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题。<br>不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：</p><ul><li>MQ内部处理消息的进程发生了异常</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code>，因此无法路由</li></ul><p>因此 RabbitMQ生产了Publisher Confirm 和 Publisher Return 两种确认机制，开启确认机制后，在MQ成功收到消息后 会返回确认消息给生产者，返回的结果有以下几种：</p><ul><li>消息投递到了MQ，但是路由失败，此时会通过Publisher Return 返回路由异常原因，然后返回 <code>ACK</code>，告知投递成功</li><li>临时消息投递到了MQ，并且如对成功 返回 <code>ACK</code> 告知投递成功</li><li>持久消息投递到MQ，并且入队完成持久化，返回 <code>ACK</code> 告知投递成功</li><li>其他情况下都返回 <code>NACK</code> , 告知投递失败（比如：持久消息，入队 但是持久化本地时，磁盘满了 持久化失败）</li></ul><p><img src="/.com//image-20240521143410762.png" alt="image-20240521143410762"></p><h2 id="实现生产者确认"><a href="#实现生产者确认" class="headerlink" title="实现生产者确认"></a>实现生产者确认</h2><h3 id="开启生产者确认"><a href="#开启生产者确认" class="headerlink" title="开启生产者确认"></a>开启生产者确认</h3><p>在publisher模块的<code>application.yaml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure><p>这里<code>publisher-confirm-type</code>有三种模式可选：</p><ul><li><code>none</code>：关闭confirm机制</li><li><code>simple</code>：同步阻塞等待MQ的回执</li><li><code>correlated</code>：MQ异步回调返回回执</li></ul><p>一般我们推荐使用<code>correlated</code>，回调机制。</p><h3 id="定义ReturnCallback"><a href="#定义ReturnCallback" class="headerlink" title="定义ReturnCallback"></a>定义ReturnCallback</h3><p>每个<code>RabbitTemplate</code>只能配置一个<code>ReturnCallback</code>，因此我们可以在配置类中统一设置。我们在publisher模块定义一个配置类：<br><img src="/.com//image-20240521170234881.png" alt="image-20240521170234881"><br>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.publisher.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ReturnedMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;触发return callback,&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义ConfirmCallback"><a href="#定义ConfirmCallback" class="headerlink" title="定义ConfirmCallback"></a>定义ConfirmCallback</h3><p>由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中的convertAndSend方法时，多传递一个参数：<br><img src="/.com//image-20240521170228729.png" alt="image-20240521170228729"><br>这里的CorrelationData中包含两个核心的东西：</p><ul><li><code>id</code>：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆</li><li><code>SettableListenableFuture</code>：回执结果的Future对象</li></ul><p>将来MQ的回执就会通过这个<code>Future</code>来返回，我们可以提前给<code>CorrelationData</code>中的<code>Future</code>添加回调函数来处理消息回执：<br><img src="/.com//image-20240521170220854.png" alt="image-20240521170220854"></p><p>我们新建一个测试，向系统自带的交换机发送消息，并且添加<code>ConfirmCallback</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建CorrelationData</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">    <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">            log.error(<span class="string">&quot;send message fail&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123; <span class="comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                log.error(<span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="/.com//image-20240521170212281.png" alt="image-20240521170212281"><br>可以看到，由于传递的<code>RoutingKey</code>是错误的，路由失败后，触发了<code>return callback</code>，同时也收到了ack。<br>当我们修改为正确的<code>RoutingKey</code>以后，就不会触发<code>return callback</code>了，只收到ack。<br>而如果连交换机都是错误的，则只会收到nack。</p><p>:::warning<br><strong>注意</strong>：<br>开启生产者确认比较消耗MQ性能，一般不建议开启。而且大家思考一下触发确认的几种情况：</p><ul><li>路由失败：一般是因为RoutingKey错误导致，往往是编程导致</li><li>交换机名称错误：同样是编程错误导致</li><li>MQ内部故障：这种需要处理，但概率往往较低。因此只有对消息可靠性要求非常高的业务才需要开启，而且仅仅需要开启ConfirmCallback处理nack就可以了。<br>:::</li></ul><p>如何处理生产者的确认消息？</p><ul><li>生产者确认需要额外的网络和系统资源开销，尽量不要使用</li><li>如果一定要使用，无需开启Publisher-Return机制，因为一般路由失败时自己业务问题</li><li>对应nack消息可以有限次数重试，依然失败则记录异常消息</li></ul><h1 id="MQ的可靠性"><a href="#MQ的可靠性" class="headerlink" title="MQ的可靠性"></a>MQ的可靠性</h1><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟，这样会导致两个问题；</p><ul><li>一旦MQ宕机，内存中的信息会丢失</li><li>内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发MQ阻塞</li></ul><p><img src="/.com//image-20240521162709236.png" alt="image-20240521162709236"></p><p>如上图，当队列存满时，就无法添加新的消息到队列中，这个时候 后面的进程都会在这等待，此时，RabbitMQ会做一件事 称之为PageOut他会将那些老的消息 存到本地磁盘</p><p><img src="/.com//image-20240521162820532.png" alt="image-20240521162820532"></p><p>这个时候有两种模式供我们使用：</p><ul><li>数据持久化</li><li>Lazy Queue</li></ul><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>RabbitMQ实现数据持久化包含3个方面：</p><ul><li>交换机持久化<ul><li><img src="/.com//image-20240521164002701.png" alt="image-20240521164002701"></li></ul></li><li>队列持久化<ul><li><img src="/.com//image-20240521164011700.png" alt="image-20240521164011700"></li></ul></li><li>消息持久化<ul><li><img src="/.com//image-20240521163951026.png" alt="image-20240521163951026"></li></ul></li></ul><h2 id="Lazy-Queue"><a href="#Lazy-Queue" class="headerlink" title="Lazy Queue"></a>Lazy Queue</h2><h3 id="控制台配置Lazy模式"><a href="#控制台配置Lazy模式" class="headerlink" title="控制台配置Lazy模式"></a>控制台配置Lazy模式</h3><p>在添加队列的时候，添加<code>x-queue-mod=lazy</code>参数即可设置队列为Lazy模式：</p><p><img src="/.com//image-20240521165507938.png" alt="image-20240521165507938"></p><h3 id="代码配置Lazy模式"><a href="#代码配置Lazy模式" class="headerlink" title="代码配置Lazy模式"></a>代码配置Lazy模式</h3><p>在利用SpringAMQP声明队列的时候，添加<code>x-queue-mod=lazy</code>参数也可设置队列为Lazy模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过<code>QueueBuilder</code>的<code>lazy()</code>函数配置Lazy模式，底层源码如下：</p><p><img src="/.com//image-20240521165604656.png" alt="image-20240521165604656"></p><p>当然，我们也可以基于注解来声明队列并设置为Lazy模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新已有队列为lazy模式"><a href="#更新已有队列为lazy模式" class="headerlink" title="更新已有队列为lazy模式"></a>更新已有队列为lazy模式</h3><p>对于已经存在的队列，也可以配置为lazy模式，但是要通过设置policy实现。<br>可以基于命令行设置policy：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues  </span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>当然，也可以在控制台配置policy，进入在控制台的<code>Admin</code>页面，点击<code>Policies</code>，即可添加配置：<br><img src="/.com//image-20240521165718035.png" alt="image-20240521165718035"></p><h1 id="消费者可靠性"><a href="#消费者可靠性" class="headerlink" title="消费者可靠性"></a>消费者可靠性</h1><h2 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h2><p>为了确认消费者是否成功处理消息，RabbiMQ提供了消费者确认机制。当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态，绘制有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p><img src="/.com//image-20240522135625224.png" alt="image-20240522135625224"></p><p>SpringAMQP已经实现了消息确认功能，并允许我们通过配置文件选择AVK处理放hi是，有三种方式：</p><ul><li><p><code>none </code>：不处理，即消息投递给消费者后立刻<strong>ack</strong>，消息会立刻从MQ删除，非常不安全，不建议使用</p></li><li><p><code>manual</code> ：手动模式，需要自己在业务代码中调用api，发送<strong>ack</strong>和<strong>reject</strong>，存在业务入侵，但更灵活</p></li><li><p><code>auto</code> ：自动模式，SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则返回ack</p><p>当业务出现异常时，根据异常判断返回不同结果:</p><ul><li>如果时业务异常，会自动返回nack</li><li>如果是消息处理异常或校验异常，自动返回reject</li></ul></li></ul><p>返回Reject的常见异常有：</p><blockquote><p>Starting with version 1.3.2, the default ErrorHandler is now a ConditionalRejectingErrorHandler that rejects (and does not requeue) messages that fail with an irrecoverable error. Specifically, it rejects messages that fail with the following errors:</p><ul><li>o.s.amqp…MessageConversionException: Can be thrown when converting the incoming message payload using a MessageConverter.</li><li>o.s.messaging…MessageConversionException: Can be thrown by the conversion service if additional conversion is required when mapping to a @RabbitListener method.</li><li>o.s.messaging…MethodArgumentNotValidException: Can be thrown if validation (for example, @Valid) is used in the listener and the validation fails.</li><li>o.s.messaging…MethodArgumentTypeMismatchException: Can be thrown if the inbound message was converted to a type that is not correct for the target method. For example, the parameter is declared as Message<Foo> but Message<Bar> is received.</Bar></Foo></li><li>java.lang.NoSuchMethodException: Added in version 1.6.3.</li><li>java.lang.ClassCastException: Added in version 1.6.3.</li></ul></blockquote><p>通过下面的配置可以修改SpringAMQP的ACK处理方式：</p><p>在consumer中的application.yml中配置如下信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动ack</span></span><br></pre></td></tr></table></figure><h2 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h2><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。<br>极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力：</p><p><img src="/.com//image-20240522145031698.png" alt="image-20240522145031698"></p><p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列</p><p>在consumer的application.yml中配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><h2 id="失败处理策略"><a href="#失败处理策略" class="headerlink" title="失败处理策略"></a>失败处理策略</h2><p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code> ：重试耗尽后，直接rejecct，丢弃消息，默认就是这种方式</li><li><code>ImmediateRequeueMessageRecover</code> ：重试耗尽后，返回nack，消息重新入队</li><li><code>RepublishMessageRecover</code> ：重试耗尽后，将失败的消息投递到指定的交换机</li></ul><p><img src="/.com//image-20240522145440384.png" alt="image-20240522145440384"></p><p>比较优雅的一种处理方案是<code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p><p>1）在consumer服务中定义处理失败消息的交换机和队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）定义一个RepublishMessageRecoverer，关联队列和交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.MessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.rabbitmq.listener.simple.retry.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h2><p>何为幂等性？<br><strong>幂等</strong>是一个数学概念，用函数表达式来描述是这样的：<code>f(x) = f(f(x))</code>，例如求绝对值函数。<br>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p><ul><li>根据id删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，我们要尽可能避免业务被重复执行。<br>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ消息的重复投递</li></ul><p>我们在用户支付成功后会发送MQ消息到交易服务，修改订单状态为已支付，就可能出现消息重复投递的情况。如果消费者不做判断，很有可能导致消息被消费多次，出现业务故障。<br>举例：</p><ol><li>假如用户刚刚支付完成，并且投递消息到交易服务，交易服务更改订单为<strong>已支付</strong>状态。</li><li>由于某种原因，例如网络故障导致生产者没有得到确认，隔了一段时间后<strong>重新投递</strong>给交易服务。</li><li>但是，在新投递的消息被消费之前，用户选择了退款，将订单状态改为了<strong>已退款</strong>状态。</li><li>退款完成后，新投递的消息才被消费，那么订单状态会被再次改为<strong>已支付</strong>。业务异常。</li></ol><p>因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：</p><ul><li>唯一消息ID</li><li>业务状态判断</li></ul><h3 id="唯一消息ID"><a href="#唯一消息ID" class="headerlink" title="唯一消息ID"></a>唯一消息ID</h3><p>这个思路非常简单：</p><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>我们该如何给消息添加唯一ID呢？<br>其实很简单，SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。<br>以Jackson的消息转换器为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务判断"><a href="#业务判断" class="headerlink" title="业务判断"></a>业务判断</h3><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。<br>例如我们当前案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们就可以在执行业务时判断订单状态是否是未支付，如果不是则证明订单已经被处理过，无需重复处理。</p><p>相比较而言，消息ID的方案需要改造原有的数据库，所以我更推荐使用业务判断的方案。</p><p>以支付修改订单的业务为例，我们需要修改<code>OrderServiceImpl</code>中的<code>markOrderPaySuccess</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">old</span> <span class="operator">=</span> getById(orderId);</span><br><span class="line">    <span class="comment">// 2.判断订单状态</span></span><br><span class="line">    <span class="keyword">if</span> (old == <span class="literal">null</span> || old.getStatus() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 订单不存在或者订单状态不是1，放弃处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.尝试更新订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    order.setStatus(<span class="number">2</span>);</span><br><span class="line">    order.setPayTime(LocalDateTime.now());</span><br><span class="line">    updateById(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码逻辑上符合了幂等判断的需求，但是由于判断和更新是两步动作，因此在极小概率下可能存在线程安全问题。</p><p>我们可以合并上述操作为这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// UPDATE `order` SET status = ? , pay_time = ? WHERE id = ? AND status = 1</span></span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(Order::getStatus, <span class="number">2</span>)</span><br><span class="line">            .set(Order::getPayTime, LocalDateTime.now())</span><br><span class="line">            .eq(Order::getId, orderId)</span><br><span class="line">            .eq(Order::getStatus, <span class="number">1</span>)</span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看，上述代码等同于这样的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `<span class="keyword">order</span>` <span class="keyword">SET</span> status <span class="operator">=</span> ? , pay_time <span class="operator">=</span> ? <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们在where条件中除了判断id以外，还加上了status必须为1的条件。如果条件不符（说明订单已支付），则SQL匹配不到数据，根本不会执行。</p><h2 id="兜底方案"><a href="#兜底方案" class="headerlink" title="兜底方案"></a>兜底方案</h2><p>虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息100%的可靠。万一真的MQ通知失败该怎么办呢？<br>有没有其它兜底方案，能够确保订单的支付状态一致呢？</p><p>其实思想很简单：既然MQ通知不一定发送到交易服务，那么交易服务就必须自己<strong>主动去查询</strong>支付状态。这样即便支付服务的MQ通知失败，我们依然能通过主动查询来保证订单状态的一致。<br>流程如下：<br><img src="/.com//1687521150465-25b54b36-b64a-4b2d-90b7-8dff12fb075b.jpeg"></p><p>图中黄色线圈起来的部分就是MQ通知失败后的兜底处理方案，由交易服务自己主动去查询支付状态。</p><p>不过需要注意的是，交易服务并不知道用户会在什么时候支付，如果查询的时机不正确（比如查询的时候用户正在支付中），可能查询到的支付状态也不正确。<br>那么问题来了，我们到底该在什么时间主动查询支付状态呢？</p><p>这个时间是无法确定的，因此，通常我们采取的措施就是利用<strong>定时任务</strong>定期查询，例如每隔20秒就查询一次，并判断支付状态。如果发现订单已经支付，则立刻更新订单状态为已支付即可。<br>定时任务大家之前学习过，具体的实现这里就不再赘述了。</p><p>至此，消息可靠性的问题已经解决了。</p><p>综上，支付服务与交易服务之间的订单状态一致性是如何保证的？</p><ul><li>首先，支付服务会正在用户支付成功以后利用MQ消息通知交易服务，完成订单状态同步。</li><li>其次，为了保证MQ消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递的可靠性</li><li>最后，我们还在交易服务设置了定时任务，定期查询订单支付状态。这样即便MQ通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性。</li></ul><h1 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h1><p>延迟消息：生产者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间后才收到消息。</p><p>延迟任务：设置在一定时间后才执行的任务</p><p><img src="/.com//image-20240522154115819.png" alt="image-20240522154115819"></p><h2 id="死信交换机和延迟消息"><a href="#死信交换机和延迟消息" class="headerlink" title="死信交换机和延迟消息"></a>死信交换机和延迟消息</h2><p>首先我们来学习一下基于死信交换机的延迟消息方案。</p><h3 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h3><p>什么是死信？</p><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过<code>dead-letter-exchange</code>属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为<strong>死信交换机</strong>（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p><p>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><h3 id="延迟消息-1"><a href="#延迟消息-1" class="headerlink" title="延迟消息"></a>延迟消息</h3><p>前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试时讲的<code>RepublishMessageRecoverer</code>作用类似。</p><p>而最后一种场景，大家设想一下这样的场景：<br>如图，有一组绑定的交换机（<code>ttl.fanout</code>）和队列（<code>ttl.queue</code>）。但是<code>ttl.queue</code>没有消费者监听，而是设定了死信交换机<code>hmall.direct</code>，而队列<code>direct.queue1</code>则与死信交换机绑定，RoutingKey是blue：<br><img src="/.com//image-20240522155953972.png" alt="image-20240522155953972"></p><p>假如我们现在发送一条消息到<code>ttl.fanout</code>，RoutingKey为blue，并设置消息的<strong>有效期</strong>为5000毫秒：<br><img src="/.com//image-20240522155947491.png" alt="image-20240522155947491"><br>:::warning<br><strong>注意</strong>：尽管这里的<code>ttl.fanout</code>不需要RoutingKey，但是当消息变为死信并投递到死信交换机时，会沿用之前的RoutingKey，这样<code>hmall.direct</code>才能正确路由消息。<br>:::</p><p>消息肯定会被投递到<code>ttl.queue</code>之后，由于没有消费者，因此消息无人消费。5秒之后，消息的有效期到期，成为死信：<br><img src="/.com//image-20240522155938360.png" alt="image-20240522155938360"><br>死信被再次投递到死信交换机<code>hmall.direct</code>，并沿用之前的RoutingKey，也就是<code>blue</code>：<br><img src="/.com//image-20240522155933142.png" alt="image-20240522155933142"><br>由于<code>direct.queue1</code>与<code>hmall.direct</code>绑定的key是blue，因此最终消息被成功路由到<code>direct.queue1</code>，如果此时有消费者与<code>direct.queue1</code>绑定， 也就能成功消费消息了。但此时已经是5秒钟以后了：<br><img src="/.com//image-20240522155927448.png" alt="image-20240522155927448"><br>也就是说，publisher发送了一条消息，但最终consumer在5秒后才收到消息。我们成功实现了<strong>延迟消息</strong>。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>注意：</strong><br>RabbitMQ的消息过期是基于追溯方式来实现的，也就是说当一个消息的TTL到期以后不一定会被移除或投递到死信交换机，而是在消息恰好处于队首时才会被处理。<br>当队列中消息堆积很多的时候，过期消息可能不会被按时处理，因此你设置的TTL时间不一定准确。</p><h2 id="DelayExchange插件"><a href="#DelayExchange插件" class="headerlink" title="DelayExchange插件"></a>DelayExchange插件</h2><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此RabbitMQ社区提供了一个延迟消息插件来实现相同的效果。<br>官方文档说明：<br><a href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">Scheduling Messages with RabbitMQ | RabbitMQ - Blog</a></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>插件下载地址：<br><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">GitHub - rabbitmq&#x2F;rabbitmq-delayed-message-exchange: Delayed Messaging for RabbitMQ</a><br>由于我们安装的MQ是<code>3.8</code>版本，因此这里下载<code>3.8.17</code>版本：<br><img src="/.com//image-20240522181506181.png" alt="image-20240522181506181"></p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>因为我们是基于Docker安装，所以需要先查看RabbitMQ的插件目录对应的数据卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2024-06-19T09:22:59+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/mq-plugins/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;mq-plugins&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，我们上传插件到该目录下。</p><p>接下来执行命令，安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/.com//image-20240522181528222.png" alt="image-20240522181528222"></p><h3 id="声明延迟交换机"><a href="#声明延迟交换机" class="headerlink" title="声明延迟交换机"></a>声明延迟交换机</h3><p>基于注解方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于<code>@Bean</code>的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="发送延迟消息"><a href="#发送延迟消息" class="headerlink" title="发送延迟消息"></a>发送延迟消息</h3><p>发送消息时，必须通过x-delay属性设定延迟时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:::warning<br><strong>注意：</strong><br>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，同时延迟消息的时间会存在误差。<br>因此，<strong>不建议设置延迟时间过长的延迟消息</strong>。<br>:::</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tools</title>
      <link href="/2024/05/13/tools/"/>
      <url>/2024/05/13/tools/</url>
      
        <content type="html"><![CDATA[<h1 id="实用工具箱"><a href="#实用工具箱" class="headerlink" title="实用工具箱"></a>实用工具箱</h1><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><ul><li><a href="https://sci-hub.se/">Sci-Hub</a>: Elbakyan 女神向你挥手，旨在打破知识壁垒的革命性网站。</li><li><a href="http://libgen.is/">Library Genesis</a>: 电子书下载网站。</li><li><a href="https://zlibrary-global.se/">Z-library</a>: 电子书下载网站（在 <a href="https://www.torproject.org/">Tor</a> 下运行较佳，<a href="http://loginzlib2vrak5zzpcocc3ouizykn6k5qecgj2tzlnab5wcbqhembyd.onion/">链接</a>）。</li><li><a href="https://z-epub.com/">Z-ePub</a>: ePub 电子书下载网站。</li><li><a href="https://www.pdfdrive.com/">PDF Drive</a>: PDF 电子书搜索引擎。</li><li><a href="https://magazinelib.com/">MagazineLib</a>: PDF 电子杂志下载网站。</li><li><a href="https://bitdownloader.io/">BitDownloader</a>: 油管视频下载器。</li><li><a href="https://www.qbittorrent.org/download.php">qBittorrent</a>: BitTorrent 客户端。</li><li><a href="https://www.utorrent.com/">uTorrent</a>: BitTorrent 客户端。</li><li><a href="https://std.samr.gov.cn/">全国标准信息公共服务平台</a>：各类标准查询和下载官方平台。</li><li><a href="http://www.standards.com.cn/">标准知识服务系统</a>：检索与阅读所需标准。</li><li><a href="https://msdn.itellyou.cn/">MSDN,我告诉你</a>: Windows 操作系统镜像下载站，也有许多其他软件的下载。</li></ul><h2 id="设计工具"><a href="#设计工具" class="headerlink" title="设计工具"></a>设计工具</h2><ul><li><a href="https://excalidraw.com/">excalidraw</a>: 一款手绘风格的绘图工具，非常适合绘制课程报告或者PPT内的示意图。</li><li><a href="https://www.tldraw.com/">tldraw</a>: 一个绘图工具，适合画流程图，架构图等。</li><li><a href="https://app.diagrams.net/">draw.io</a>: 强大简洁的在线的绘图网站，支持流程图，UML图，架构图，原型图等等，支持 Onedrive, Google Drive, Github 导出，同时提供离线客户端。</li><li><a href="https://www.origamiway.com/paper-folding-crafts-step-by-step.shtml">origamiway</a>: 手把手教你怎么折纸。</li><li><a href="https://www.thingiverse.com/">thingiverse</a>: 囊括各类 2D&#x2F;3D 设计资源，其 STL 文件下载可直接 3D 打印。</li><li><a href="https://www.iconfont.cn/">iconfont</a>: 国内最大的图标和插画资源库，可用于开发或绘制系统架构图。</li><li><a href="https://www.turbosquid.com/">turbosquid</a>: 可以购买各式各样的模型。</li><li><a href="https://www.flaticon.com/">flaticon</a>: 可下载免费且高质量的图标。</li><li><a href="http://bzdt.ch.mnr.gov.cn/">标准地图服务系统</a>: 可以下载官方标准地图。</li><li><a href="https://plantuml.com/zh/">PlantUML</a>: 可以使用代码快速编写 UML 图。</li></ul><h2 id="编程相关"><a href="#编程相关" class="headerlink" title="编程相关"></a>编程相关</h2><ul><li><a href="http://www.sqlfiddle.com/">sqlfiddle</a>: 一个简易的在线 SQL Playground。</li><li><a href="https://sqlzoo.net/wiki/SQL_Tutorial">sqlzoo</a>：在线练习 sql 语句。</li><li><a href="https://godbolt.org/">godbolt</a>: 非常方便的编译器探索工具。你可以写一段 C&#x2F;C++ 代码，选择一款编译器，然后便可以观察生成的具体汇编代码。</li><li><a href="https://explainshell.com/">explainshell</a>: 你是否曾为一段 shell 代码的具体含义感到困扰？manpage 看半天还是不明所以？试试这个网站！</li><li><a href="https://regex101.com/">regex101</a>: 正则表达式调试网站，支持各种编程语言的匹配标准。</li><li><a href="https://www.typingtom.com/lessons">typingtom</a>: 针对程序员的打字练习&#x2F;测速网站。</li><li><a href="https://github.com/wg/wrk">wrk</a>: 网站压测工具。</li><li><a href="https://www.gbmb.org/">gbmb</a>: 数据单位转换。</li><li><a href="https://tools.fun/">tools</a>: 在线工具合集。</li><li><a href="https://github1s.com/">github1s</a>: 用网页版 VS Code 在线阅读 GitHub 代码。</li><li><a href="https://visualgo.net/en">visualgo</a>: 算法可视化网站。</li><li><a href="http://www.rmboot.com/">DataStructureVisual</a>: 数据结构可视化网站。</li><li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a>: 数据结构与算法的可视化网站。</li><li><a href="https://learngitbranching.js.org/?locale=zh_CN">learngitbranching</a>: 可视化学习 git。</li><li><a href="https://unicode-table.com/en/">UnicodeCharacter</a>: Unicode 字符集网站。</li><li><a href="https://extendsclass.com/regex-tester.html">cyrilex</a>: 一个用于测试和可视化正则表达式的网站，支持各种编程语言标准。</li><li><a href="https://softwium.com/mockium/">mockium</a>: 生成测试数据的平台。</li></ul><h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><ul><li><a href="https://hepsoftwarefoundation.org/training/curriculum.html">HFS</a>: 各类软件教程。</li><li><a href="https://www.shadertoy.com/">Shadertoy</a>: 编写各式各样的 shader。</li><li><a href="https://conanhujinming.github.io/comments-for-awesome-courses/">comments-for-awesome-courses</a>: 名校公开课评价网。</li><li><a href="https://codetop.cc/home">codetop</a>: 企业题库。</li><li><a href="https://github.com/Developer-Y/cs-video-courses">cs-video-courses</a>: 带有视频讲座的计算机科学课程列表。</li><li><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/include/linux">bootlin</a>: 在线阅读 Linux 源码。</li><li><a href="https://github.com/tianyilt/ecnu-PGCourseShare">ecust-CourseShare</a>: 华东师范大学研究生课程攻略共享计划。</li><li><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT">REKCARC-TSC-UHT</a>: 清华大学计算机系课程攻略。</li><li><a href="https://github.com/oneman233/seu-master">seu-master</a>: 东南大学研究生课程资料整理。</li><li><a href="https://www.runoob.com/">菜鸟教程</a>: 计算机相关知识的简要的教程。</li><li><a href="https://book.bsdcn.org/">FreeBSD 从入门到跑路</a>: 一本 FreeBSD 的中文教程。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn">MDN Web Docs</a>: MDN 网络开发入门手册。</li><li><a href="https://www.hello-algo.com/">Hello 算法</a>: 动画图解、能运行、可提问的数据结构与算法快速入门教程。</li></ul><h2 id="百科网站-词典性质的网站"><a href="#百科网站-词典性质的网站" class="headerlink" title="百科网站&#x2F;词典性质的网站"></a>百科网站&#x2F;词典性质的网站</h2><ul><li><a href="https://wiki.osdev.org/Main_Page">os-wiki</a>: 操作系统技术资源百科全书。</li><li><a href="https://docs.freebsd.org/en/">FreeBSD Documentation</a>: FreeBSD 官方文档。</li><li><a href="https://docs.python.org/zh-cn/3/">Python3 Documentation</a>: Python3 官方中文文档。</li><li><a href="https://en.cppreference.com/w/">C++ Reference</a>: C++ 参考手册。</li><li><a href="https://oi-wiki.org/">OI Wiki</a>: 编程竞赛知识整合站点。</li><li><a href="https://learn.microsoft.com/zh-cn/">Microsoft Learn</a>: 微软官方的学习平台，包含了绝大多数微软产品的文档。</li><li><a href="https://wiki.archlinux.org/">Arch Wiki</a>: 专为 Arch Linux 而写的 Wiki，包含了大量 Linux 相关的知识。</li><li><a href="https://wiki.qt.io/Main">Qt Wiki</a>: Qt 官方 Wiki。</li><li><a href="https://opencv.apachecn.org/#/">OpenCV 中文文档</a>: OpenCV 的社区版中文文档。</li><li><a href="https://docs.npmjs.com/">npm Docs</a>: npm 官方文档。</li></ul><h2 id="交流平台"><a href="#交流平台" class="headerlink" title="交流平台"></a>交流平台</h2><ul><li><a href="https://github.com/">GitHub</a>: 许多开源项目的托管平台，也是许多开源项目的主要交流平台，通过查看 issue 可以解决许多问题。</li><li><a href="https://stackexchange.com/">StackExchange</a>: Stack Exchange 是由 181 个问答社区组成（其中包括 Stack Overflow）的编程社区。</li><li><a href="https://stackoverflow.com/">StackOverflow</a>: Stack Overflow 是一个与程序相关的 IT 技术问答网站。</li><li><a href="https://gitee.com/">Gitee</a>: 一个类似于 GitHub 的代码托管平台，可以在对应项目的 issue 里查找一些常见问题的解答。</li><li><a href="https://www.zhihu.com/">知乎</a>: 一个类似于 Quora 的问答社区，可以在其中提问，一些问答包含有计算机的知识。</li><li><a href="https://www.cnblogs.com/">博客园</a>: 一个面向开发者的知识分享社区，拥有一些常见问题的博客，正确率不能保证，请谨慎使用。</li><li><a href="https://blog.csdn.net/">CSDN</a>: 拥有一些常见问题的博客，正确率不能保证，请谨慎使用。</li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><a href="https://tophub.today/">tophub</a>: 新闻热榜合集（综合了知乎、微博、百度、微信等）。</li><li><a href="https://feedly.com/">feedly</a>: 著名的 RSS 订阅源阅读器。</li><li><a href="https://www.speedtest.net/zh-Hans">speedtest</a>: 在线网络测速网站。</li><li><a href="https://github.com/public-apis/public-apis">public-apis</a>: 公共 API 合集列表。</li><li><a href="https://zh.numberempire.com/derivativecalculator.php">numberempire</a>: 函数求导工具。</li><li><a href="https://sustech-application.com/#/grad-application/computer-science-and-engineering/README">sustech-application</a>: 南方科技大学经验分享网。</li><li><a href="https://vim-adventures.com/">vim-adventures</a>: 一款基于 vim 键盘快捷键的在线游戏。</li><li><a href="https://vimsnake.com/">vimsnake</a>: 利用 vim 玩贪吃蛇。</li><li><a href="https://www.keybr.com/">keybr</a>: 学习盲打的网站。</li><li><a href="https://cpp.libhunt.com/">Awesome C++</a>: 很棒的 C&#x2F;C++ 框架、库、资源精选列表。</li><li><a href="https://hellogithub.com/">HelloGitHub</a>: 分享 GitHub 上有趣、入门级的开源项目。</li><li><a href="https://github.com/DEAKSoftware/Synergy-Binaries">Synergy</a>: 一套键鼠能控制多台电脑。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2</title>
      <link href="/2024/05/10/Vue2/"/>
      <url>/2024/05/10/Vue2/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要学习Vue"><a href="#为什么要学习Vue" class="headerlink" title="为什么要学习Vue"></a>为什么要学习Vue</h1><p>1.前端必备技能</p><p>2.岗位多，绝大互联网公司都在使用Vue</p><p>3.提高开发效率</p><p>4.高薪必备技能（Vue2+Vue3）</p><h1 id="什么是Vue"><a href="#什么是Vue" class="headerlink" title="什么是Vue"></a>什么是Vue</h1><p>概念：Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套 **构建用户界面 ** 的 <strong>渐进式</strong> <strong>框架</strong></p><p>Vue2官网：<a href="https://v2.cn.vuejs.org/">https://v2.cn.vuejs.org/</a></p><h3 id="1-什么是构建用户界面"><a href="#1-什么是构建用户界面" class="headerlink" title="1.什么是构建用户界面"></a>1.什么是构建用户界面</h3><p><strong>基于数据</strong>渲染出用户可以看到的<strong>界面</strong></p><p><img src="/.com//1681875887026.png" alt="68187588702"></p><h3 id="2-什么是渐进式"><a href="#2-什么是渐进式" class="headerlink" title="2.什么是渐进式"></a>2.什么是渐进式</h3><p>所谓渐进式就是循序渐进，不一定非得把Vue中的所有API都学完才能开发Vue，可以学一点开发一点</p><h4 id="Vue的两种开发方式："><a href="#Vue的两种开发方式：" class="headerlink" title="Vue的两种开发方式："></a>Vue的两种开发方式：</h4><ol><li><p>Vue核心包开发</p><p>场景：局部模块改造</p></li><li><p>Vue核心包&amp;Vue插件&amp;工程化</p><p>场景：整站开发</p></li></ol><h3 id="3-什么是框架"><a href="#3-什么是框架" class="headerlink" title="3.什么是框架"></a>3.什么是框架</h3><p>所谓框架：就是一套完整的解决方案</p><p><strong>举个栗子</strong></p><p>如果把一个完整的项目比喻为一个装修好的房子，那么框架就是一个毛坯房。</p><p>我们只需要在“毛坯房”的基础上，增加功能代码即可。</p><p>提到框架，不得不提一下库。</p><ul><li>库，类似工具箱，是一堆方法的集合，比如 axios、lodash、echarts等</li><li>框架，是一套完整的解决方案，实现了大部分功能，我们只需要按照一定的规则去编码即可。</li></ul><p>下图是 库 和 框架的对比。</p><p><img src="/.com//1681876620277.png" alt="68187662027"></p><p>框架的特点：有一套必须让开发者遵守的<strong>规则</strong>或者<strong>约束</strong></p><p>咱们学框架就是学习的这些规则 <a href="https://v2.cn.vuejs.org/">官网</a></p><h3 id="总结：什么是Vue？"><a href="#总结：什么是Vue？" class="headerlink" title="总结：什么是Vue？"></a>总结：什么是Vue？</h3><p>Vue是什么：</p><p>什么是构建用户界面：</p><p>什么是渐进式：</p><p>什么是框架：</p><h1 id="创建Vue实例"><a href="#创建Vue实例" class="headerlink" title="创建Vue实例"></a>创建Vue实例</h1><p>我们已经知道了Vue框架可以 基于数据帮助我们渲染出用户界面，那应该怎么做呢？</p><p><img src="/.com//1681877190137.png" alt="68187719013"></p><p>比如就上面这个数据，基于提供好的msg 怎么渲染后右侧可展示的数据呢？</p><p><strong>核心步骤（4步）：</strong></p><ol><li>准备容器</li><li>引包（官网） — 开发版本&#x2F;生产版本</li><li>创建Vue实例  new Vue()</li><li>指定配置项，渲染数据<ol><li>el:指定挂载点</li><li>data提供数据</li></ol></li></ol><p><img src="/.com//1681877405007.png" alt="68187740500"></p><p><strong>总结：创建Vue实例需要执行哪4步</strong></p><h1 id="插值表达式-“-”"><a href="#插值表达式-“-”" class="headerlink" title="插值表达式 “{}”"></a>插值表达式 “{}”</h1><p>插值表达式是一种Vue的模板语法</p><p>我们可以用插值表达式渲染出Vue提供的数据</p><p><img src="/.com//1681886494417.png" alt="68188649441"></p><h3 id="1-作用：利用表达式进行插值，渲染到页面中"><a href="#1-作用：利用表达式进行插值，渲染到页面中" class="headerlink" title="1.作用：利用表达式进行插值，渲染到页面中"></a>1.作用：利用表达式进行插值，渲染到页面中</h3><p>表达式：是可以被求值的代码，JS引擎会讲其计算出一个结果</p><p>以下的情况都是表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">money + <span class="number">100</span></span><br><span class="line">money - <span class="number">100</span></span><br><span class="line">money * <span class="number">10</span></span><br><span class="line">money / <span class="number">10</span> </span><br><span class="line">price &gt;= <span class="number">100</span> ? <span class="string">&#x27;真贵&#x27;</span>:<span class="string">&#x27;还行&#x27;</span></span><br><span class="line">obj.<span class="property">name</span></span><br><span class="line">arr[<span class="number">0</span>]</span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line">obj.<span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h3><p>插值表达式语法：”{ 表达式 }”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;<span class="string">&quot;&#123;title&#125;&quot;</span>&lt;h3&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;&#123;nickName.toUpperCase()&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;&#123;age &gt;= 18 ? &#x27;成年&#x27;:&#x27;未成年&#x27;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;&#123;obj.name&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;&#123;fn()&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="3-错误用法"><a href="#3-错误用法" class="headerlink" title="3.错误用法"></a>3.错误用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在插值表达式中使用的数据 必须在data中进行了提供</span><br><span class="line">&lt;p&gt;<span class="string">&quot;&#123;hobby&#125;&quot;</span>&lt;<span class="regexp">/p&gt;  /</span>/如果在data中不存在 则会报错</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>支持的是表达式，而非语句，比如：<span class="keyword">if</span>   <span class="keyword">for</span> ...</span><br><span class="line">&lt;p&gt;<span class="string">&quot;&#123;if&#125;&quot;</span>&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>不能在标签属性中使用 <span class="string">&quot;&#123;  &#125;&quot;</span> 插值 (插值表达式只能标签中间使用)</span><br><span class="line">&lt;p title=<span class="string">&quot;&quot;</span>&#123;username&#125;<span class="string">&quot;&quot;</span>&gt;我是P标签&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>1.插值表达式的作用是什么</p><p>2.语法是什么</p><p>3.插值表达式的注意事项</p><h1 id="响应式特性"><a href="#响应式特性" class="headerlink" title="响应式特性"></a>响应式特性</h1><h3 id="1-什么是响应式？"><a href="#1-什么是响应式？" class="headerlink" title="1.什么是响应式？"></a>1.什么是响应式？</h3><p>​简单理解就是数据变，视图对应变。 </p><h3 id="2-如何访问-和-修改-data中的数据（响应式演示）"><a href="#2-如何访问-和-修改-data中的数据（响应式演示）" class="headerlink" title="2.如何访问 和 修改 data中的数据（响应式演示）"></a>2.如何访问 和 修改 data中的数据（响应式演示）</h3><p>data中的数据, 最终会被添加到实例上</p><p>① 访问数据： “实例.属性名”</p><p>② 修改数据： “实例.属性名”&#x3D; “值”</p><p><img src="/.com//1681888539340.png" alt="68188853934"></p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ol><li>什么是响应式</li><li>如何访问和修改data中的数据呢</li></ol><h2 id="Vue开发者工具安装"><a href="#Vue开发者工具安装" class="headerlink" title="Vue开发者工具安装"></a>Vue开发者工具安装</h2><ol><li>通过谷歌应用商店安装（国外网站）</li><li>极简插件下载（推荐） <a href="https://chrome.zzzmh.cn/index">https://chrome.zzzmh.cn/index</a></li></ol><p>安装步骤：</p><p><img src="/.com//1681889390406.png" alt="68188939040"></p><p>安装之后可以F12后看到多一个Vue的调试面板</p><p><img src="/.com//1681889483446.png" alt="68188948344"></p><h1 id="Vue中的常用指令"><a href="#Vue中的常用指令" class="headerlink" title="Vue中的常用指令"></a>Vue中的常用指令</h1><p><strong>概念：</strong>指令（Directives）是 Vue 提供的带有 <strong>v- 前缀</strong> 的 特殊 标签<strong>属性</strong>。</p><p>为啥要学：提高程序员操作 DOM 的效率。</p><p>vue 中的指令按照不同的用途可以分为如下 6 大类：</p><ul><li>内容渲染指令（v-html、v-text）</li><li>条件渲染指令（v-show、v-if、v-else、v-else-if）</li><li>事件绑定指令（v-on）</li><li>属性绑定指令 （v-bind）</li><li>双向绑定指令（v-model）</li><li>列表渲染指令（v-for）</li></ul><p>指令是 vue 开发中最基础、最常用、最简单的知识点。</p><h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><p>内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容。常用的内容渲染指令有如下2 个：</p><ul><li><p>v-text（类似innerText）</p></li><li><ul><li>使用语法：<code>&lt;p v-text=&quot;uname&quot;&gt;hello&lt;/p&gt;</code>，意思是将 uame 值渲染到 p 标签中</li><li>类似 innerText，使用该语法，会覆盖 p 标签原有内容</li></ul></li><li><p>v-html（类似 innerHTML）</p></li><li><ul><li>使用语法：<code>&lt;p v-html=&quot;intro&quot;&gt;hello&lt;/p&gt;</code>，意思是将 intro 值渲染到 p 标签中</li><li>类似 innerHTML，使用该语法，会覆盖 p 标签原有内容</li><li>类似 innerHTML，使用该语法，能够将HTML标签的样式呈现出来。</li></ul></li></ul><p>代码演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>个人信息<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 既然指令是vue提供的特殊的html属性，所以咱们写的时候就当成属性来用即可</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;uname&quot;</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">&quot;intro&quot;</span>&gt;</span>简介：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt; </span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">        const app = new Vue(&#123;</span><br><span class="line">            el:&#x27;#app&#x27;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                uname:&#x27;张三&#x27;,</span><br><span class="line">                intro:&#x27;&lt;h2&gt;这是一个&lt;strong&gt;非常优秀&lt;/strong&gt;的boy&lt;h2&gt;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="v-show、v-if"><a href="#v-show、v-if" class="headerlink" title="v-show、v-if"></a>v-show、v-if</h2><p>条件判断指令，用来辅助开发者按需控制 DOM 的显示与隐藏。条件渲染指令有如下两个，分别是：</p><ol><li><p>v-show</p><ol><li>作用：  控制元素显示隐藏</li><li>语法：  v-show &#x3D; “表达式”   表达式值为 true 显示， false 隐藏</li><li>原理：  切换 display:none 控制显示隐藏</li><li>场景：频繁切换显示隐藏的场景</li></ol><p><img src="/.com//1681891228284.png" alt="68189122828"></p></li><li><p>v-if</p><ol><li>作用：  控制元素显示隐藏（条件渲染）</li><li>语法：  v-if&#x3D; “表达式”          表达式值 true显示， false 隐藏</li><li>原理：  基于条件判断，是否创建 或 移除元素节点</li><li>场景：  要么显示，要么隐藏，不频繁切换的场景</li></ol><p><img src="/.com//1681891237750.png" alt="68189123775"></p><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>我是v-show控制的盒子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>我是v-if控制的盒子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">   </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">flag</span>: <span class="literal">false</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>v-else 和 v-else-if</p><ol><li>作用：辅助v-if进行判断渲染</li><li>语法：v-else  v-else-if&#x3D;”表达式”</li><li>需要紧接着v-if使用</li></ol></li></ol><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>性别：♂ 男<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>性别：♀ 女<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>成绩评定A：奖励电脑一台<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>成绩评定B：奖励周末郊游<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>成绩评定C：奖励零食礼包<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>成绩评定D：惩罚一周不能玩手机<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">gender</span>: <span class="number">2</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">score</span>: <span class="number">95</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>使用Vue时，如需为DOM注册事件，及其的简单，语法如下：</p><ul><li>&lt;button v-on:事件名&#x3D;”内联语句”&gt;按钮</li><li>&lt;button v-on:事件名&#x3D;”处理函数”&gt;按钮</li><li>&lt;button v-on:事件名&#x3D;”处理函数(实参)”&gt;按钮</li><li><code>v-on:</code> 简写为 <strong>@</strong></li></ul><ol><li><p>内联语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count--&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&quot;&#123; count &#125;&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">count</span>: <span class="number">100</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>事件处理函数</p><p>注意：</p><ul><li>事件处理函数应该写到一个跟data同级的配置项（methods）中</li><li>methods中的函数内部的this都指向Vue实例</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>切换显示隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>黑马程序员<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">isShow</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>  3.给事件处理函数传参</p><ul><li><p>如果不传递任何参数，则方法无需加小括号；methods方法中可以直接使用 e 当做事件对象</p></li><li><p>如果传递了参数，则实参 <code>$event</code> 表示事件对象，固定用法。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">   .<span class="property">box</span> &#123;</span><br><span class="line">     <span class="attr">border</span>: 3px solid #<span class="number">000000</span>;</span><br><span class="line">     border-<span class="attr">radius</span>: 10px;</span><br><span class="line">     <span class="attr">padding</span>: 20px;</span><br><span class="line">     <span class="attr">margin</span>: 20px;</span><br><span class="line">     <span class="attr">width</span>: 200px;</span><br><span class="line">   &#125;</span><br><span class="line">   h3 &#123;</span><br><span class="line">     <span class="attr">margin</span>: 10px <span class="number">0</span> 20px <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   p &#123;</span><br><span class="line">     <span class="attr">margin</span>: 20px;</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/style&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">h3</span>&gt;</span>小黑自动售货机<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">button</span>&gt;</span>可乐5元<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">button</span>&gt;</span>咖啡10元<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">button</span>&gt;</span>牛奶8元<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>银行卡余额：&quot;&#123; money &#125;&quot;元<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="attr">money</span>: <span class="number">100</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><ol><li><strong>作用：</strong>动态设置html的标签属性 比如：src、url、title</li><li><strong>语法</strong>：**v-bind:**属性名&#x3D;“表达式”</li><li>**v-bind:**可以简写成 &#x3D;&gt;   <strong>:</strong></li></ol><p>比如，有一个图片，它的 <code>src</code> 属性值，是一个图片地址。这个地址在数据 data 中存储。</p><p>则可以这样设置属性值：</p><ul><li><code>&lt;img v-bind:src=&quot;url&quot; /&gt;</code></li><li><code>&lt;img :src=&quot;url&quot; /&gt;</code>   （v-bind可以省略）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imgUrl&quot;</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgUrl&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">imgUrl</span>: <span class="string">&#x27;./imgs/10-02.png&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">msg</span>: <span class="string">&#x27;hello 波仔&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>Vue 提供了 v-for 列表渲染指令，用来辅助开发者基于一个数组来循环渲染一个列表结构。</p><p>v-for 指令需要使用 <code>(item, index) in arr</code> 形式的特殊语法，其中：</p><ul><li>item 是数组中的每一项</li><li>index 是每一项的索引，不需要可以省略</li><li>arr 是被遍历的数组</li></ul><p>此语法也可以遍历<strong>对象和数字</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历对象</span></span><br><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;(value, key, index) in object&quot;</span>&gt;<span class="string">&quot;&#123;value&#125;&quot;</span>&lt;/div&gt;</span><br><span class="line"><span class="attr">value</span>:对象中的值</span><br><span class="line"><span class="attr">key</span>:对象中的键</span><br><span class="line"><span class="attr">index</span>:遍历索引从<span class="number">0</span>开始</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数字</span></span><br><span class="line">&lt;p v-<span class="keyword">for</span>=<span class="string">&quot;item in 10&quot;</span>&gt;<span class="string">&quot;&#123;item&#125;&quot;</span>&lt;/p&gt;</span><br><span class="line">item从<span class="number">1</span> 开始</span><br></pre></td></tr></table></figure><h2 id="v-for中的key"><a href="#v-for中的key" class="headerlink" title="v-for中的key"></a>v-for中的key</h2><p><strong>语法：</strong> key&#x3D;”唯一值”</p><p><strong>作用：</strong>给列表项添加的<strong>唯一标识</strong>。便于Vue进行列表项的<strong>正确排序复用</strong>。</p><p><strong>为什么加key：</strong>Vue 的默认行为会尝试原地修改元素（<strong>就地复用</strong>）</p><p>实例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in booksList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&quot;&#123; item.name &#125;&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&quot;&#123; item.author &#125;&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;del(item.id)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>key 的值只能是字符串 或 数字类型</li><li>key 的值必须具有唯一性</li><li>推荐使用  id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应）</li></ol><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>所谓双向绑定就是：</p><ol><li>数据改变后，呈现的页面结果会更新</li><li>页面结果更新后，数据也会随之而变</li></ol><p><strong>作用：</strong> 给<strong>表单元素</strong>（input、radio、select）使用，双向绑定数据，可以快速 <strong>获取</strong> 或 <strong>设置</strong> 表单元素内容</p><p><strong>语法：</strong>v-model&#x3D;”变量”</p><p><strong>需求：</strong>使用双向绑定实现以下需求</p><ol><li>点击登录按钮获取表单中的内容</li><li>点击重置按钮清空表单中的内容</li></ol><p><img src="/.com//1681913125738.png" alt="68191312573"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    账户：&lt;input type=<span class="string">&quot;text&quot;</span>&gt; &lt;br&gt;&lt;br&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">&quot;password&quot;</span>&gt; &lt;br&gt;&lt;br&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="指令修饰符"><a href="#指令修饰符" class="headerlink" title="指令修饰符"></a>指令修饰符</h2><h3 id="1-什么是指令修饰符？"><a href="#1-什么是指令修饰符？" class="headerlink" title="1.什么是指令修饰符？"></a>1.什么是指令修饰符？</h3><p>​所谓指令修饰符就是通过“.”指明一些指令<strong>后缀</strong> 不同的<strong>后缀</strong>封装了不同的处理操作  —&gt; 简化代码</p><h3 id="2-按键修饰符"><a href="#2-按键修饰符" class="headerlink" title="2.按键修饰符"></a>2.按键修饰符</h3><ul><li>@keyup.enter  —&gt;当点击enter键的时候才触发</li></ul><p>代码演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>@keyup.enter  →  监听键盘回车事件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="3-v-model修饰符"><a href="#3-v-model修饰符" class="headerlink" title="3.v-model修饰符"></a>3.v-model修饰符</h3><ul><li>v-model.trim  —&gt;去除首位空格</li><li>v-model.number —&gt;转数字</li></ul><h3 id="4-事件修饰符"><a href="#4-事件修饰符" class="headerlink" title="4.事件修饰符"></a>4.事件修饰符</h3><ul><li>@事件名.stop —&gt; 阻止冒泡</li><li>@事件名.prevent  —&gt;阻止默认行为</li><li>@事件名.stop.prevent —&gt;可以连用 即阻止事件冒泡也阻止默认行为</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">   .<span class="property">father</span> &#123;</span><br><span class="line">     <span class="attr">width</span>: 200px;</span><br><span class="line">     <span class="attr">height</span>: 200px;</span><br><span class="line">     background-<span class="attr">color</span>: pink;</span><br><span class="line">     margin-<span class="attr">top</span>: 20px;</span><br><span class="line">   &#125;</span><br><span class="line">   .<span class="property">son</span> &#123;</span><br><span class="line">     <span class="attr">width</span>: 100px;</span><br><span class="line">     <span class="attr">height</span>: 100px;</span><br><span class="line">     background-<span class="attr">color</span>: skyblue;</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;h3&gt;v-model修饰符 .trim .number&lt;/h3&gt;</span><br><span class="line">   姓名：&lt;input v-model=&quot;username&quot; type=&quot;text&quot;&gt;&lt;br&gt;</span><br><span class="line">   年纪：&lt;input v-model=&quot;age&quot; type=&quot;text&quot;&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   &lt;h3&gt;@事件名.stop     →  阻止冒泡&lt;/h3&gt;</span><br><span class="line">   &lt;div @click=&quot;fatherFn&quot; class=&quot;father&quot;&gt;</span><br><span class="line">     &lt;div @click=&quot;sonFn&quot; class=&quot;son&quot;&gt;儿子&lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;h3&gt;@事件名.prevent  →  阻止默认行为&lt;/h3&gt;</span><br><span class="line">   &lt;a @click href=&quot;http://www.baidu.com&quot;&gt;阻止默认行为&lt;/a&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   const app = new Vue(&#123;</span><br><span class="line">     el: &#x27;#app&#x27;,</span><br><span class="line">     data: &#123;</span><br><span class="line">       username: &#x27;&#x27;,</span><br><span class="line">       age: &#x27;&#x27;,</span><br><span class="line">     &#125;,</span><br><span class="line">     methods: &#123;</span><br><span class="line">       fatherFn () &#123;</span><br><span class="line">         alert(&#x27;老父亲被点击了&#x27;)</span><br><span class="line">       &#125;,</span><br><span class="line">       sonFn (e) &#123;</span><br><span class="line">         // e.stopPropagation()</span><br><span class="line">         alert(&#x27;儿子被点击了&#x27;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="v-bind对样式控制的增强"><a href="#v-bind对样式控制的增强" class="headerlink" title="v-bind对样式控制的增强"></a>v-bind对样式控制的增强</h1><h2 id="v-bind对样式控制的增强-操作class"><a href="#v-bind对样式控制的增强-操作class" class="headerlink" title="v-bind对样式控制的增强-操作class"></a>v-bind对样式控制的增强-操作class</h2><p>为了方便开发者进行样式控制， Vue 扩展了 v-bind 的语法，可以针对 <strong>class 类名</strong> 和 <strong>style 行内样式</strong> 进行控制 。</p><h3 id="1-语法："><a href="#1-语法：" class="headerlink" title="1.语法："></a>1.语法：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> :class = &quot;对象/数组&quot;&gt;这是一个div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-对象语法"><a href="#2-对象语法" class="headerlink" title="2.对象语法"></a>2.对象语法</h3><p>当class动态绑定的是<strong>对象</strong>时，<strong>键就是类名，值就是布尔值</strong>，如果值是<strong>true</strong>，就有这个类，否则没有这个类</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; 类名1: 布尔值, 类名2: 布尔值 &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    适用场景：一个类名，来回切换</p><h3 id="3-数组语法"><a href="#3-数组语法" class="headerlink" title="3.数组语法"></a>3.数组语法</h3><p>当class动态绑定的是<strong>数组</strong>时 → 数组中所有的类，都会添加到盒子上，本质就是一个 class 列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;[ 类名1, 类名2, 类名3 ]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   使用场景:批量添加或删除类</p><h2 id="v-bind对有样式控制的增强-操作style"><a href="#v-bind对有样式控制的增强-操作style" class="headerlink" title="v-bind对有样式控制的增强-操作style"></a>v-bind对有样式控制的增强-操作style</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; CSS属性名1: CSS属性值, CSS属性名2: CSS属性值 &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-代码练习"><a href="#2-代码练习" class="headerlink" title="2.代码练习"></a>2.代码练习</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">187</span>, <span class="number">150</span>, <span class="number">156</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="v-model在其他表单元素的使用"><a href="#v-model在其他表单元素的使用" class="headerlink" title="v-model在其他表单元素的使用"></a>v-model在其他表单元素的使用</h1><h2 id="1-讲解内容："><a href="#1-讲解内容：" class="headerlink" title="1.讲解内容："></a>1.讲解内容：</h2><p>常见的表单元素都可以用 v-model 绑定关联  →  快速 <strong>获取</strong> 或 <strong>设置</strong> 表单元素的值</p><p>它会根据  <strong>控件类型</strong> 自动选取  <strong>正确的方法</strong> 来更新元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入框  <span class="attr">input</span>:text   ——&gt; value</span><br><span class="line">文本域  textarea ——&gt; value</span><br><span class="line">复选框  <span class="attr">input</span>:checkbox  ——&gt; checked</span><br><span class="line">单选框  <span class="attr">input</span>:radio   ——&gt; checked</span><br><span class="line">下拉菜单 select    ——&gt; value</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>基于<strong>现有的数据</strong>，计算出来的<strong>新属性</strong>。 <strong>依赖</strong>的数据变化，<strong>自动</strong>重新计算。</p><h2 id="2-语法-1"><a href="#2-语法-1" class="headerlink" title="2.语法"></a>2.语法</h2><ol><li>声明在 <strong>computed 配置项</strong>中，一个计算属性对应一个函数</li><li>使用起来和普通属性一样使用  “{ 计算属性名}”</li></ol><h2 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h2><ol><li>computed配置项和data配置项是<strong>同级</strong>的</li><li>computed中的计算属性<strong>虽然是函数的写法</strong>，但他<strong>依然是个属性</strong></li><li>computed中的计算属性<strong>不能</strong>和data中的属性<strong>同名</strong></li><li>使用computed中的计算属性和使用data中的属性是一样的用法</li><li>computed中计算属性内部的<strong>this</strong>依然<strong>指向的是Vue实例</strong></li></ol><h1 id="computed计算属性-VS-methods方法"><a href="#computed计算属性-VS-methods方法" class="headerlink" title="computed计算属性 VS methods方法"></a>computed计算属性 VS methods方法</h1><h2 id="1-computed计算属性"><a href="#1-computed计算属性" class="headerlink" title="1.computed计算属性"></a>1.computed计算属性</h2><p>作用：封装了一段对于<strong>数据</strong>的处理，求得一个<strong>结果</strong></p><p>语法：</p><ol><li>写在computed配置项中</li><li>作为属性，直接使用<ul><li>js中使用计算属性： this.计算属性</li><li>模板中使用计算属性：”{计算属性}”</li></ul></li></ol><h2 id="2-methods计算属性"><a href="#2-methods计算属性" class="headerlink" title="2.methods计算属性"></a>2.methods计算属性</h2><p>作用：给Vue实例提供一个<strong>方法</strong>，调用以<strong>处理业务逻辑</strong>。</p><p>语法：</p><ol><li>写在methods配置项中</li><li>作为方法调用<ul><li>js中调用：this.方法名()</li><li>模板中调用 “{方法名()}”  或者 @事件名&#x3D;“方法名”</li></ul></li></ol><h2 id="3-计算属性的优势"><a href="#3-计算属性的优势" class="headerlink" title="3.计算属性的优势"></a>3.计算属性的优势</h2><ol><li><p>缓存特性（提升性能）</p><p>计算属性会对计算出来的结果缓存，再次使用直接读取缓存，</p><p>依赖项变化了，会自动重新计算 → 并再次缓存</p></li><li><p>methods没有缓存特性</p></li><li><p>通过代码比较</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">table</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">th</span>,<span class="selector-tag">td</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h3</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">left</span>: <span class="number">145px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">top</span>: -<span class="number">4px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#e63f32</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>小黑的礼物清单🛒<span class="tag">&lt;<span class="name">span</span>&gt;</span>?<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>数量<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&quot;&#123; item.name &#125;&quot;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&quot;&#123; item.num &#125;&quot;个<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>礼物总数：&quot;&#123; totalCount &#125;&quot; 个<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 现有的数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">list</span>: [</span></span><br><span class="line"><span class="language-javascript">          &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;篮球&#x27;</span>, <span class="attr">num</span>: <span class="number">3</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">          &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;玩具&#x27;</span>, <span class="attr">num</span>: <span class="number">2</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">          &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;铅笔&#x27;</span>, <span class="attr">num</span>: <span class="number">5</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        ]</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        totalCount () &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">let</span> total = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, item</span>) =&gt;</span> sum + item.<span class="property">num</span>, <span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> total</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4.总结"></a>4.总结</h2><p>1.computed<strong>有缓存特性</strong>，methods<strong>没有缓存</strong></p><p>2.当一个结果依赖其他多个值时，推荐使用计算属性</p><p>3.当处理业务逻辑时，推荐使用methods方法，比如事件的处理函数</p><h1 id="计算属性的完整写法"><a href="#计算属性的完整写法" class="headerlink" title="计算属性的完整写法"></a>计算属性的完整写法</h1><p><strong>既然计算属性也是属性，能访问，应该也能修改了？</strong></p><ol><li>计算属性默认的简写，只能读取访问，不能 “修改”</li><li>如果要 “修改”  → 需要写计算属性的完整写法</li></ol><p><img src="/.com//1682041822963.png" alt="68204182296"></p><p>完整写法代码演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   姓：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span>&gt;</span> +</span><br><span class="line">   名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span> =</span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span>&gt;</span>改名卡<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">     <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">firstName</span>: <span class="string">&#x27;刘&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">lastName</span>: <span class="string">&#x27;备&#x27;</span></span></span><br><span class="line"><span class="language-javascript">     &#125;,</span></span><br><span class="line"><span class="language-javascript">     <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     &#125;,</span></span><br><span class="line"><span class="language-javascript">     <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     &#125;</span></span><br><span class="line"><span class="language-javascript">   &#125;)</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="watch侦听器（监视器）"><a href="#watch侦听器（监视器）" class="headerlink" title="watch侦听器（监视器）"></a>watch侦听器（监视器）</h1><h2 id="1-作用："><a href="#1-作用：" class="headerlink" title="1.作用："></a>1.作用：</h2><p>​<strong>监视数据变化</strong>，执行一些业务逻辑或异步操作</p><h2 id="2-语法："><a href="#2-语法：" class="headerlink" title="2.语法："></a>2.语法：</h2><ol><li><p>watch同样声明在跟data同级的配置项中</p></li><li><p>简单写法： 简单类型数据直接监视</p></li><li><p>完整写法：添加额外配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123; </span><br><span class="line">  <span class="attr">words</span>: <span class="string">&#x27;苹果&#x27;</span>,</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">words</span>: <span class="string">&#x27;苹果&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="comment">// 该方法会在数据变化时，触发执行</span></span><br><span class="line">  数据属性名 (newValue, oldValue) &#123;</span><br><span class="line">    一些业务逻辑 或 异步操作。 </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;对象.属性名&#x27;</span> (newValue, oldValue) &#123;</span><br><span class="line">    一些业务逻辑 或 异步操作。 </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-完整写法"><a href="#3-完整写法" class="headerlink" title="3.完整写法"></a>3.完整写法</h2><p>完整写法 —&gt;添加额外的配置项</p><ol><li>deep:true 对复杂类型进行深度监听</li><li>immdiate:true 初始化 立刻执行一次</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">words</span>: <span class="string">&#x27;苹果&#x27;</span>,</span><br><span class="line">    <span class="attr">lang</span>: <span class="string">&#x27;italy&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">watch</span>: &#123;<span class="comment">// watch 完整写法</span></span><br><span class="line">  对象: &#123;</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span>, <span class="comment">// 深度监视</span></span><br><span class="line">    <span class="attr">immdiate</span>:<span class="literal">true</span>,<span class="comment">//立即执行handler函数</span></span><br><span class="line">    handler (newValue) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-总结-2"><a href="#4-总结-2" class="headerlink" title="4.总结"></a>4.总结</h2><p>watch侦听器的写法有几种？</p><p>1.简单写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  数据属性名 (newValue, oldValue) &#123;</span><br><span class="line">    一些业务逻辑 或 异步操作。 </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;对象.属性名&#x27;</span> (newValue, oldValue) &#123;</span><br><span class="line">    一些业务逻辑 或 异步操作。 </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.完整写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;<span class="comment">// watch 完整写法</span></span><br><span class="line">  数据属性名: &#123;</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span>, <span class="comment">// 深度监视(针对复杂类型)</span></span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="comment">// 是否立刻执行一次handler</span></span><br><span class="line">    handler (newValue) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Vue声明周期和生命周期的四个阶段"><a href="#Vue声明周期和生命周期的四个阶段" class="headerlink" title="Vue声明周期和生命周期的四个阶段"></a>Vue声明周期和生命周期的四个阶段</h1><p>思考：什么时候可以发送<strong>初始化渲染请求</strong>？(越早越好)什么时候可以开始<strong>操作dom</strong>？(至少得dom渲染出来)</p><p>Vue声明周期：一个Vue实例从<strong>创建</strong>到<strong>销毁</strong>的过程</p><p>生命周期四个阶段：1.创建 2.挂载 3.更新 4.销毁</p><p><img src="/.com//image-20240418171447366.png" alt="image-20240418171447366"></p><h1 id="Vue声明周期函数（钩子函数）"><a href="#Vue声明周期函数（钩子函数）" class="headerlink" title="Vue声明周期函数（钩子函数）"></a>Vue声明周期函数（钩子函数）</h1><p>Vue生命周期过程，会自动运行一些函数，被称为【生命周期钩子】→让开发者 在【特定阶段】运行自己的代码</p><p><img src="/.com//image-20240418171711663.png" alt="image-20240418171711663"></p><p><img src="/.com//image-20240418171649423.png" alt="image-20240418171649423"></p><p>created：发送初始化渲染请求</p><p>mounted：操作dom</p><p>before destory：释放Vue以外的资源（清除定时器，延时器….）</p><h1 id="工程化开发-脚手架Vue-CLI"><a href="#工程化开发-脚手架Vue-CLI" class="headerlink" title="工程化开发 &amp; 脚手架Vue CLI"></a>工程化开发 &amp; 脚手架Vue CLI</h1><h2 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a><strong>基本介绍：</strong></h2><p>Vue CLI 是Vue官方提供的一个全局命令工具</p><p>可以帮助我们快速创建一个开发Vue项目的标准化基础架子，【集成了webspack配置】</p><p><strong>好处：</strong></p><p>1.开箱即用，零配置</p><p>2.内置babel</p><p>3.标准化</p><h2 id="运行流程："><a href="#运行流程：" class="headerlink" title="运行流程："></a>运行流程：</h2><p><img src="/.com//image-20240419091402170.png" alt="image-20240419091402170"></p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><ul><li>页面可以拆分成一个个组件，每个组件有着独立的结构、行为、样式</li><li>好处：便于维护，利用复用 → 提升开发效率</li><li>组件分类：普通组件、根组件</li></ul><h2 id="根组件"><a href="#根组件" class="headerlink" title="根组件"></a>根组件</h2><p>整个应用最上层的组件、包裹所有普通小组件</p><p>一个组件App.vue 包含的三个部分：</p><ul><li>template：结构（有且只能有一个根元素）</li><li>script：js逻辑</li><li>style：样式（可支持less，需要装包）</li></ul><h2 id="普通组件的注册使用"><a href="#普通组件的注册使用" class="headerlink" title="普通组件的注册使用"></a>普通组件的注册使用</h2><h3 id="组件注册的两种方式："><a href="#组件注册的两种方式：" class="headerlink" title="组件注册的两种方式："></a>组件注册的两种方式：</h3><ol><li>局部注册：只能在注册的组件中使用<ol><li>创建.vue文件<ul><li><img src="/.com//image-20240419100716370.png" alt="image-20240419100716370"></li></ul></li><li>在使用的组件内导入并注册（在App.vue中完成）<ul><li><img src="/.com//image-20240419100739919.png" alt="image-20240419100739919"></li></ul></li><li>调用<ul><li><img src="/.com//image-20240419100800332.png" alt="image-20240419100800332"></li></ul></li></ol></li><li>全局注册：所有组件都能使用<ol><li>在main.js中导入<ul><li><img src="/.com//image-20240419100548570.png" alt="image-20240419100548570"></li></ul></li><li>在main.js进行全局注册<ul><li><img src="/.com//image-20240419100607199.png" alt="image-20240419100607199"></li></ul></li><li>去需要用到组件的vue中进行使用即可<ul><li><img src="/.com//image-20240419100645668.png" alt="image-20240419100645668"></li></ul></li></ol></li></ol><h1 id="Scoped"><a href="#Scoped" class="headerlink" title="Scoped"></a>Scoped</h1><p><strong>默认情况</strong>：写在组件中的样式会 <strong>全局生效</strong> → 因此很容易造成多个组件之间的样式冲突问题</p><ul><li><strong>全局样式</strong>：默认组件中的样式会作用到全局</li><li><strong>局部样式</strong>：可以给组件加上<strong>scoped</strong>属性，<strong>可以让样式只作用于当前组件</strong></li></ul><p><strong>原理：</strong></p><ol><li>当前组件内标签都被添加 <code>data-v-hash值</code> 的属性<ul><li><img src="/.com//image-20240419120757751.png" alt="image-20240419120757751"></li></ul></li><li>css 选择器都被添加 [data-v-hash值] 的属性选择器<ul><li><img src="/.com//image-20240419120808041.png" alt="image-20240419120808041"></li></ul></li></ol><p><strong>最终效果：</strong>必须是当前组件的元素，才会有这个自定义属性，才会被这个样式作用到</p><h1 id="data函数"><a href="#data函数" class="headerlink" title="data函数"></a>data函数</h1><p>组件中的data是一个函数，并非之前的data对象 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">count: 100</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="两种组件关系分类-和-对应的组件通信方案"><a href="#两种组件关系分类-和-对应的组件通信方案" class="headerlink" title="两种组件关系分类 和 对应的组件通信方案"></a>两种组件关系分类 和 对应的组件通信方案</h1><p>父子关系 ——→**props **&amp; <strong>$emit</strong></p><p>非父子关系——→<strong>provide</strong> &amp; <strong>inject</strong> 或 <strong>eventbus</strong></p><p>通用方案——→<strong>vuex</strong></p><h2 id="父子通信方案的核心流程"><a href="#父子通信方案的核心流程" class="headerlink" title="父子通信方案的核心流程"></a>父子通信方案的核心流程</h2><h3 id="父-→-子-props"><a href="#父-→-子-props" class="headerlink" title="父 → 子 props"></a>父 → 子 props</h3><ul><li>父中给子添加属性传值</li><li>子props接收</li><li>使用</li></ul><p><img src="/.com//image-20240419131754371.png" alt="image-20240419131754371"></p><h3 id="子-→-父-emit"><a href="#子-→-父-emit" class="headerlink" title="子 → 父 $emit"></a>子 → 父 $emit</h3><ul><li>子$emit发送消息</li><li>父中给子添加消息监听</li><li>父中实现处理函数</li></ul><p><img src="/.com//image-20240419131827371.png" alt="image-20240419131827371"></p><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><h3 id="Prop定义"><a href="#Prop定义" class="headerlink" title="Prop定义"></a>Prop定义</h3><p>组件上注册一些自定义属性</p><h3 id="Prop作用"><a href="#Prop作用" class="headerlink" title="Prop作用"></a>Prop作用</h3><p>向子组件传递数据</p><p>特点：</p><ul><li>​可以 传递 任意<strong>数量</strong> 的prop</li><li>​    可以 传递 任意<strong>类型</strong> 的prop</li></ul><p><img src="/.com//image-20240419134855205.png" alt="image-20240419134855205"></p><h3 id="prop校验"><a href="#prop校验" class="headerlink" title="prop校验"></a>prop校验</h3><p><strong>思考</strong>：组件的prop 可以乱穿么？  不可以</p><p><strong>作用</strong>：为组件的prop指定验证要求，不符合要求，控制台就会有错误提示 → 帮助开发者，快速发现错误</p><p><strong>语法</strong>：</p><ul><li>类型校验</li><li>非空校验</li><li>默认值</li><li>自定义校验</li></ul><p><img src="/.com//image-20240419135923055.png" alt="image-20240419135923055"><br><img src="/.com//image-20240419140715188.png" alt="image-20240419140715188"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">w: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">props: &#123;</span><br><span class="line">w: &#123;</span><br><span class="line">type: 类型,</span><br><span class="line">required: true,  // 是否必填</span><br><span class="line">default:默认值,  //默认值</span><br><span class="line">validator(value) &#123;</span><br><span class="line">if(逻辑判断) &#123;</span><br><span class="line">// 自定义校验逻辑</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prop-data、单向数据流"><a href="#prop-data、单向数据流" class="headerlink" title="prop &amp; data、单向数据流"></a>prop &amp; data、单向数据流</h3><p>共同点：都可以给组件提供数据</p><p>区别：</p><ul><li>data 的数据是自己的 → 随便改</li><li>prop 的数据是外部的 → 不能随便改， 要遵循单向数据流</li></ul><p>单项数据流：父级prop的数据更新，会向下流动，影响子组件。这个数据流动是单项的</p><p><img src="/.com//image-20240419141355768.png" alt="image-20240419141355768"></p><h2 id="非父子通信（拓展）-event-bus-事件总线"><a href="#非父子通信（拓展）-event-bus-事件总线" class="headerlink" title="非父子通信（拓展）-event bus 事件总线"></a>非父子通信（拓展）-event bus 事件总线</h2><p><img src="/.com//image-20240419154933160.png" alt="image-20240419154933160"></p><p><strong>作用</strong>：非父子组件之间，进行简易消息传递。（复杂场景 → Vuex）</p><ol><li>创建一个都能访问到的事件总线（空Vue实例） → utils&#x2F;EventBus.js<ul><li><img src="/.com//image-20240419154832119.png" alt="image-20240419154832119"></li></ul></li><li>A组件（接收方），监听Bus实例的事件<ul><li><img src="/.com//image-20240419154858841.png" alt="image-20240419154858841"></li></ul></li><li>B组件（发送方），触发Bus实例的事件<ul><li><img src="/.com//image-20240419154924207.png" alt="image-20240419154924207"></li></ul></li></ol><p><strong>实现</strong></p><p>组件A：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;base-a&quot;&gt;</span><br><span class="line">    我是A组件（接受方）</span><br><span class="line">    &lt;p&gt;&quot;&#123;msg&#125;&quot;&lt;/p&gt;  </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Bus from &#x27;../utils/EventBus&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    Bus.$on(&#x27;sendMsg&#x27;, (msg) =&gt; &#123;</span><br><span class="line">      this.msg = msg</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>组件B：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;base-b&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是B组件（发布方）&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMsgFn&quot;&gt;发送消息&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Bus from &#x27;../utils/EventBus&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendMsgFn() &#123;</span><br><span class="line">      Bus.$emit(&#x27;sendMsg&#x27;, &#x27;今天天气不错，适合旅游&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="非父子通信-provide-inject"><a href="#非父子通信-provide-inject" class="headerlink" title="非父子通信-provide &amp; inject"></a>非父子通信-<strong>provide</strong> &amp; <strong>inject</strong></h2><p><strong>provide &amp; inject的作用：</strong>跨层级共享数据</p><p><strong>父组件： provide 提供数据</strong></p><p><img src="/.com//image-20240420094110639.png" alt="image-20240420094110639"></p><p>响应式：当修改数据时 页面会做出响应</p><p>非响应式：当修改数据时，页面不会做出响应</p><p><strong>子&#x2F;孙组件： inject 取值使用</strong></p><p><img src="/.com//image-20240420094226560.png" alt="image-20240420094226560"></p><h1 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h1><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>v-model本质上是一个语法糖。例如应用在输入框上，就是value属性 和 input事件 的合写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot; &gt;</span><br><span class="line">    &lt;input v-model=&quot;msg&quot; type=&quot;text&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input :value=&quot;msg&quot; @input=&quot;msg = $event.target.value&quot; type=&quot;text&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>提供数据的双向绑定</p><ul><li>数据变，视图跟着变：value</li><li>视图变，数据跟着变：@input</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>$event</strong> 用于在模板中，获取事件的形参</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot;  /&gt;</span><br><span class="line">    &lt;br /&gt; </span><br><span class="line">    &lt;input type=&quot;text&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg1: &#x27;&#x27;,</span><br><span class="line">      msg2: &#x27;&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="v-model使用在其他表单元素上的原理"><a href="#v-model使用在其他表单元素上的原理" class="headerlink" title="v-model使用在其他表单元素上的原理"></a>v-model使用在其他表单元素上的原理</h3><p>不同的表单元素， v-model在底层的处理机制是不一样的。比如给checkbox使用v-model</p><p>底层处理的是 checked属性和change事件。</p><p><strong>不过咱们只需要掌握应用在文本框上的原理即可</strong></p><h1 id="表单类组件封装-v-model-简化代码"><a href="#表单类组件封装-v-model-简化代码" class="headerlink" title="表单类组件封装 &amp; v-model 简化代码"></a>表单类组件封装 &amp; <strong>v-model</strong> 简化代码</h1><h2 id="1-表单类组件封装"><a href="#1-表单类组件封装" class="headerlink" title="1.表单类组件封装"></a><strong>1.表单类组件封装</strong></h2><ul><li>父传子：数据 应该时父组件<strong>props</strong>传递 过来的， v-model拆解绑定数据</li><li>子传父：监听输入，子传父传值给父组件修改</li></ul><p><img src="/.com//image-20240420101931245.png" alt="image-20240420101931245"></p><p><img src="/.com//image-20240420101937810.png" alt="image-20240420101937810"></p><h2 id="2-v-model简化代码"><a href="#2-v-model简化代码" class="headerlink" title="2.v-model简化代码"></a><strong>2.v-model简化代码</strong></h2><p>其实就是凑value和input这两个变量名</p><ul><li>子组件中：props 通过 value 接收，事件触发 input</li><li>父组件中：v-model 给组件直接绑定数据（:value + @input）</li></ul><p><img src="/.com//image-20240420103350723.png" alt="image-20240420103350723"></p><h1 id="sycn修饰符"><a href="#sycn修饰符" class="headerlink" title=".sycn修饰符"></a>.sycn修饰符</h1><p>作用：可以实现 <strong>子组件</strong> 与 **父组件数据 ** 的 <strong>双向绑定</strong>，简化代码</p><p>特点：prop属性名，可以<strong>自定义</strong>，非固定为 <strong>value</strong></p><p>场景：封装弹框类的基础组件，<strong>visible 属性</strong>，true显示 false隐藏</p><p>本质：就是 <code>:属性名</code> 和 <code>@update:属性名</code> 合写</p><p><img src="/.com//image-20240420110430553.png" alt="image-20240420110430553"></p><p><img src="/.com//image-20240420110554179.png" alt="image-20240420110554179"></p><h1 id="ref-和-refs"><a href="#ref-和-refs" class="headerlink" title="ref 和 $refs"></a>ref 和 $refs</h1><p><strong>作用：</strong>利用ref 和 $refs 可以用于<strong>获取 dom 元素</strong> 或<strong>组件实例</strong></p><p><strong>特点：</strong>查找范围 → 当前组件内（更精确稳定）</p><ul><li>获取dom<ul><li>目标标签 - 添加ref属性<ul><li><img src="/.com//image-20240420113017419.png" alt="image-20240420113017419"></li></ul></li><li>恰当时机，通过<code>this.$refs.xxx</code>，获取目标标签<ul><li><img src="/.com//image-20240420113105006.png" alt="image-20240420113105006"></li></ul></li></ul></li></ul><p><strong>案例1：</strong></p><p>​<img src="/.com//image-20240420113439198.png" alt="image-20240420113439198"></p><p><img src="/.com//image-20240420113612685.png" alt="image-20240420113612685"></p><p><strong>案例2：</strong></p><p>App.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h4&gt;父组件 -- &lt;button&gt;获取组件实例&lt;/button&gt;&lt;/h4&gt;</span><br><span class="line">    &lt;BaseForm ref=&quot;BaseForm&quot;&gt;&lt;/BaseForm&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button @click=&quot;handleGet&quot;&gt;获取数据&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;handleReset&quot;&gt;重置数据&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import BaseForm from &#x27;./components/BaseForm.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    BaseForm,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleGet () &#123;</span><br><span class="line">      console.log(this.$refs.BaseForm.getValues())</span><br><span class="line">    &#125;,</span><br><span class="line">    handleReset () &#123;</span><br><span class="line">      this.$refs.BaseForm.resetValues()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>BaseForm.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      账号: &lt;input v-model=&quot;username&quot; type=&quot;text&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">      密码: &lt;input v-model=&quot;password&quot; type=&quot;text&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      username: &#x27;&#x27;,</span><br><span class="line">      password: &#x27;&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getValues() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        username: this.username,</span><br><span class="line">        password: this.password</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    resetValues() &#123;</span><br><span class="line">      this.username = &#x27;&#x27;</span><br><span class="line">      this.password = &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p>获取输入框里面的值</p><p><img src="/.com//image-20240420113737083.png" alt="image-20240420113737083"></p><h1 id="Vue异步更新-nextTick"><a href="#Vue异步更新-nextTick" class="headerlink" title="Vue异步更新 &amp; $nextTick"></a>Vue异步更新 &amp; $nextTick</h1><h2 id="Vue是异步更新DOM的"><a href="#Vue是异步更新DOM的" class="headerlink" title="Vue是异步更新DOM的"></a><strong>Vue是异步更新DOM的</strong></h2><p>Vue.js是一种用于构建用户界面的渐进式 JavaScript 框架。其中一个非常重要的特性是异步更新。异步更新是指当数据发生变化时，Vue不会立即更新DOM。相反，它会在下一个“tick”或渲染循环中异步执行DOM更新。这种机制可以提高性能，减少不必要的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们直接修改 Vue 实例的数据时，Vue 会在内部将数据更新操作放入一个异步队列中，而不是立即进行更新。</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 当点击编辑按钮时，输入框显示 并且自动获取焦点</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 编辑状态 --&gt;</span><br><span class="line">    &lt;div v-if=&quot;isShowEdit&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;editValue&quot; ref=&quot;inp&quot; /&gt;</span><br><span class="line">      &lt;button&gt;确认&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 默认状态 --&gt;</span><br><span class="line">    &lt;div v-else&gt;</span><br><span class="line">      &lt;span&gt;&quot;&#123; title &#125;&quot;&lt;/span&gt;</span><br><span class="line">      &lt;button @click=&quot;handleAppearance&quot;&gt;编辑&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &#x27;大标题&#x27;,</span><br><span class="line">      isShowEdit: false,</span><br><span class="line">      editValue: &#x27;&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mehods: &#123;</span><br><span class="line">    handleAppearance() &#123;</span><br><span class="line">      // 显示输入框 (Vue异步更新的)</span><br><span class="line">      this.isShowEdit = true</span><br><span class="line">        // this.$refs.inp.focus()  直接这么写 是不能获取焦点的 因为Vue是异步更新的，而$nextTick 可以实现同步更新</span><br><span class="line">      // 获取焦点 ($nextTick 等dom渲染完毕后 立即执行)</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.$refs.inp.focus()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h2><p>$nextTick：等DOM更新后，才会触发执行此方法里的函数体</p><p>语法：this.$nextTick(函数体)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">someDataProperty = newValue; // 异步更新</span><br><span class="line"></span><br><span class="line">this.$nextTick(() =&gt; &#123;</span><br><span class="line">  // 在更新操作完成后执行回调函数</span><br><span class="line">  // 可以获取最新的数据状态</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于那些依赖于 Vue 更新的 DOM 操作，我们需要使用 `$nextTick` 方法来确保在DOM更新完成后执行操作。</span><br></pre></td></tr></table></figure><h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自己定义的指令：可以定义的一些指令，可以封装一些 dom 操作，扩展额外功能</p><ul><li><p>在需要绑定的标签上写上自定义的指令</p><ul><li><img src="/.com//image-20240421102351808.png" alt="image-20240421102351808"></li></ul></li><li><p>全局注册 - 语法</p><ul><li>在main.js中注册<ul><li><img src="/.com//image-20240421102218477.png" alt="image-20240421102218477"></li></ul></li></ul></li><li><p>局部注册 - 语法</p><ul><li>在app.vue中注册<ul><li><img src="/.com//image-20240421102316638.png" alt="image-20240421102316638"></li></ul></li></ul></li></ul><h2 id="自定义指令-指令的值"><a href="#自定义指令-指令的值" class="headerlink" title="自定义指令 - 指令的值"></a>自定义指令 - 指令的值</h2><p>需求：实现一个color指令 - 传入不同的颜色，给标签设置文字颜色</p><ul><li>语法：在绑定指令时，可以通过 “等号” 的形式 为指令绑定 具体的参数值 <code>v-指令名= &quot;指令值&quot;</code><ul><li><img src="/.com//image-20240421104209131.png" alt="image-20240421104209131"></li></ul></li><li>而后通过  <code>binding.value</code> 可以拿到指令值，指令值修改会触发update函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：inserted函数 是当元素添加到页面中时才会触发，如果已经添加到页面中，再去修改属性值 是不会触发的 这个时候 要用到一个update函数</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240421104436281.png" alt="image-20240421104436281"></p><h2 id="自定义指令-封装v-loading指令"><a href="#自定义指令-封装v-loading指令" class="headerlink" title="自定义指令 - 封装v-loading指令"></a>自定义指令 - 封装v-loading指令</h2><p>效果：当我们去请求数据时，页面可能会空白一段时间，我们想要在空白的这段时间内 让他显示加载的动画</p><ul><li><p>实现步骤</p><ul><li><p><img src="/.com//image-20240421111012155.png" alt="image-20240421111012155"></p></li><li><p><img src="/.com//image-20240421111145791.png" alt="image-20240421111145791"></p></li></ul></li></ul><h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><h2 id="插槽-默认插槽"><a href="#插槽-默认插槽" class="headerlink" title="插槽 - 默认插槽"></a>插槽 - 默认插槽</h2><p><strong>作用</strong>：让组件内部的一些 <strong>结构</strong> 支持 <strong>自定义</strong></p><p><strong>场景</strong>：当组内某一部分结构不确定，想要自定义时。</p><p><strong>需求</strong>：要在页面中显示一个对话框，封装成一个组件</p><p><strong>问题</strong>：组件的内部部分，<strong>不希望写死</strong>，希望能使用的时候<strong>自定义</strong>。怎么办？</p><p><img src="/.com//image-20240421115110618.png" alt="image-20240421115110618"></p><p>插槽基本语法：</p><ol><li>组件内需要定制的结构部分，改用<slot></slot>占位</li><li>使用组件时，<MyDialog></MyDialog>标签内部，传入结构替代slot</li></ol><p>案例：</p><p><img src="/.com//image-20240421115716517.png" alt="image-20240421115716517"></p><p><img src="/.com//image-20240421115722869.png" alt="image-20240421115722869"></p><p><img src="/.com//image-20240421115726763.png" alt="image-20240421115726763"></p><h2 id="插槽-后备插槽"><a href="#插槽-后备插槽" class="headerlink" title="插槽 - 后备插槽"></a>插槽 - 后备插槽</h2><p>插槽后备内容：封装组件时，可以为预留的 <code>&lt;slot&gt;</code> 插槽提供<strong>后备内容</strong>（默认内容）</p><ul><li>语法：在<slot> 标签内，放置内容，作为默认显示内容</slot></li><li>效果：<ul><li>外部使用组件时，步传东西，则slot会显示后备内容<ul><li><MyDialog></MyDialog></li></ul></li><li>外部使用组件时，传东西了，则slot整体会被换掉<ul><li><MyDialog>我是内容</MyDialog></li></ul></li></ul></li></ul><p><img src="/.com//image-20240421120721410.png" alt="image-20240421120721410"></p><h2 id="插槽-具名插槽"><a href="#插槽-具名插槽" class="headerlink" title="插槽 - 具名插槽"></a>插槽 - 具名插槽</h2><p><strong>组件内 有多处不确定的结构 怎么办？</strong></p><p><strong>具名插槽</strong></p><ul><li>slot占位，给name属性起名字来区分</li><li>template配合 <strong>v-slot:插槽名</strong> 分发内容v-slot:插槽名 可以简化成什么？<ul><li><strong>#插槽名</strong></li></ul></li></ul><p><img src="/.com//image-20240421122052310.png" alt="image-20240421122052310"></p><h2 id="插槽-作用域插槽"><a href="#插槽-作用域插槽" class="headerlink" title="插槽 - 作用域插槽"></a>插槽 - 作用域插槽</h2><p>作用域插槽：定义slot插槽的同时，是可以传值的。给插槽上可以绑定数据，将来 使用组件时可以使用</p><p>场景：封装表格组件</p><ol><li>子传父，动态渲染表格内容</li><li>利用默认插槽，定制操作列</li><li>删除或查看都需要用到<strong>当前项的id</strong>，属于<strong>组件内部的数据</strong>通过<strong>作用域插槽</strong>传值绑定，进而使用</li></ol><p><img src="/.com//image-20240421160300672.png" alt="image-20240421160300672"></p><p><img src="/.com//image-20240421160240117.png" alt="image-20240421160240117"></p><p><strong>作用域插槽的作用</strong>：可以给插槽上绑定数据，供将来使用组件时使用</p><p><strong>作用域插槽使用步骤？</strong></p><ul><li>给slot标签，以添加属性的方式传值<ul><li><img src="/.com//image-20240421160527128.png" alt="image-20240421160527128"></li></ul></li><li>所有属性都会被收集到一个对象中<ul><li><img src="/.com//image-20240421160535688.png" alt="image-20240421160535688"></li></ul></li><li>template中，通过 <code>#插槽名= &quot;obj&quot;</code> 接收<ul><li><img src="/.com//image-20240421160545873.png" alt="image-20240421160545873"></li></ul></li></ul><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是路由？"><a href="#什么是路由？" class="headerlink" title="什么是路由？"></a>什么是路由？</h3><p>路由是一种映射关系</p><h3 id="Vue中的路由是什么？"><a href="#Vue中的路由是什么？" class="headerlink" title="Vue中的路由是什么？"></a>Vue中的路由是什么？</h3><p><strong>路径和组件的映射关系</strong></p><p>根据路由就能知道不同路径的，应该匹配渲染哪个组件</p><h2 id="VueRouter的使用（5-2）"><a href="#VueRouter的使用（5-2）" class="headerlink" title="VueRouter的使用（5+2）"></a>VueRouter的使用（5+2）</h2><ul><li>5个基础步骤（固定）<ol><li>下载：下载VueRouter模块到工程中<ul><li>vue2 → vueRouter3 → Vuex3               vue4 → vueRouter4 → Vuex4</li><li><img src="/.com//image-20240422111024686.png" alt="image-20240422111024686"></li></ul></li><li>引入<ul><li><img src="/.com//image-20240422111041771.png" alt="image-20240422111041771"></li></ul></li><li>安装注册<ul><li><img src="/.com//image-20240422111058438.png" alt="image-20240422111058438"></li></ul></li><li>创建路由对象<ul><li><img src="/.com//image-20240422111110375.png" alt="image-20240422111110375"></li></ul></li><li>注入，将路由对象注入到new Vue实例中，建立关联<ul><li><img src="/.com//image-20240422111133017.png" alt="image-20240422111133017"></li></ul></li></ol></li><li>2个核心步骤<ol><li>创建需要的组件(放在views目录下)，配置路由规则<ul><li><strong>Find.vue  My.vue Friend.vue</strong></li><li><img src="/.com//image-20240422112132161.png" alt="image-20240422112132161"></li></ul></li><li>配置导航，配置路由出口（路径匹配的组件显示的位置）<ul><li><img src="/.com//image-20240422112213300.png" alt="image-20240422112213300"></li></ul></li></ol></li></ul><h2 id="Vue组件的分类"><a href="#Vue组件的分类" class="headerlink" title="Vue组件的分类"></a>Vue组件的分类</h2><ol><li>组件分类有哪几类？ 分类的目的是什么？<ul><li>页面组件 和 分类组件      便于维护</li></ul></li><li>放在什么文件夹？作用分别是什么？<ul><li>页面组件 - <strong>views</strong>文件夹 &#x3D;&gt; 配合路由，页面展示</li><li>复用组件 - <strong>components</strong>文件夹 &#x3D;&gt; 封装复用</li></ul></li></ol><h2 id="路由的封装抽离"><a href="#路由的封装抽离" class="headerlink" title="路由的封装抽离"></a>路由的封装抽离</h2><p>问题：所有的路由配置都堆在main.js中合适么？</p><p>目标：将路由模块抽离出来。好处：<strong>拆分模块，利于维护</strong></p><ol><li>创建router&#x2F;index.js文件<ul><li>将main.js中路由的配置 剪贴到index.js</li><li><img src="/.com//image-20240422143533462.png" alt="image-20240422143533462"></li></ul></li><li>在main.js中引入router<ul><li><img src="/.com//image-20240422143436011.png" alt="image-20240422143436011"></li></ul></li></ol><h2 id="声明式导航-导航链接"><a href="#声明式导航-导航链接" class="headerlink" title="声明式导航 - 导航链接"></a>声明式导航 - 导航链接</h2><p>需求：实现导航高亮效果</p><p>Vue-router 提供了一个全局组件 router-link （取代a标签）</p><ul><li><strong>能跳转</strong>，配置 to 属性执行路径（<strong>必须</strong>）。本质还是 a 标签， <strong>to无需 #</strong></li><li><strong>能高亮</strong>，默认就会提供<strong>高亮类名</strong>，可以直接设置高亮样式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link&gt;</span><br><span class="line">   &lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link&gt;</span><br><span class="line">   &lt;router-link to=&quot;/friend&quot;&gt;朋友&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>声明式导航 - 两个类名</p><p>说明：我们发现 router-link 自动给当前导航添加了<strong>两个高亮类名</strong></p><ul><li><code>router-link-active</code> 模糊匹配(用的多)<ul><li>to&#x3D;”&#x2F;my” 可以匹配 &#x2F;my    &#x2F;my&#x2F;a    &#x2F;my&#x2F;b    ….</li></ul></li><li><code>router-link-exact-active</code> 精确匹配<ul><li>to&#x3D;”&#x2F;my”   尽可以匹配   &#x2F;my</li></ul></li></ul><p><strong>如何自定义router-link 的两个高亮类名？</strong></p><ul><li><code>linkActiveClass</code> 模糊匹配 类名自定义</li><li><code>linkExactActiveClass</code> 精确匹配 类名自定义</li></ul><h2 id="声明式导航-跳转传参"><a href="#声明式导航-跳转传参" class="headerlink" title="声明式导航 - 跳转传参"></a>声明式导航 - 跳转传参</h2><ul><li><strong>查询参数查询（多个参数）</strong><ul><li>路由<ul><li><img src="/.com//image-20240422155413600.png" alt="image-20240422155413600"></li></ul></li><li>跳转：<code>to=&quot;/path?参数名=值&quot;</code><ul><li><img src="/.com//image-20240422155050008.png" alt="image-20240422155050008"></li></ul></li><li>接收：<code>$route.query.参数名</code><ul><li><img src="/.com//image-20240422155142353.png" alt="image-20240422155142353"></li></ul></li></ul></li><li><strong>动态参数查询（简洁优雅）</strong><ul><li>路由：<code>/path/:参数名</code><ul><li><img src="/.com//image-20240422155244854.png" alt="image-20240422155244854"></li></ul></li><li>跳转：<code>to=&quot;/path/值&quot;</code><ul><li><img src="/.com//image-20240422155200504.png" alt="image-20240422155200504"></li></ul></li><li>接收：<code>$route.params.参数名</code><ul><li><img src="/.com//image-20240422155210918.png" alt="image-20240422155210918"></li></ul></li></ul></li></ul><p><strong>动态参数查询有一个问题：</strong>当我们不通过传参的方式访问搜索页  而是直接访问搜索页时，会发现 没有任何页面</p><p><img src="/.com//image-20240422155930937.png" alt="image-20240422155930937"></p><p>原因：<code>/search/:words</code> 表示，必须要传参数。如果不传参数，也希望匹配，可以加一个可选符 “?”</p><p><img src="/.com//image-20240422160108022.png" alt="image-20240422160108022"></p><p><img src="/.com//image-20240422160120338.png" alt="image-20240422160120338"></p><h2 id="Vue路由-重定向"><a href="#Vue路由-重定向" class="headerlink" title="Vue路由 - 重定向"></a>Vue路由 - 重定向</h2><p>问题：网页打开，url默认是 &#x2F; 路径，未匹配到组件时，会出现空白</p><p>说明：重定向 → 匹配path后，强制跳转path路径</p><p>语法：{path: 匹配路径, redirect: 重定向到的路径}</p><p><img src="/.com//image-20240422160707625.png" alt="image-20240422160707625"></p><p><img src="/.com//image-20240422160647127.png" alt="image-20240422160647127"></p><h2 id="Vue路由-404"><a href="#Vue路由-404" class="headerlink" title="Vue路由-404"></a>Vue路由-404</h2><p>作用：当路径找不到匹配时，给个提示页面</p><p>位置：配在路由最后</p><p>语法：<code>path: &quot;*&quot;</code> （任意路径） - 前面不匹配就命中最后这个</p><p><img src="/.com//image-20240422162333727.png" alt="image-20240422162333727"></p><h2 id="Vue路由-模式设置"><a href="#Vue路由-模式设置" class="headerlink" title="Vue路由 - 模式设置"></a>Vue路由 - 模式设置</h2><p>问题：路由的路径看起来不自然，有#，能都切成真正路径形式？</p><ul><li>hash路由(默认)例如：<a href="http://localhost:8080/#/home">http://localhost:8080/#/home</a></li><li>history路由(常用)例如：<a href="http://localhost:8080/home">http://localhost:8080/home</a>(以后上线需要服务器端支持)</li></ul><p><img src="/.com//image-20240422162624077.png" alt="image-20240422162624077"></p><h2 id="Vue路由-基本跳转"><a href="#Vue路由-基本跳转" class="headerlink" title="Vue路由 - 基本跳转"></a>Vue路由 - 基本跳转</h2><p>问题：点击按钮跳转如何实现</p><p>两种语法：</p><ul><li><code>path 路径跳转(简单方便)</code>    注意这里是 <code>$router</code> 不是 <code>$route</code><ul><li><img src="/.com//image-20240423153004901.png" alt="image-20240423153004901"></li></ul></li><li><code>name 命名路由跳转(适合path超长的场景)</code> <ul><li><img src="/.com//image-20240423153406895.png" alt="image-20240423153406895"></li><li><img src="/.com//image-20240423153152450.png" alt="image-20240423153152450"></li></ul></li></ul><h2 id="Vue路由-两种跳转方式传参"><a href="#Vue路由-两种跳转方式传参" class="headerlink" title="Vue路由 - 两种跳转方式传参"></a>Vue路由 - 两种跳转方式传参</h2><ul><li><code>path 路径跳转带参数</code><ul><li>简写方式<ul><li><img src="/.com//image-20240423160230082.png" alt="image-20240423160230082"></li><li><img src="/.com//image-20240423160238246.png" alt="image-20240423160238246"></li></ul></li><li>完整写法（适合传参时，使用）<ul><li><img src="/.com//image-20240423160435212.png" alt="image-20240423160435212"></li><li><img src="/.com//image-20240423160442688.png" alt="image-20240423160442688"></li></ul></li><li><code>name 命名路径跳转带参数</code><ul><li><img src="/.com//image-20240423161131934.png" alt="image-20240423161131934"></li><li>对应的如果是params 则是 <code>$route.query.参数名</code></li><li>对应的如果是query 则是 <code>$route.params.参数名</code>   注意：这里的参数名是配置动态路径参数时写的<code>:参数名</code></li></ul></li></ul></li></ul><p>总结：</p><ul><li>​<img src="/.com//image-20240423161645115.png" alt="image-20240423161645115"></li><li><img src="/.com//image-20240423161703948.png" alt="image-20240423161703948"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">路径短用path 路径长用name</span><br></pre></td></tr></table></figure><h2 id="Vue路由-子路由（嵌套路由）"><a href="#Vue路由-子路由（嵌套路由）" class="headerlink" title="Vue路由 - 子路由（嵌套路由）"></a>Vue路由 - 子路由（嵌套路由）</h2><ul><li>在children属性中，配置属性<ul><li><img src="/.com//image-20240423195103501.png" alt="image-20240423195103501"></li></ul></li><li>配置路由出口<ul><li><img src="/.com//image-20240423194955155.png" alt="image-20240423194955155"></li></ul></li></ul><h2 id="面经项目"><a href="#面经项目" class="headerlink" title="面经项目"></a>面经项目</h2><p>参考D:&#x2F;vscode&#x2F;Vue&#x2F;vue-mianJ-projiect文件</p><p><img src="/.com//image-20240423162529145.png" alt="image-20240423162529145"></p><h2 id="组件缓存"><a href="#组件缓存" class="headerlink" title="组件缓存"></a>组件缓存</h2><p>当我通过路由跳转到其他页面时，这个页面会被销毁，再次返回的时候会被重新加载 这个时候可以用一个数据缓存</p><ul><li>keep-alive 是什么？<ul><li>Vue的内置组件，包裹动态组件时，可以缓存</li></ul></li><li>keep-alive的优点<ul><li>组件切换过程中，把切换出去的组件保留在内存中（提升性能）</li></ul></li><li>keep-alive的三个属性（了解）<ul><li><strong>include：组件名数组，只有匹配的组件会被缓存</strong></li><li>exclude：组件名数组，任何匹配的组件都不会被缓存</li><li>max：最多可以缓存多少组件实例</li></ul></li><li>keep-alive的使用会触发两个生命周期函数（了解） 当组件被缓存时，created，mounted函数就不会执行了<ul><li>activated 当组件被激活（使用）的时候触发 → 进入页面触发</li><li>deactivated 当组件不被使用的时候触发 → 离开页面触发</li></ul></li></ul><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>目标：明确vuex 是什么？应用场景，优势</p><ol><li><p>是什么？</p><ul><li>vuex 是一个vue的<strong>状态管理工具</strong> （状态就是数据）</li><li>大白话：vuex是一个插件，可以帮我们管理 vue 通用的数据 （多组间共享的数据）</li></ul></li><li><p>场景：</p><ul><li>某个状态在 很多个组件 来使用（个人信息）</li><li>多个组件共同维护一份数据（购物车）</li></ul></li><li><p>优势</p><ul><li>共同维护一份数据，数据集中化管理</li><li>响应式变化</li><li>操作简洁（vuex提供了一些辅助函数）</li></ul></li></ol><h2 id="vuex-的使用-创建仓库"><a href="#vuex-的使用-创建仓库" class="headerlink" title="vuex 的使用 - 创建仓库"></a>vuex 的使用 - 创建仓库</h2><p><img src="/.com//1683212784179.png" alt="68321278417"></p><h3 id="1-安装-vuex"><a href="#1-安装-vuex" class="headerlink" title="1.安装 vuex"></a>1.安装 vuex</h3><p>安装vuex与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vuex@3 或者 npm i vuex@3</span><br></pre></td></tr></table></figure><h3 id="2-新建-store-index-js-专门存放-vuex"><a href="#2-新建-store-index-js-专门存放-vuex" class="headerlink" title="2.新建 store/index.js 专门存放 vuex"></a>2.新建 <code>store/index.js</code> 专门存放 vuex</h3><p>​为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 <code>router/index.js</code> 类似)</p><p>​<img src="/.com//1683212805824.png" alt="68321280582"></p><h3 id="3-创建仓库-store-index-js"><a href="#3-创建仓库-store-index-js" class="headerlink" title="3.创建仓库 store/index.js"></a>3.创建仓库 <code>store/index.js</code></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 vue</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入 vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建仓库 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出仓库</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h3 id="4-在-main-js-中导入挂载到-Vue-实例上"><a href="#4-在-main-js-中导入挂载到-Vue-实例上" class="headerlink" title="4 在 main.js 中导入挂载到 Vue 实例上"></a>4 在 main.js 中导入挂载到 Vue 实例上</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">  store</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此刻起, 就成功创建了一个 <strong>空仓库!!</strong></p><h3 id="5-测试打印Vuex"><a href="#5-测试打印Vuex" class="headerlink" title="5.测试打印Vuex"></a>5.测试打印Vuex</h3><p>App.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$store</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心概念-state状态"><a href="#核心概念-state状态" class="headerlink" title="核心概念 - state状态"></a>核心概念 - state状态</h2><p>目标：明确如何给仓库 <strong>提供</strong> 数据，如何 使用 仓库的数据</p><p><img src="/.com//image-20240424145605209.png" alt="image-20240424145605209"></p><p>使用数据：</p><ul><li>通过store直接访问<ul><li>模板中：”{ $store.state.xxx }”</li><li>组件逻辑中：this.$store.state.xxx</li><li>JS模块中：store.state.xxx</li></ul></li><li>通过辅助函数（简化）<ul><li>导入mapState<ul><li><img src="/.com//image-20240424150816193.png" alt="image-20240424150816193"></li></ul></li><li>封装到computed属性中<ul><li><img src="/.com//image-20240424150832149.png" alt="image-20240424150832149"></li></ul></li><li>直接调用属性名<ul><li><img src="/.com//image-20240424150906678.png" alt="image-20240424150906678"></li></ul></li></ul></li></ul><h2 id="核心概念-mutations"><a href="#核心概念-mutations" class="headerlink" title="核心概念 - mutations"></a>核心概念 - mutations</h2><p>vuex同样<strong>遵循单行数据流</strong>，组件中不能直接修改仓库的数据</p><p>掌握mutations对象，对象中存放修改state的方法</p><ul><li>定义mutations对象，对象中存放修改state的方法<ul><li><img src="/.com//image-20240424152950268.png" alt="image-20240424152950268"></li></ul></li><li>组件中提交调用mutations<ul><li><img src="/.com//image-20240424153031490.png" alt="image-20240424153031490"></li></ul></li></ul><h3 id="mutation传参"><a href="#mutation传参" class="headerlink" title="mutation传参"></a>mutation传参</h3><p>目标：掌握mutations传参语法</p><p>提交mutation是可以传递参数的 <code>this.$store.commit(&#39;xxx&#39;, 参数)</code></p><ul><li>提供mutation 函数 (带参数 - 提交载荷 payload)<ul><li><img src="/.com//image-20240424155414155.png" alt="image-20240424155414155"></li></ul></li><li>页面中提交调用 mutation<ul><li><img src="/.com//image-20240424155446162.png" alt="image-20240424155446162"></li></ul></li></ul><p>注意：</p><ul><li>所有mutation函数，第一个参数，都是state</li><li>mutation参数有且只有一个，state除外，如果需要多个参数，包装成一个对象<ul><li><img src="/.com//image-20240424155638070.png" alt="image-20240424155638070"></li><li><img src="/.com//image-20240424155652632.png" alt="image-20240424155652632"></li></ul></li></ul><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><p>目标：实时输入，实施更新</p><p><img src="/.com//image-20240424162014664.png" alt="image-20240424162014664"></p><p><img src="/.com//image-20240424162019320.png" alt="image-20240424162019320"></p><ul><li>输入框内容渲染<ul><li><img src="/.com//image-20240424162131956.png" alt="image-20240424162131956"></li></ul></li><li>监听输入获取内容<ul><li><img src="/.com//image-20240424162347473.png" alt="image-20240424162347473"></li></ul></li><li>封装mutation处理函数<ul><li><img src="/.com//image-20240424162230980.png" alt="image-20240424162230980"></li></ul></li><li>调用传参<ul><li><img src="/.com//image-20240424162354835.png" alt="image-20240424162354835"></li></ul></li></ul><h2 id="辅助函数：mapMutations"><a href="#辅助函数：mapMutations" class="headerlink" title="辅助函数：mapMutations"></a>辅助函数：mapMutations</h2><p>mapMutations 和 mapState 很像，它是把位于mutations中的方法提取了出来，映射到组件methods中</p><ul><li>在mutation创建方法<ul><li><img src="/.com//image-20240424165023840.png" alt="image-20240424165023840"></li></ul></li><li>导入mapMutation的包 在需要用到的组件中   只需要写左边<ul><li><img src="/.com//image-20240424165445012.png" alt="image-20240424165445012"></li><li><img src="/.com//image-20240424165110169.png" alt="image-20240424165110169"></li></ul></li><li>直接调用<ul><li><img src="/.com//image-20240425132514363.png" alt="image-20240425132514363"></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2024/05/05/Spring/"/>
      <url>/2024/05/05/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring相关概念"><a href="#Spring相关概念" class="headerlink" title="Spring相关概念"></a>Spring相关概念</h2><h3 id="初识Spring"><a href="#初识Spring" class="headerlink" title="初识Spring"></a>初识Spring</h3><p>在这一节，主要通过以下两个点来了解下Spring:</p><h4 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h4><ul><li><p>官网：<a href="https://spring.io，从官网我们可以大概了解到：">https://spring.io，从官网我们可以大概了解到：</a></p><ul><li>Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。</li><li>Spring并不是单一的一个技术，而是一个大家族，可以从官网的<code>Projects</code>中查看其包含的所有技术。</li></ul></li><li><p>Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。</p><ul><li><p>Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。</p></li><li><p>Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫&#x3D;&#x3D;全家桶&#x3D;&#x3D;，如下图所示</p><p><img src="/.com//image-20210729171850181-1719409838881-1.png" alt="image-20210729171850181"></p><p><strong>说明:</strong></p><p>图中的图标都代表什么含义，可以进入<code>https://spring.io/projects</code>网站进行对比查看。</p><p>这些技术并不是所有的都需要学习，额外需要重点关注<code>Spring Framework</code>、<code>SpringBoot</code>和<code>SpringCloud</code>:</p><p><img src="/.com//1629714811435-1719409838881-2.png" alt="1629714811435"></p><ul><li>Spring Framework:Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li><li>SpringBoot:Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li><li>SpringCloud:这个是用来做分布式之微服务架构的相关开发。</li></ul><p>除了上面的这三个技术外，还有很多其他的技术，也比较流行，如SpringData,SpringSecurity等，这些都可以被应用在我们的项目中。我们今天所学习的Spring其实指的是&#x3D;&#x3D;Spring Framework&#x3D;&#x3D;。</p></li></ul></li></ul><h4 id="了解Spring发展史"><a href="#了解Spring发展史" class="headerlink" title="了解Spring发展史"></a>了解Spring发展史</h4><p> 接下来我们介绍下Spring Framework这个技术是如何来的呢?</p><p><img src="/.com//image-20210729171926576-1719409838881-3.png" alt="image-20210729171926576"></p><p>Spring发展史</p><ul><li>IBM(IT公司-国际商业机器公司)在1997年提出了EJB思想,早期的JAVAEE开发大都基于该思想。</li><li>Rod Johnson(Java和J2EE开发领域的专家)在2002年出版的<code>Expert One-on-One J2EE Design and Development</code>,书中有阐述在开发中使用EJB该如何做。</li><li>Rod Johnson在2004年出版的<code>Expert One-on-One J2EE Development without EJB</code>,书中提出了比EJB思想更高效的实现方案，并且在同年将方案进行了具体的落地实现，这个实现就是Spring1.0。</li><li>随着时间推移，版本不断更新维护，目前最新的是Spring5<ul><li>Spring1.0是纯配置文件开发</li><li>Spring2.0为了简化开发引入了注解开发，此时是配置文件加注解的开发方式</li><li>Spring3.0已经可以进行纯注解开发，使开发效率大幅提升，我们的课程会以注解开发为主</li><li>Spring4.0根据JDK的版本升级对个别API进行了调整</li><li>Spring5.0已经全面支持JDK8，现在Spring最新的是5系列所以建议大家把JDK安装成1.8版</li></ul></li></ul><p>本节介绍了Spring家族与Spring的发展史，需要大家重点掌握的是:</p><ul><li>今天所学的Spring其实是Spring家族中的Spring Framework</li><li>Spring Framework是Spring家族中其他框架的底层基础，学好Spring可以为其他Spring框架的学习打好基础</li></ul><h3 id="Spring系统架构"><a href="#Spring系统架构" class="headerlink" title="Spring系统架构"></a>Spring系统架构</h3><p>前面我们说spring指的是Spring Framework,那么它其中都包含哪些内容以及我们该如何学习这个框架?</p><p>针对这些问题，我们将从<code>系统架构图</code>和<code>课程学习路线</code>来进行说明:</p><h4 id="系统架构图"><a href="#系统架构图" class="headerlink" title="系统架构图"></a>系统架构图</h4><ul><li><p>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。</p></li><li><p>Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整</p><p><img src="/.com//image-20210729172153796-1719409838881-4.png" alt="image-20210729172153796"></p></li><li><p>Spring Framework的5版本目前没有最新的架构图，而最新的是4版本，所以接下来主要研究的是4的架构图</p><p><img src="/.com//1629720945720-1719409838882-5.png" alt="1629720945720"></p><p>(1)核心层</p><ul><li>Core Container:核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li></ul><p>(2)AOP层</p><ul><li>AOP:面向切面编程，它依赖核心层容器，目的是&#x3D;&#x3D;在不改变原有代码的前提下对其进行功能增强&#x3D;&#x3D;</li><li>Aspects:AOP是思想,Aspects是对AOP思想的具体实现</li></ul><p>(3)数据层</p><ul><li>Data Access:数据访问，Spring全家桶中有对数据访问的具体实现技术</li><li>Data Integration:数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li><li>Transactions:事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li></ul><p>(4)Web层</p><ul><li>这一层的内容将在SpringMVC框架具体学习</li></ul><p>(5)Test层</p><ul><li>Spring主要整合了Junit来完成单元测试和集成测试</li></ul></li></ul><h4 id="课程学习路线"><a href="#课程学习路线" class="headerlink" title="课程学习路线"></a>课程学习路线</h4><p>介绍完Spring的体系结构后，从中我们可以得出对于Spring的学习主要包含四部分内容，分别是:</p><ul><li>&#x3D;&#x3D;Spring的IOC&#x2F;DI&#x3D;&#x3D;</li><li>&#x3D;&#x3D;Spring的AOP&#x3D;&#x3D;</li><li>&#x3D;&#x3D;AOP的具体应用,事务管理&#x3D;&#x3D;</li><li>&#x3D;&#x3D;IOC&#x2F;DI的具体应用,整合Mybatis&#x3D;&#x3D;</li></ul><p><img src="/.com//1629722300996-1719409838882-6.png" alt="1629722300996"></p><p>对于这节的内容，大家重点要记住的是Spring需要学习的四部分内容。接下来就从第一部分开始学起。</p><h3 id="Spring核心概念"><a href="#Spring核心概念" class="headerlink" title="Spring核心概念"></a>Spring核心概念</h3><p>在Spring核心概念这部分内容中主要包含<code>IOC/DI</code>、<code>IOC容器</code>和<code>Bean</code>,那么问题就来了，这些都是什么呢?</p><h4 id="目前项目中的问题"><a href="#目前项目中的问题" class="headerlink" title="目前项目中的问题"></a>目前项目中的问题</h4><p>要想解答这个问题，就需要先分析下目前咱们代码在编写过程中遇到的问题:</p><p><img src="/.com//1629723232339-1719409838882-7.png" alt="1629723232339"></p><p>(1)业务层需要调用数据层的方法，就需要在业务层new数据层的对象</p><p>(2)如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署</p><p>(3)所以，现在代码在编写的过程中存在的问题是：&#x3D;&#x3D;耦合度偏高&#x3D;&#x3D;</p><p>针对这个问题，该如何解决呢?</p><p><img src="/.com//1629724206002-1719409838882-8.png" alt="1629724206002"></p><p>我们就想，如果能把框中的内容给去掉，不就可以降低依赖了么，但是又会引入新的问题，去掉以后程序能运行么?</p><p>答案肯定是不行，因为bookDao没有赋值为Null，强行运行就会出空指针异常。</p><p>所以现在的问题就是，业务层不想new对象，运行的时候又需要这个对象，该咋办呢?</p><p>针对这个问题，Spring就提出了一个解决方案:</p><ul><li>使用对象时，在程序中不要主动使用new产生对象，转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象</li></ul><p>这种实现思就是Spring的一个核心概念</p><h4 id="IOC、IOC容器、Bean、DI"><a href="#IOC、IOC容器、Bean、DI" class="headerlink" title="IOC、IOC容器、Bean、DI"></a>IOC、IOC容器、Bean、DI</h4><ol><li>&#x3D;&#x3D;IOC（Inversion of Control）控制反转&#x3D;&#x3D;</li></ol><p>(1)什么是控制反转呢？</p><ul><li>使用对象时，由主动new产生对象转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。<ul><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，交给<code>别人[外部]</code>来创建对象</li><li><code>别人[外部]</code>就反转控制了数据层对象的创建权</li><li>这种思想就是控制反转</li><li>别人[外部]指定是什么呢?继续往下学</li></ul></li></ul><p>(2)Spring和IOC之间的关系是什么呢?</p><ul><li>Spring技术对IOC思想进行了实现</li><li>Spring提供了一个容器，称为&#x3D;&#x3D;IOC容器&#x3D;&#x3D;，用来充当IOC思想中的”外部”</li><li>IOC思想中的<code>别人[外部]</code>指的就是Spring的IOC容器</li></ul><p>(3)IOC容器的作用以及内部存放的是什么?</p><ul><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li><li>被创建或被管理的对象在IOC容器中统称为&#x3D;&#x3D;Bean&#x3D;&#x3D;</li><li>IOC容器中放的就是一个个的Bean对象</li></ul><p>(4)当IOC容器中创建好service和dao对象后，程序能正确执行么?</p><ul><li>不行，因为service运行需要依赖dao对象</li><li>IOC容器中虽然有service和dao对象</li><li>但是service对象和dao对象没有任何关系</li><li>需要把dao对象交给service,也就是说要绑定service和dao对象之间的关系</li></ul><p>像这种在容器中建立对象与对象之间的绑定关系就要用到DI:</p><ol start="2"><li>&#x3D;&#x3D;DI（Dependency Injection）依赖注入&#x3D;&#x3D;</li></ol><p><img src="/.com//1629735078619-1719409838882-9.png" alt="1629735078619"></p><p>(1)什么是依赖注入呢?</p><ul><li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入<ul><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，靠<code>别人[外部其实指的就是IOC容器]</code>来给注入进来</li><li>这种思想就是依赖注入</li></ul></li></ul><p>(2)IOC容器中哪些bean之间要建立依赖关系呢?</p><ul><li>这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系</li></ul><p>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:&#x3D;&#x3D;充分解耦&#x3D;&#x3D;，具体实现靠:</p><ul><li>使用IOC容器管理bean（IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li><li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li></ul><h4 id="核心概念小结"><a href="#核心概念小结" class="headerlink" title="核心概念小结"></a>核心概念小结</h4><p>这节比较重要，重点要理解<code>什么是IOC/DI思想</code>、<code>什么是IOC容器</code>和<code>什么是Bean</code>：</p><p>(1)什么IOC&#x2F;DI思想?</p><ul><li>IOC:控制反转，控制反转的是对象的创建权</li><li>DI:依赖注入，绑定对象与对象之间的依赖关系</li></ul><p>(2)什么是IOC容器?</p><p>Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器</p><p>(3)什么是Bean?</p><p>容器中所存放的一个个对象就叫Bean或Bean对象</p><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>介绍完Spring的核心概念后，接下来我们得思考一个问题就是，Spring到底是如何来实现IOC和DI的，那接下来就通过一些简单的入门案例，来演示下具体实现过程:</p><h3 id="IOC入门案例"><a href="#IOC入门案例" class="headerlink" title="IOC入门案例"></a>IOC入门案例</h3><p>对于入门案例，我们得先<code>分析思路</code>然后再<code>代码实现</code>，</p><h4 id="入门案例思路分析"><a href="#入门案例思路分析" class="headerlink" title="入门案例思路分析"></a>入门案例思路分析</h4><p>(1)Spring是使用容器来管理bean对象的，那么管什么? </p><ul><li>主要管理项目中所使用到的类对象，比如(Service和Dao)</li></ul><p>(2)如何将被管理的对象告知IOC容器?</p><ul><li>使用配置文件</li></ul><p>(3)被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?</p><ul><li>Spring框架提供相应的接口</li></ul><p>(4)IOC容器得到后，如何从容器中获取bean?</p><ul><li>调用Spring框架提供对应接口中的方法</li></ul><p>(5)使用Spring导入哪些坐标?</p><ul><li>用别人的东西，就需要在pom.xml添加对应的依赖</li></ul><h4 id="入门案例代码实现"><a href="#入门案例代码实现" class="headerlink" title="入门案例代码实现"></a>入门案例代码实现</h4><blockquote><p>需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。</p><p>1.创建Maven的java项目</p><p>2.pom.xml添加Spring的依赖jar包</p><p>3.创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p><p>4.resources下添加spring配置文件，并完成bean的配置</p><p>5.使用Spring提供的接口完成IOC容器的创建</p><p>6.从容器中获取对象进行方法调用</p></blockquote><p><strong>步骤1:创建Maven项目</strong></p><p><img src="/.com//1629734010072-1719409838882-10.png" alt="1629734010072"></p><p><strong>步骤2:添加Spring的依赖jar包</strong></p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤3:添加案例中需要的类</strong></p><p>创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookDaoImpl</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4:添加spring配置文件</strong></p><p>resources下添加spring配置文件applicationContext.xml，并完成bean的配置</p><p><img src="/.com//../../../Typora%E7%AC%94%E8%AE%B0/Spring/1629734336440.png" alt="1629734336440"></p><p><strong>步骤5:在配置文件中完成bean的配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;注意事项：bean定义时id属性在同一个上下文中(配置文件)不能重复&#x3D;&#x3D;</strong></p><p><strong>步骤6:获取IOC容器</strong></p><p>使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤7:从容器中获取对象进行方法调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line"><span class="comment">//        BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span></span><br><span class="line"><span class="comment">//        bookDao.save();</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤8:运行程序</strong></p><p>测试结果为：</p><p><img src="/.com//image-20210729184337603-1719409838882-13.png" alt="image-20210729184337603"></p><p>Spring的IOC入门案例已经完成，但是在<code>BookServiceImpl</code>的类中依然存在<code>BookDaoImpl</code>对象的new操作，它们之间的耦合度还是比较高，这块该如何解决，就需要用到下面的<code>DI:依赖注入</code>。</p><h3 id="DI入门案例"><a href="#DI入门案例" class="headerlink" title="DI入门案例"></a>DI入门案例</h3><p>对于DI的入门案例，我们依然先<code>分析思路</code>然后再<code>代码实现</code>，</p><h4 id="入门案例思路分析-1"><a href="#入门案例思路分析-1" class="headerlink" title="入门案例思路分析"></a>入门案例思路分析</h4><p>(1)要想实现依赖注入，必须要基于IOC管理Bean</p><ul><li>DI的入门案例要依赖于前面IOC的入门案例</li></ul><p>(2)Service中使用new形式创建的Dao对象是否保留?</p><ul><li>需要删除掉，最终要使用IOC容器中的bean对象</li></ul><p>(3)Service中需要的Dao对象如何进入到Service中?</p><ul><li>在Service中提供方法，让Spring的IOC容器可以通过该方法传入bean对象</li></ul><p>(4)Service与Dao间的关系如何描述?</p><ul><li>使用配置文件</li></ul><h4 id="入门案例代码实现-1"><a href="#入门案例代码实现-1" class="headerlink" title="入门案例代码实现"></a>入门案例代码实现</h4><blockquote><p>需求:基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入</p><p>1.删除业务层中使用new的方式创建的dao对象</p><p>2.在业务层提供BookDao的setter方法</p><p>3.在配置文件中添加依赖注入的配置</p><p>4.运行程序调用方法</p></blockquote><p><strong>步骤1: 去除代码中的new</strong></p><p>在BookServiceImpl类中，删除业务层中使用new的方式创建的dao对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:为属性提供setter方法</strong></p><p>在BookServiceImpl类中,为BookDao提供setter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供对应的set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>步骤3:修改配置完成注入</strong></p><p>在配置文件中添加依赖注入的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置server与dao的关系--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">        name属性表示配置哪一个具体的属性</span></span><br><span class="line"><span class="comment">        ref属性表示参照哪一个bean</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:配置中的两个bookDao的含义是不一样的&#x3D;&#x3D;</p><ul><li>name&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的<code>setBookDao()</code>方法进行对象注入</li><li>ref&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring能在IOC容器中找到id为<code>bookDao</code>的Bean对象给<code>bookService</code>进行注入</li><li>综上所述，对应关系如下:</li></ul><p><img src="/.com//1629736314989-1719409838882-12.png" alt="1629736314989"></p><p><strong>步骤4:运行程序</strong></p><p>运行，测试结果为：</p><p><img src="/.com//image-20210729184337603-1719409838882-13.png" alt="image-20210729184337603"></p><h2 id="IOC相关内容"><a href="#IOC相关内容" class="headerlink" title="IOC相关内容"></a>IOC相关内容</h2><p>通过前面两个案例，我们已经学习了<code>bean如何定义配置</code>，<code>DI如何定义配置</code>以及<code>容器对象如何获取</code>的内容，接下来主要是把这三块内容展开进行详细的讲解，深入的学习下这三部分的内容，首先是bean基础配置。</p><h3 id="bean基础配置"><a href="#bean基础配置" class="headerlink" title="bean基础配置"></a>bean基础配置</h3><p>对于bean的配置中，主要会讲解<code>bean基础配置</code>,<code>bean的别名配置</code>,<code>bean的作用范围配置</code>&#x3D;&#x3D;(重点)&#x3D;&#x3D;,这三部分内容：</p><h4 id="bean基础配置-id与class"><a href="#bean基础配置-id与class" class="headerlink" title="bean基础配置(id与class)"></a>bean基础配置(id与class)</h4><p>对于bean的基础配置，在前面的案例中已经使用过:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><p>其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下</p><p><img src="/.com//image-20210729183500978-1719409838882-15.png" alt="image-20210729183500978"></p><p>这其中需要大家重点掌握的是:&#x3D;&#x3D;bean标签的id和class属性的使用&#x3D;&#x3D;。</p><p><strong>思考：</strong></p><ul><li>class属性能不能写接口如<code>BookDao</code>的类全名呢?</li></ul><p>答案肯定是不行，因为接口是没办法创建对象的。</p><ul><li>前面提过为bean设置id时，id必须唯一，但是如果由于命名习惯而产生了分歧后，该如何解决?</li></ul><p>在解决这个问题之前，我们需要准备下开发环境，对于开发环境我们可以有两种解决方案:</p><ul><li><p>使用前面IOC和DI的案例</p></li><li><p>重新搭建一个新的案例环境,目的是方便大家查阅代码</p><ul><li><p>搭建的内容和前面的案例是一样的，内容如下：</p><p><img src="/.com//1629769227068-1719409838882-14.png" alt="1629769227068"></p></li></ul></li></ul><h4 id="bean的name属性"><a href="#bean的name属性" class="headerlink" title="bean的name属性"></a>bean的name属性</h4><p>环境准备好后，接下来就可以在这个环境的基础上来学习下bean的别名配置，</p><p>首先来看下别名的配置说明:</p><p><img src="/.com//image-20210729183558051-1719409838882-16.png" alt="image-20210729183558051"></p><p><strong>步骤1：配置别名</strong></p><p>打开spring的配置文件applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service service4 bookEbi&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明:Ebi全称Enterprise Business Interface，翻译为企业业务接口</strong></p><p><strong>步骤2:根据名称容器中获取bean对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForName</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//此处根据bean标签的id属性和name属性的任意一个值来获取bean对象</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;service4&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:运行程序</strong></p><p>测试结果为：</p><p><img src="/.com//image-20210729184337603-1719409838882-13.png" alt="image-20210729184337603"></p><p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p><ul><li><p>bean依赖注入的ref属性指定bean，必须在容器中存在</p><p><img src="/.com//1629771744003-1719409838882-18.png" alt="1629771744003"></p></li><li><p>如果不存在,则会报错，如下:</p><p><img src="/.com//1629771880920-1719409838882-17.png" alt="1629771880920"></p><p>这个错误大家需要特别关注下:</p><p><img src="/.com//1629771972886-1719409838882-19.png" alt="1629771972886"></p><p>获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常&#x3D;&#x3D;NoSuchBeanDefinitionException&#x3D;&#x3D;</p></li></ul><h4 id="bean作用范围scope配置"><a href="#bean作用范围scope配置" class="headerlink" title="bean作用范围scope配置"></a>bean作用范围scope配置</h4><p>关于bean的作用范围是bean属性配置的一个&#x3D;&#x3D;重点&#x3D;&#x3D;内容。</p><p>看到这个作用范围，我们就得思考bean的作用范围是来控制bean哪块内容的?</p><p>我们先来看下<code>bean作用范围的配置属性</code>:</p><p><img src="/.com//image-20210729183628138-1719409838882-20.png" alt="image-20210729183628138"></p><h5 id="验证IOC容器中对象是否为单例"><a href="#验证IOC容器中对象是否为单例" class="headerlink" title="验证IOC容器中对象是否为单例"></a>验证IOC容器中对象是否为单例</h5><h6 id="验证思路"><a href="#验证思路" class="headerlink" title="验证思路"></a>验证思路</h6><p>​同一个bean获取两次，将对象打印到控制台，看打印出的地址值是否一致。</p><h6 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h6><ul><li><p>创建一个AppForScope的类，在其main方法中来验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打印，观察控制台的打印结果</p><p><img src="/.com//1629772538893-1719409838882-21.png" alt="1629772538893"></p></li><li><p>结论:默认情况下，Spring创建的bean对象都是单例的</p></li></ul><p>获取到结论后，问题就来了，那如果我想创建出来非单例的bean对象，该如何实现呢?</p><h5 id="配置bean为非单例"><a href="#配置bean为非单例" class="headerlink" title="配置bean为非单例"></a>配置bean为非单例</h5><p>在Spring配置文件中，配置scope属性来实现bean的非单例创建</p><ul><li><p>在Spring的配置文件中，修改<code>&lt;bean&gt;</code>的scope属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将scope设置为<code>singleton</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>运行AppForScope，打印看结果</p><p><img src="/.com//1629772538893-1719409838882-21.png" alt="1629772538893"></p></li><li><p>将scope设置为<code>prototype</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; name=&quot;dao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;prototype&quot;/&gt;</span><br></pre></td></tr></table></figure><p>运行AppForScope，打印看结果</p><p><img src="/.com//1629772928714-1719409838882-22.png" alt="1629772928714"></p></li><li><p>结论，使用bean的<code>scope</code>属性可以控制bean的创建是否为单例：</p><ul><li><code>singleton</code>默认为单例</li><li><code>prototype</code>为非单例</li></ul></li></ul><h5 id="scope使用后续思考"><a href="#scope使用后续思考" class="headerlink" title="scope使用后续思考"></a>scope使用后续思考</h5><p>介绍完<code>scope</code>属性以后，我们来思考几个问题:</p><ul><li>为什么bean默认为单例?<ul><li>bean为单例的意思是在Spring的IOC容器中只会有该类的一个对象</li><li>bean对象只有一个就避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高</li></ul></li><li>bean在容器中是单例的，会不会产生线程安全问题?<ul><li>如果对象是有状态对象，即该对象有成员变量可以用来存储数据的，</li><li>因为所有请求线程共用一个bean对象，所以会存在线程安全问题。</li><li>如果对象是无状态对象，即该对象没有成员变量没有进行数据存储的，</li><li>因方法中的局部变量在方法调用完成后会被销毁，所以不会存在线程安全问题。</li></ul></li><li>哪些bean对象适合交给容器进行管理?<ul><li>表现层对象</li><li>业务层对象</li><li>数据层对象</li><li>工具对象</li></ul></li><li>哪些bean对象不适合交给容器进行管理?<ul><li>封装实例的域对象，因为会引发线程安全问题，所以不适合。</li></ul></li></ul><h4 id="bean基础配置小结"><a href="#bean基础配置小结" class="headerlink" title="bean基础配置小结"></a>bean基础配置小结</h4><p>关于bean的基础配置中，需要大家掌握以下属性:</p><p><img src="/.com//1631529887695-1719409838882-23.png" alt="1631529887695"></p><h3 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h3><p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p><p>就需要研究下<code>bean的实例化过程</code>，在这块内容中主要解决两部分内容，分别是</p><ul><li>bean是如何创建的</li><li>实例化bean的三种方式，<code>构造方法</code>,<code>静态工厂</code>和<code>实例工厂</code></li></ul><p>在讲解这三种创建方式之前，我们需要先确认一件事:</p><p>bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的。</p><p>基于这个知识点出发，我们来验证spring中bean的三种创建方式，</p><h4 id="构造方法实例化"><a href="#构造方法实例化" class="headerlink" title="构造方法实例化"></a>构造方法实例化</h4><p>在上述的环境下，我们来研究下Spring中的第一种bean的创建方式<code>构造方法实例化</code>:</p><p><strong>步骤1:准备需要被创建的类</strong></p><p>准备一个BookDao和BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:将类配置到Spring容器</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤3:编写运行程序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceBook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4:类中提供构造函数测试</strong></p><p>在BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，如果控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数</p><p><img src="/.com//1629775972507-1719409838882-24.png" alt="1629775972507"></p><p><strong>步骤5:将构造函数改成private测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，能执行成功,说明内部走的依然是构造函数,能访问到类中的私有构造方法,显而易见Spring底层用的是反射</p><p><img src="/.com//1629775972507-1719409838882-24.png" alt="1629775972507"></p><p><strong>步骤6:构造函数中添加一个参数测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BookDaoImpl</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，</p><p>程序会报错，说明Spring底层使用的是类的无参构造方法。</p><p><img src="/.com//../../../Typora%E7%AC%94%E8%AE%B0/Spring/1629776331499.png" alt="1629776331499"></p><h4 id="静态工厂实例化"><a href="#静态工厂实例化" class="headerlink" title="静态工厂实例化"></a>静态工厂实例化</h4><p>接下来研究Spring中的第二种bean的创建方式<code>静态工厂实例化</code>:</p><p><strong>工厂方式创建bean</strong></p><p>在讲这种方式之前，我们需要先回顾一个知识点是使用工厂来创建对象的方式:</p><p>(1)准备一个OrderDao和OrderDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;order dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)创建一个工厂类OrderDaoFactory并提供一个&#x3D;&#x3D;静态方法&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态工厂创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)编写AppForInstanceOrder运行类，在类中通过工厂获取对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过静态工厂创建对象</span></span><br><span class="line">        <span class="type">OrderDao</span> <span class="variable">orderDao</span> <span class="operator">=</span> OrderDaoFactory.getOrderDao();</span><br><span class="line">        orderDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)运行后，可以查看到结果</p><p><img src="/.com//1629786862329-1719409838882-26.png" alt="1629786862329"></p><p>如果代码中对象是通过上面的这种方式来创建的，如何将其交给Spring来管理呢?</p><p><strong>静态工厂实例化</strong></p><p>这就要用到Spring中的静态工厂实例化的知识了，具体实现步骤为:</p><p>(1)在spring的配置文件application.properties中添加以下内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.OrderDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getOrderDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>class:工厂类的类全名</p><p>factory-mehod:具体工厂类中创建对象的方法名</p><p>对应关系如下图:</p><p><img src="/.com//image-20210729195248948-1719409838882-28.png" alt="image-20210729195248948"></p><p>(2)在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OrderDao</span> <span class="variable">orderDao</span> <span class="operator">=</span> (OrderDao) ctx.getBean(<span class="string">&quot;orderDao&quot;</span>);</span><br><span class="line"></span><br><span class="line">        orderDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)运行后，可以查看到结果</p><p><img src="/.com//1629786862329-1719409838882-26.png" alt="1629786862329"></p><p>看到这，可能有人会问了，你这种方式在工厂类中不也是直接new对象的，和我自己直接new没什么太大的区别，而且静态工厂的方式反而更复杂，这种方式的意义是什么?</p><p>主要的原因是:</p><ul><li>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，这些操作必不可少,如:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;factory setup....&quot;</span>);<span class="comment">//模拟必要的业务操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前new对象的方式就无法添加其他的业务内容，重新运行，查看结果:</p><p><img src="/.com//1629788036885-1719409838882-27.png" alt="1629788036885"></p><p>介绍完静态工厂实例化后，这种方式一般是用来兼容早期的一些老系统，所以&#x3D;&#x3D;了解为主&#x3D;&#x3D;。</p><h4 id="实例工厂与FactoryBean"><a href="#实例工厂与FactoryBean" class="headerlink" title="实例工厂与FactoryBean"></a>实例工厂与FactoryBean</h4><p>接下来继续来研究Spring的第三种bean的创建方式<code>实例工厂实例化</code>:</p><p><strong>环境准备</strong></p><p>(1)准备一个UserDao和UserDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)创建一个工厂类OrderDaoFactory并提供一个普通方法，注意此处和静态工厂的工厂类不一样的地方是方法不是静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)编写AppForInstanceUser运行类，在类中通过工厂获取对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建实例工厂对象</span></span><br><span class="line">        <span class="type">UserDaoFactory</span> <span class="variable">userDaoFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoFactory</span>();</span><br><span class="line">        <span class="comment">//通过实例工厂对象创建对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> userDaoFactory.getUserDao();</span><br><span class="line">        userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)运行后，可以查看到结果</p><p><img src="/.com//1629788769436-1719409838882-29.png" alt="1629788769436"></p><p>对于上面这种实例工厂的方式如何交给Spring管理呢?</p><p><strong>实例工厂实例化</strong></p><p>具体实现步骤为:</p><p>(1)在spring的配置文件中添加以下内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>实例化工厂运行的顺序是:</p><ul><li><p>创建实例化工厂对象,对应的是第一行配置</p></li><li><p>调用对象中的方法来创建bean，对应的是第二行配置</p><ul><li><p>factory-bean:工厂的实例对象</p></li><li><p>factory-method:工厂对象中的具体创建对象的方法名,对应关系如下:</p><p><img src="/.com//image-20210729200203249-1719409838882-30.png" alt="image-20210729200203249"></p></li></ul></li></ul><p>factory-mehod:具体工厂类中创建对象的方法名</p><p>(2)在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)运行后，可以查看到结果</p><p><img src="/.com//1629788769436-1719409838882-29.png" alt="1629788769436"></p><p>实例工厂实例化的方式就已经介绍完了，配置的过程还是比较复杂，所以Spring为了简化这种配置方式就提供了一种叫<code>FactoryBean</code>的方式来简化开发。</p><p><strong>FactoryBean的使用</strong></p><p>具体的使用步骤为:</p><p>(1)创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回所创建类的Class对象</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)在Spring的配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>(3)AppForInstanceUser运行类不用做任何修改，直接运行</p><p><img src="/.com//1629788769436-1719409838882-29.png" alt="1629788769436"></p><p>这种方式在Spring去整合其他框架的时候会被用到，所以这种方式需要大家理解掌握。</p><p>查看源码会发现，FactoryBean接口其实会有三个方法，分别是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法一:getObject()，被重写后，在方法中进行对象的创建并返回</p><p>方法二:getObjectType(),被重写后，主要返回的是被创建类的Class对象</p><p>方法三:没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true，从意思上来看，我们猜想默认应该是单例，如何来验证呢?</p><p>思路很简单，就是从容器中获取该对象的多个值，打印到控制台，查看是否为同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        System.out.println(userDao1);</span><br><span class="line">        System.out.println(userDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果，如下:</p><p><img src="/.com//1629790070607-1719409838882-31.png" alt="1629790070607"></p><p>通过验证，会发现默认是单例，那如果想改成单例具体如何实现?</p><p>只需要将isSingleton()方法进行重写，修改返回为false，即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FactoryBean创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行AppForInstanceUser，查看结果</p><p><img src="/.com//1629790197860-1719409838882-32.png" alt="1629790197860"></p><p>从结果中可以看出现在已经是非单例了，但是一般情况下我们都会采用单例，也就是采用默认即可。所以isSingleton()方法一般不需要进行重写。</p><h4 id="bean实例化小结"><a href="#bean实例化小结" class="headerlink" title="bean实例化小结"></a>bean实例化小结</h4><p>通过这一节的学习，需要掌握:</p><p>(1)bean是如何创建的呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造方法</span><br></pre></td></tr></table></figure><p>(2)Spring的IOC实例化对象的三种方式分别是:</p><ul><li>构造方法(常用)</li><li>静态工厂(了解)</li><li>实例工厂(了解)<ul><li>FactoryBean(实用)</li></ul></li></ul><p>这些方式中，重点掌握<code>构造方法</code>和<code>FactoryBean</code>即可。</p><p>需要注意的一点是，构造方法在类中默认会提供，但是如果重写了构造方法，默认的就会消失，在使用的过程中需要注意，如果需要重写构造方法，最好把默认的构造方法也重写下。</p><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><p>关于bean的相关知识还有最后一个是<code>bean的生命周期</code>,对于生命周期，我们主要围绕着<code>bean生命周期控制</code>来讲解:</p><ul><li>首先理解下什么是生命周期?<ul><li>从创建到消亡的完整过程,例如人从出生到死亡的整个过程就是一个生命周期。</li></ul></li><li>bean生命周期是什么?<ul><li>bean对象从创建到销毁的整体过程。</li></ul></li><li>bean生命周期控制是什么?<ul><li>在bean创建后到销毁前做一些事情。</li></ul></li></ul><p>现在我们面临的问题是如何在bean的创建之后和销毁之前把我们需要添加的内容添加进去。</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>还是老规矩，为了方便大家后期代码的阅读，我们重新搭建下环境:</p><ul><li>创建一个Maven项目</li><li>pom.xml添加依赖</li><li>resources下添加spring的配置文件applicationContext.xml</li></ul><p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p><p><img src="/.com//1629791473409-1719409838882-33.png" alt="1629791473409"></p><p>(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)resources下提供spring的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3)编写AppForLifeCycle运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForLifeCycle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">        <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生命周期设置"><a href="#生命周期设置" class="headerlink" title="生命周期设置"></a>生命周期设置</h4><p>接下来，在上面这个环境中来为BookDao添加生命周期的控制方法，具体的控制有两个阶段:</p><ul><li>bean创建之后，想要添加内容，比如用来初始化需要用到资源</li><li>bean销毁之前，想要添加内容，比如用来释放用到的资源</li></ul><p><strong>步骤1:添加初始化和销毁方法</strong></p><p>针对这两个阶段，我们在BooDaoImpl类中分别添加两个方法，&#x3D;&#x3D;方法名任意&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean初始化对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean销毁前对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:配置生命周期</strong></p><p>在配置文件添加配置，如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤3:运行程序</strong></p><p>运行AppForLifeCycle打印结果为:</p><p><img src="/.com//1629792339889-1719409838882-34.png" alt="1629792339889"></p><p>从结果中可以看出，init方法执行了，但是destroy方法却未执行，这是为什么呢?</p><ul><li>Spring的IOC容器是运行在JVM中</li><li>运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行</li><li>main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了</li><li>所以没有调用对应的destroy方法</li></ul><p>知道了出现问题的原因，具体该如何解决呢?</p><h4 id="close关闭容器"><a href="#close关闭容器" class="headerlink" title="close关闭容器"></a>close关闭容器</h4><ul><li><p>ApplicationContext中没有close方法</p></li><li><p>需要将ApplicationContext更换成ClassPathXmlApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">    <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>调用ctx的close()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.close();</span><br></pre></td></tr></table></figure></li><li><p>运行程序，就能执行destroy方法的内容</p><p><img src="/.com//1629792857608-1719409838882-35.png" alt="1629792857608"></p></li></ul><h4 id="注册钩子关闭容器"><a href="#注册钩子关闭容器" class="headerlink" title="注册钩子关闭容器"></a>注册钩子关闭容器</h4><ul><li><p>在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器</p></li><li><p>调用ctx的registerShutdownHook()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.registerShutdownHook();</span><br></pre></td></tr></table></figure><p>**注意:**registerShutdownHook在ApplicationContext中也没有</p></li><li><p>运行后，查询打印结果</p><p><img src="/.com//1629792857608-1719409838882-35.png" alt="1629792857608"></p></li></ul><p>两种方式介绍完后，close和registerShutdownHook选哪个?</p><p>相同点:这两种都能用来关闭容器</p><p>不同点:close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。</p><p>分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。</p><p>Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code></p><p>接下来在BookServiceImpl完成这两个接口的使用:</p><p>修改BookServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行AppForLifeCycle类，</p><p><img src="/.com//1629794527419-1719409838882-36.png" alt="1629794527419"></p><p>那第二种方式的实现，我们也介绍完了。</p><p><strong>小细节</strong></p><ul><li><p>对于InitializingBean接口中的afterPropertiesSet方法，翻译过来为<code>属性设置之后</code>。</p></li><li><p>对于BookServiceImpl来说，bookDao是它的一个属性</p></li><li><p>setBookDao方法是Spring的IOC容器为其注入属性的方法</p></li><li><p>思考:afterPropertiesSet和setBookDao谁先执行?</p><ul><li><p>从方法名分析，猜想应该是setBookDao方法先执行</p></li><li><p>验证思路，在setBookDao方法中添加一句话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;set .....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>重新运行AppForLifeCycle，打印结果如下:</p><p><img src="/.com//1629794928636-1719409838883-37.png" alt="1629794928636"></p><p>验证的结果和我们猜想的结果是一致的，所以初始化方法会在类中属性设置之后执行。</p></li></ul></li></ul><h4 id="bean生命周期小结"><a href="#bean生命周期小结" class="headerlink" title="bean生命周期小结"></a>bean生命周期小结</h4><p>(1)关于Spring中对bean生命周期控制提供了两种方式:</p><ul><li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性</li><li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口，这种方式了解下即可。</li></ul><p>(2)对于bean的生命周期控制在bean的整个生命周期中所处的位置如下:</p><ul><li>初始化容器<ul><li>1.创建对象(内存分配)</li><li>2.执行构造方法</li><li>3.执行属性注入(set操作)</li><li>&#x3D;&#x3D;4.执行bean初始化方法&#x3D;&#x3D;</li></ul></li><li>使用bean<ul><li>1.执行业务操作</li></ul></li><li>关闭&#x2F;销毁容器<ul><li>&#x3D;&#x3D;1.执行bean销毁方法&#x3D;&#x3D;</li></ul></li></ul><p>(3)关闭容器的两种方式:</p><ul><li>ConfigurableApplicationContext是ApplicationContext的子类<ul><li>close()方法</li><li>registerShutdownHook()方法</li></ul></li></ul><h2 id="DI相关内容"><a href="#DI相关内容" class="headerlink" title="DI相关内容"></a>DI相关内容</h2><p>前面我们已经完成了bean相关操作的讲解，接下来就进入第二个大的模块<code>DI依赖注入</code>，首先来介绍下Spring中有哪些注入方式?</p><p>我们先来思考</p><ul><li>向一个类中传递数据的方式有几种?<ul><li>普通方法(set方法)</li><li>构造方法</li></ul></li><li>依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢?<ul><li>引用类型</li><li>简单类型(基本数据类型与String)</li></ul></li></ul><p>Spring就是基于上面这些知识点，为我们提供了两种注入方式，分别是:</p><ul><li>setter注入<ul><li>简单类型</li><li>&#x3D;&#x3D;引用类型&#x3D;&#x3D;</li></ul></li><li>构造器注入<ul><li>简单类型</li><li>引用类型</li></ul></li></ul><p>依赖注入的方式已经介绍完，接下来挨个学习下:</p><h3 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h3><ol><li>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</li></ol><ul><li>在bean中定义引用类型属性，并提供可访问的&#x3D;&#x3D;set&#x3D;&#x3D;方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置中使用&#x3D;&#x3D;property&#x3D;&#x3D;标签&#x3D;&#x3D;ref&#x3D;&#x3D;属性注入引用类型对象</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.imipl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注入引用数据类型"><a href="#注入引用数据类型" class="headerlink" title="注入引用数据类型"></a>注入引用数据类型</h4><blockquote><p>需求:在bookServiceImpl对象中注入userDao</p><p>1.在BookServiceImpl中声明userDao属性</p><p>2.为userDao属性提供setter方法</p><p>3.在配置文件中使用property标签注入</p></blockquote><p><strong>步骤1:声明属性并提供setter方法</strong></p><p>在BookServiceImpl中声明userDao属性，并提供setter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:配置文件中进行注入配置</strong></p><p>在applicationContext.xml配置文件中使用property标签注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤3:运行程序</strong></p><p>运行AppForDISet类，查看结果，说明userDao已经成功注入。</p><p><img src="/.com//1629799873386-1719409838883-38.png" alt="1629799873386"></p><h4 id="注入简单数据类型"><a href="#注入简单数据类型" class="headerlink" title="注入简单数据类型"></a>注入简单数据类型</h4><blockquote><p>需求：给BookDaoImpl注入一些简单数据类型的数据</p><p>参考引用数据类型的注入，我们可以推出具体的步骤为:</p><p>1.在BookDaoImpl类中声明对应的简单数据类型的属性</p><p>2.为这些属性提供对应的setter方法</p><p>3.在applicationContext.xml中配置</p></blockquote><p><strong>思考:</strong></p><p>引用类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code>,简单数据类型还是使用ref么?</p><p>ref是指向Spring的IOC容器中的另一个bean对象的，对于简单数据类型，没有对应的bean对象，该如何配置?</p><p><strong>步骤1:声明属性并提供setter方法</strong></p><p>在BookDaoImpl类中声明对应的简单数据类型的属性,并提供对应的setter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnectionNum</span><span class="params">(<span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDatabaseName</span><span class="params">(String databaseName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>+databaseName+<span class="string">&quot;,&quot;</span>+connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:配置文件中进行注入配置</strong></p><p>在applicationContext.xml配置文件中使用property标签注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>value:后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样的话，spring在将<code>abc</code>转换成int类型的时候就会报错。</p><p><strong>步骤3:运行程序</strong></p><p>运行AppForDISet类，查看结果，说明userDao已经成功注入。</p><p><img src="/.com//1629800324721-1719409838883-39.png" alt="1629800324721"></p><p>**注意:**两个property注入标签的顺序可以任意。</p><p>对于setter注入方式的基本使用就已经介绍完了，</p><ul><li>对于引用数据类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code></li><li>对于简单数据类型使用的是<code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li></ul><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>接下来，在上面这个环境中来完成构造器注入的学习:</p><blockquote><p>需求：将BookServiceImpl类中的bookDao修改成使用构造器的方式注入。</p><p>1.将bookDao的setter方法删除掉</p><p>2.添加带有bookDao参数的构造方法</p><p>3.在applicationContext.xml中配置</p></blockquote><p><strong>步骤1:删除setter方法并提供构造方法</strong></p><p>在BookServiceImpl类中将bookDao的setter方法删除掉,并添加带有bookDao参数的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:配置文件中进行配置构造方式注入</strong></p><p>在applicationContext.xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>标签<constructor-arg>中</constructor-arg></p><ul><li><p>name属性对应的值为构造函数中方法形参的参数名，必须要保持一致。</p></li><li><p>ref属性指向的是spring的IOC容器中其他bean对象。</p></li></ul><p><strong>步骤3：运行程序</strong></p><p>运行AppForDIConstructor类，查看结果，说明bookDao已经成功注入。</p><p><img src="/.com//1629802656916-1719409838883-40.png" alt="1629802656916"></p><h4 id="多个引用数据类型"><a href="#多个引用数据类型" class="headerlink" title="多个引用数据类型"></a>多个引用数据类型</h4><blockquote><p>需求:在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao</p><p>1.声明userDao属性</p><p>2.生成一个带有bookDao和userDao参数的构造函数</p><p>3.在applicationContext.xml中配置注入</p></blockquote><p><strong>步骤1:提供多个属性的构造函数</strong></p><p>在BookServiceImpl声明userDao并提供多个参数的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao,UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:配置文件中配置多参数注入</strong></p><p>在applicationContext.xml中配置注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**说明:**这两个<code>&lt;contructor-arg&gt;</code>的配置顺序可以任意</p><p><strong>步骤3:运行程序</strong></p><p>运行AppForDIConstructor类，查看结果，说明userDao已经成功注入。</p><p><img src="/.com//1629802697318-1719409838883-41.png" alt="1629802697318"></p><h4 id="多个简单数据类型"><a href="#多个简单数据类型" class="headerlink" title="多个简单数据类型"></a>多个简单数据类型</h4><blockquote><p>需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。</p><p>参考引用数据类型的注入，我们可以推出具体的步骤为:</p><p>1.提供一个包含这两个参数的构造方法</p><p>2.在applicationContext.xml中进行注入配置</p></blockquote><p><strong>步骤1:添加多个简单属性并提供构造方法</strong></p><p>修改BookDaoImpl类，添加构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">(String databaseName, <span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>+databaseName+<span class="string">&quot;,&quot;</span>+connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:配置完成多个属性构造器注入</strong></p><p>在applicationContext.xml中进行注入配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**说明:**这两个<code>&lt;contructor-arg&gt;</code>的配置顺序可以任意</p><p><strong>步骤3:运行程序</strong></p><p>运行AppForDIConstructor类，查看结果</p><p><img src="/.com//1629803111769-1719409838883-42.png" alt="1629803111769"></p><p>上面已经完成了构造函数注入的基本使用，但是会存在一些问题:</p><p><img src="/.com//1629803529598-1719409838883-43.png" alt="1629803529598"></p><ul><li>当构造函数中方法的参数名发生变化后，配置文件中的name属性也需要跟着变</li><li>这两块存在紧耦合，具体该如何解决?</li></ul><p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，大家都以了解为主。</p><p>方式一:删除name属性，添加type属性，按照类型注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这种方式可以解决构造函数形参名发生变化带来的耦合问题</li><li>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</li></ul><p>方式二:删除type属性，添加index属性，按照索引下标注入，下标从0开始</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这种方式可以解决参数类型重复问题</li><li>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</li></ul><p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p><ol><li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul><li>强制依赖指对象在创建的过程中必须要注入指定的参数</li></ul></li><li>可选依赖使用setter注入进行，灵活性强<ul><li>可选依赖指对象在创建过程中注入的参数可有可无</li></ul></li><li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li><li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li><li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li><li><strong>&#x3D;&#x3D;自己开发的模块推荐使用setter注入&#x3D;&#x3D;</strong></li></ol><p>这节中主要讲解的是Spring的依赖注入的实现方式:</p><ul><li><p>setter注入</p><ul><li><p>简单数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>构造器注入</p><ul><li><p>简单数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>依赖注入的方式选择上</p><ul><li>建议使用setter注入</li><li>第三方技术根据情况选择</li></ul></li></ul><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>前面花了大量的时间把Spring的注入去学习了下，总结起来就一个字&#x3D;&#x3D;麻烦&#x3D;&#x3D;。</p><p>问:麻烦在哪?</p><p>答:配置文件的编写配置上。</p><p>问:有更简单方式么?</p><p>答:有，自动配置</p><p>什么是自动配置以及如何实现自动配置，就是接下来要学习的内容：</p><h4 id="什么是依赖自动装配"><a href="#什么是依赖自动装配" class="headerlink" title="什么是依赖自动装配?"></a>什么是依赖自动装配?</h4><ul><li>IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配</li></ul><h4 id="自动装配方式有哪些"><a href="#自动装配方式有哪些" class="headerlink" title="自动装配方式有哪些?"></a>自动装配方式有哪些?</h4><ul><li>&#x3D;&#x3D;按类型（常用）&#x3D;&#x3D;</li><li>按名称</li><li>按构造方法</li><li>不启用自动装配</li></ul><h4 id="准备下案例环境"><a href="#准备下案例环境" class="headerlink" title="准备下案例环境"></a>准备下案例环境</h4><ul><li>创建一个Maven项目</li><li>pom.xml添加依赖</li><li>resources下添加spring的配置文件</li></ul><p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p><p><img src="/.com//1629805387647-1719409838883-44.png" alt="1629805387647"></p><p>(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)resources下提供spring的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3)编写AppForAutoware运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAutoware</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完成自动装配的配置"><a href="#完成自动装配的配置" class="headerlink" title="完成自动装配的配置"></a>完成自动装配的配置</h4><p>接下来，在上面这个环境中来完成<code>自动装配</code>的学习:</p><p>自动装配只需要修改applicationContext.xml配置文件即可:</p><p>(1)将<code>&lt;property&gt;</code>标签删除</p><p>(2)在<code>&lt;bean&gt;</code>标签中添加autowire属性</p><p>首先来实现按照类型注入的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p><ul><li>需要注入属性的类中对应属性的setter方法不能省略</li><li>被注入的对象必须要被Spring的IOC容器管理</li><li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li></ul><p>一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p><ul><li><p>按照名称注入中的名称指的是什么?</p><p><img src="/.com//1629806856156-1719409838883-45.png" alt="1629806856156"></p><ul><li>bookDao是private修饰的，外部类无法直接方法</li><li>外部类只能通过属性的set方法进行访问</li><li>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名<ul><li>为什么是去掉set首字母小写?</li><li>这个规则是set方法生成的默认规则，set方法的生成是把属性名首字母大写前面加set形成的方法名</li></ul></li><li>所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的</li></ul></li><li><p>如果按照名称去找对应的bean对象，找不到则注入Null</p></li><li><p>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</p></li></ul><p>两种方式介绍完后，以后用的更多的是&#x3D;&#x3D;按照类型&#x3D;&#x3D;注入。</p><p>最后对于依赖注入，需要注意一些其他的配置特征:</p><ol><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li><li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li></ol><h3 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h3><p>前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型&#x3D;&#x3D;集合&#x3D;&#x3D;，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢?</p><p>先来回顾下，常见的集合类型有哪些?</p><ul><li>数组</li><li>List</li><li>Set</li><li>Map</li><li>Properties</li></ul><p>针对不同的集合类型，该如何实现注入呢?</p><h4 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>chuanzhihui<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Map类型"><a href="#Map类型" class="headerlink" title="Map类型"></a>Map类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span> <span class="attr">value</span>=<span class="string">&quot;henan&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kaifeng&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Properties类型"><a href="#Properties类型" class="headerlink" title="Properties类型"></a>Properties类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span>&gt;</span>china<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span>&gt;</span>henan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span>&gt;</span>kaifeng<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成后，运行下看结果:</p><p><img src="/.com//1629808046783-1719409838883-46.png" alt="1629808046783"></p><p><strong>说明：</strong></p><ul><li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li><li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li><li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li></ul><h2 id="IOC-DI配置管理第三方bean"><a href="#IOC-DI配置管理第三方bean" class="headerlink" title="IOC&#x2F;DI配置管理第三方bean"></a>IOC&#x2F;DI配置管理第三方bean</h2><p>前面所讲的知识点都是基于我们自己写的类，现在如果有需求让我们去管理第三方jar包中的类，该如何管理?</p><h3 id="案例-数据源对象管理"><a href="#案例-数据源对象管理" class="headerlink" title="案例:数据源对象管理"></a>案例:数据源对象管理</h3><p>在这一节中，我们将通过一个案例来学习下对于第三方bean该如何进行配置管理。</p><p>以后我们会用到很多第三方的bean,本次案例将使用咱们前面提到过的数据源<code>Druid(德鲁伊)</code>和<code>C3P0</code>来配置学习下。</p><h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><p>学习之前，先来准备下案例环境:</p><ul><li><p>创建一个Maven项目</p><p><img src="/.com//1629860338328-1719303975236-1-1719409838883-47.png" alt="1629860338328"></p></li><li><p>pom.xml添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>resources下添加spring的配置文件applicationContext.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">            http://www.springframework.org/schema/beans</span><br><span class="line">            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写一个运行类App</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>在上述环境下，我们来对数据源进行配置管理，先来分析下思路:</p><blockquote><p>需求:使用Spring的IOC容器来管理Druid连接池对象</p><p>1.使用第三方的技术，需要在pom.xml添加依赖</p><p>2.在配置文件中将【第三方的类】制作成一个bean，让IOC容器进行管理</p><p>3.数据库连接需要基础的四要素<code>驱动</code>、<code>连接</code>、<code>用户名</code>和<code>密码</code>，【如何注入】到对应的bean中</p><p>4.从IOC容器中获取对应的bean对象，将其打印到控制台查看结果</p></blockquote><p><strong>思考:</strong></p><ul><li>第三方的类指的是什么?</li><li>如何注入数据库连接四要素?</li></ul><h4 id="实现Druid管理"><a href="#实现Druid管理" class="headerlink" title="实现Druid管理"></a>实现Druid管理</h4><p>带着这两个问题，把下面的案例实现下:</p><p><strong>步骤1:导入<code>druid</code>的依赖</strong></p><p>pom.xml中添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.1</span><span class="number">.16</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>步骤2:配置第三方bean</strong></p><p>在applicationContext.xml配置文件中添加<code>DruidDataSource</code>的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;!--管理DruidDataSource对象--&gt;</span><br><span class="line">    &lt;bean class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>driverClassName:数据库驱动</li><li>url:数据库连接地址</li><li>username:数据库连接用户名</li><li>password:数据库连接密码</li><li>数据库连接的四要素要和自己使用的数据库信息一致。</li></ul><p><strong>步骤3:从IOC容器中获取对应的bean对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">       <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) ctx.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">       System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4:运行程序</strong></p><p>打印如下结果: 说明第三方bean对象已经被spring的IOC容器进行管理</p><p><img src="/.com//1629887733081-1719303975236-3-1719409838883-48.png" alt="1629887733081"></p><p>做完案例后，我们可以将刚才思考的两个问题答案说下:</p><ul><li><p>第三方的类指的是什么?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DruidDataSource</span><br></pre></td></tr></table></figure></li><li><p>如何注入数据库连接四要素?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setter注入</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现C3P0管理"><a href="#实现C3P0管理" class="headerlink" title="实现C3P0管理"></a>实现C3P0管理</h4><p>完成了DruidDataSource的管理，接下来我们再来加深下练习，这次我们来管理<code>C3P0</code>数据源，具体的实现步骤是什么呢?</p><blockquote><p>需求:使用Spring的IOC容器来管理C3P0连接池对象</p><p>实现方案和上面基本一致，重点要关注管理的是哪个bean对象&#96;?</p></blockquote><p><strong>步骤1:导入<code>C3P0</code>的依赖</strong></p><p>pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>对于新的技术，不知道具体的坐标该如何查找?</strong></p><ul><li><p>直接百度搜索</p></li><li><p>从mvn的仓库<code>https://mvnrepository.com/</code>中进行搜索</p><p><img src="/.com//1629888540286-1719303975236-2-1719409838883-49.png" alt="1629888540286"></p></li></ul><p><strong>步骤2:配置第三方bean</strong></p><p>在applicationContext.xml配置文件中添加配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>ComboPooledDataSource的属性是通过setter方式进行注入</li><li>想注入属性就需要在ComboPooledDataSource类或其上层类中有提供属性对应的setter方法</li><li>C3P0的四个属性和Druid的四个属性是不一样的</li></ul><p><strong>步骤3:运行程序</strong></p><p>程序会报错，错误如下</p><p><img src="/.com//../../../Typora%E7%AC%94%E8%AE%B0/Spring/1629889170229-1719303975236-4.png" alt="1629889170229"></p><p>报的错为ClassNotFoundException,翻译出来是<code>类没有发现的异常</code>，具体的类为<code>com.mysql.jdbc.Driver</code>。错误的原因是缺少mysql的驱动包。</p><p>分析出错误的原因，具体的解决方案就比较简单，只需要在pom.xml把驱动包引入即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加完mysql的驱动包以后，再次运行App,就可以打印出结果:</p><p><img src="/.com//../../../Typora%E7%AC%94%E8%AE%B0/Spring/1629903845404-1719303975236-5.png" alt="1629903845404"></p><p><strong>注意：</strong></p><ul><li>数据连接池在配置属性的时候，除了可以注入数据库连接四要素外还可以配置很多其他的属性，具体都有哪些属性用到的时候再去查，一般配置基础的四个，其他都有自己的默认值</li><li>Druid和C3P0在没有导入mysql驱动包的前提下，一个没报错一个报错，说明Druid在初始化的时候没有去加载驱动，而C3P0刚好相反</li><li>Druid程序运行虽然没有报错，但是当调用DruidDataSource的getConnection()方法获取连接的时候，也会报找不到驱动类的错误</li></ul><h3 id="加载properties文件"><a href="#加载properties文件" class="headerlink" title="加载properties文件"></a>加载properties文件</h3><p>上节中我们已经完成两个数据源<code>druid</code>和<code>C3P0</code>的配置，但是其中包含了一些问题，我们来分析下:</p><ul><li>这两个数据源中都使用到了一些固定的常量如数据库连接四要素，把这些值写在Spring的配置文件中不利于后期维护</li><li>需要将这些值提取到一个外部的properties配置文件中</li><li>Spring框架如何从配置文件中读取属性值来配置就是接下来要解决的问题。</li></ul><p>问题提出来后，具体该如何实现?</p><h4 id="第三方bean属性优化"><a href="#第三方bean属性优化" class="headerlink" title="第三方bean属性优化"></a>第三方bean属性优化</h4><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><blockquote><p>需求:将数据库连接四要素提取到properties配置文件，spring来加载配置信息并使用这些信息来完成属性注入。</p><p>1.在resources下创建一个jdbc.properties(文件的名称可以任意)</p><p>2.将数据库连接四要素配置到配置文件中</p><p>3.在Spring的配置文件中加载properties文件</p><p>4.使用加载到的值实现属性注入</p><p>其中第3，4步骤是需要大家重点关注，具体是如何实现。</p></blockquote><h5 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h5><p><strong>步骤1:准备properties配置文件</strong></p><p>resources下创建一个jdbc.properties文件,并添加对应的属性键值对</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><p><strong>步骤2:开启<code>context</code>命名空间</strong></p><p>在applicationContext.xml中开<code>context</code>命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤3:加载properties配置文件</strong></p><p>在配置文件中使用<code>context</code>命名空间下的标签来加载properties配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤4:完成属性注入</strong></p><p>使用<code>$&#123;key&#125;</code>来读取properties配置文件中的内容并完成属性注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至此，读取外部properties配置文件中的内容就已经完成。</p><h4 id="读取单个属性"><a href="#读取单个属性" class="headerlink" title="读取单个属性"></a>读取单个属性</h4><h5 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h5><p>对于上面的案例，效果不是很明显，我们可以换个案例来演示下:</p><blockquote><p>需求:从properties配置文件中读取key为name的值，并将其注入到BookDao中并在save方法中进行打印。</p><p>1.在项目中添加BookDao和BookDaoImpl类</p><p>2.为BookDaoImpl添加一个name属性并提供setter方法</p><p>3.在jdbc.properties中添加数据注入到bookDao中打印方便查询结果</p><p>4.在applicationContext.xml添加配置完成配置文件加载、属性注入(${key})</p></blockquote><h5 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h5><p><strong>步骤1:在项目中添对应的类</strong></p><p>BookDao和BookDaoImpl类，并在BookDaoImpl类中添加<code>name</code>属性与setter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:完成配置文件的读取与注入</strong></p><p>在applicationContext.xml添加配置，<code>bean的配置管理</code>、<code>读取外部properties</code>、<code>依赖注入</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;context:property-placeholder location=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><strong>步骤3:运行程序</strong></p><p>在App类中，从IOC容器中获取bookDao对象，调用方法，查看值是否已经被获取到并打印控制台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//1629975492444-1719303975236-6-1719409838883-52.png" alt="1629975492444"></p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>至此，读取properties配置文件中的内容就已经完成，但是在使用的时候，有些注意事项:</p><ul><li><p>问题一:键值对的key为<code>username</code>引发的问题</p><p>1.在properties中配置键值对的时候，如果key设置为<code>username</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">root666</span></span><br></pre></td></tr></table></figure><p>2.在applicationContext.xml注入该属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.运行后，在控制台打印的却不是<code>root666</code>，而是自己电脑的用户名</p><p><img src="/.com//1629975934694-1719303975236-7-1719409838883-53.png" alt="1629975934694"></p><p>4.出现问题的原因是<code>&lt;context:property-placeholder/&gt;</code>标签会加载系统的环境变量，而且环境变量的值会被优先加载，如何查看系统的环境变量?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Map&lt;String, String&gt; env = System.getenv();</span><br><span class="line">    System.out.println(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以自行运行，在打印出来的结果中会有一个USERNAME&#x3D;XXX[自己电脑的用户名称]</p><p>5.解决方案</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>system-properties-mode:设置为NEVER,表示不加载系统属性，就可以解决上述问题。</p><p>当然还有一个解决方案就是避免使用<code>username</code>作为属性的<code>key</code>。</p></li><li><p>问题二:当有多个properties配置文件需要被加载，该如何配置?</p><p>1.调整下配置文件的内容，在resources下添加<code>jdbc.properties</code>,<code>jdbc2.properties</code>,内容如下:</p><p>jdbc.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><p>jdbc2.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">root666</span></span><br></pre></td></tr></table></figure><p>2.修改applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式一 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties,jdbc2.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式三 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式四--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>    </span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>方式一:可以实现，如果配置文件多的话，每个都需要配置</li><li>方式二:<code>*.properties</code>代表所有以properties结尾的文件都会被加载，可以解决方式一的问题，但是不标准</li><li>方式三:标准的写法，<code>classpath:</code>代表的是从根路径下开始查找，但是只能查询当前项目的根路径</li><li>方式四:不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的properties配置文件</li></ul></li></ul><h4 id="加载properties文件小结"><a href="#加载properties文件小结" class="headerlink" title="加载properties文件小结"></a>加载properties文件小结</h4><p>  本节主要讲解的是properties配置文件的加载，需要掌握的内容有:</p><ul><li><p>如何开启<code>context</code>命名空间</p><p><img src="/.com//1629980280952-1719303975236-8-1719409838883-54.png" alt="1629980280952"></p></li><li><p>如何加载properties配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>如何在applicationContext.xml引入properties配置文件中的值</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">$&#123;key&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h2><p>前面已经完成bean与依赖注入的相关知识学习，接下来我们主要学习的是IOC容器中的核心容器。</p><p>这里所说的核心容器，大家可以把它简单的理解为<code>ApplicationContext</code>，前面虽然已经用到过，但是并没有系统的学习，接下来咱们从以下几个问题入手来学习下容器的相关知识:</p><ul><li>如何创建容器?</li><li>创建好容器后，如何从容器中获取bean对象?</li><li>容器类的层次结构是什么?</li><li>BeanFactory是什么?</li></ul><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="容器的创建方式"><a href="#容器的创建方式" class="headerlink" title="容器的创建方式"></a>容器的创建方式</h4><p>案例中创建<code>ApplicationContext</code>的方式为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方式翻译为:类路径下的XML配置文件</p><p>除了上面这种方式，Spring还提供了另外一种创建方式为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方式翻译为:文件系统下的XML配置文件</p><p>使用这种方式，运行，会出现如下错误:</p><p><img src="/.com//1629983245121-1719303975236-10-1719409838883-55.png" alt="1629983245121"></p><p>从错误信息中能发现，这种方式是从项目路径下开始查找<code>applicationContext.xml</code>配置文件的，所以需要将其修改为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:\\workspace\\spring\\spring_10_container\\src\\main\\resources\\applicationContext.xml&quot;</span>); </span><br></pre></td></tr></table></figure><p>**说明:**大家练习的时候，写自己的具体路径。</p><p>这种方式虽能实现，但是当项目的位置发生变化后,代码也需要跟着改,耦合度较高,不推荐使用。</p><h4 id="Bean的三种获取方式"><a href="#Bean的三种获取方式" class="headerlink" title="Bean的三种获取方式"></a>Bean的三种获取方式</h4><p>方式一，就是目前案例中获取的方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方式存在的问题是每次获取的时候都需要进行类型转换，有没有更简单的方式呢?</p><p>方式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;bookDao&quot;</span>，BookDao.class);</span><br></pre></td></tr></table></figure><p>这种方式可以解决类型强转问题，但是参数又多加了一个，相对来说没有简化多少。</p><p>方式三:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br></pre></td></tr></table></figure><p>这种方式就类似我们之前所学习依赖注入中的按类型注入。必须要确保IOC容器中该类型对应的bean对象只能有一个。</p><h4 id="容器类层次结构"><a href="#容器类层次结构" class="headerlink" title="容器类层次结构"></a>容器类层次结构</h4><p>(1)在IDEA中双击<code>shift</code>,输入BeanFactory</p><p><img src="/.com//1629985148294-1719303975236-11-1719409838883-56.png" alt="1629985148294"></p><p>(2)点击进入BeanFactory类，ctrl+h,就能查看到如下结构的层次关系</p><p><img src="/.com//../../../Typora%E7%AC%94%E8%AE%B0/Spring/1629984980781-1719303975236-12.png" alt="1629984980781"></p><p>从图中可以看出，容器类也是从无到有根据需要一层层叠加上来的，大家重点理解下这种设计思想。</p><h4 id="BeanFactory的使用"><a href="#BeanFactory的使用" class="headerlink" title="BeanFactory的使用"></a>BeanFactory的使用</h4><p>使用BeanFactory来创建IOC容器的具体实现方式为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resources);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> bf.getBean(BookDao.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好的看出<code>BeanFactory</code>和<code>ApplicationContext</code>之间的区别，在BookDaoImpl添加如下构造函数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不去获取bean对象，打印会发现：</p><ul><li><p>BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建</p></li><li><p>ApplicationContext是立即加载，容器加载的时候就会创建bean对象</p></li><li><p>ApplicationContext要想成为延迟加载，只需要按照如下方式进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>  <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>小结</strong></p><p>这一节中所讲的知识点包括:</p><ul><li><p>容器创建的两种方式</p><ul><li>ClassPathXmlApplicationContext[掌握]</li><li>FileSystemXmlApplicationContext[知道即可]</li></ul></li><li><p>获取Bean的三种方式</p><ul><li>getBean(“名称”):需要类型转换</li><li>getBean(“名称”,类型.class):多了一个参数</li><li>getBean(类型.class):容器中不能有多个该类的bean对象</li></ul><p>上述三种方式，各有各的优缺点，用哪个都可以。</p></li><li><p>容器类层次结构</p><ul><li>只需要知晓容器的最上级的父接口为 BeanFactory即可</li></ul></li><li><p>BeanFactory</p><ul><li>使用BeanFactory创建的容器是延迟加载</li><li>使用ApplicationContext创建的容器是立即加载</li><li>具体BeanFactory如何创建只需要了解即可。</li></ul></li></ul><h3 id="核心容器总结"><a href="#核心容器总结" class="headerlink" title="核心容器总结"></a>核心容器总结</h3><p>这节中没有新的知识点，只是对前面知识的一个大总结，共包含如下内容:</p><h4 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h4><ul><li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li><li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li><li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li><li>ApplicationContext接口常用初始化类<ul><li><strong>ClassPathXmlApplicationContext(常用)</strong></li><li>FileSystemXmlApplicationContext</li></ul></li></ul><h4 id="bean相关"><a href="#bean相关" class="headerlink" title="bean相关"></a>bean相关</h4><p><img src="/.com//../../../Typora%E7%AC%94%E8%AE%B0/Spring/1629986510487-1719303975236-13.png" alt="1629986510487"></p><p>其实整个配置中最常用的就两个属性id和class。</p><p>把scope、init-method、destroy-method框起来的原因是，后面注解在讲解的时候还会用到，所以大家对这三个属性关注下。</p><h4 id="依赖注入相关"><a href="#依赖注入相关" class="headerlink" title="依赖注入相关"></a>依赖注入相关</h4><p><img src="/.com//../../../Typora%E7%AC%94%E8%AE%B0/Spring/1629986848563-1719303975236-14.png" alt="1629986848563"></p><h2 id="IOC-DI注解开发"><a href="#IOC-DI注解开发" class="headerlink" title="IOC&#x2F;DI注解开发"></a>IOC&#x2F;DI注解开发</h2><p>Spring的IOC&#x2F;DI对应的配置开发就已经讲解完成，但是使用起来相对来说还是比较复杂的，复杂的地方在配置文件。</p><p>前面咱们聊Spring的时候说过，Spring可以简化代码的开发，到现在并没有体会到。</p><p>所以Spring到底是如何简化代码开发的呢?</p><p>要想真正简化开发，就需要用到Spring的注解开发，Spring对注解支持的版本历程:</p><ul><li>2.0版开始支持注解</li><li>2.5版注解功能趋于完善</li><li>3.0版支持纯注解开发</li></ul><p>关于注解开发，我们会讲解两块内容<code>注解开发定义bean</code>和<code>纯注解开发</code>。</p><p>注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解。</p><h3 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h3><p>在学习注解开发之前，先来准备下案例环境:</p><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>resources下添加applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加BookDao、BookDaoImpl、BookService、BookServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建运行类App</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1629989221808-1719303975236-15-1719409838883-60.png" alt="1629989221808"></p><h3 id="注解开发定义bean"><a href="#注解开发定义bean" class="headerlink" title="注解开发定义bean"></a>注解开发定义bean</h3><p>在上述环境的基础上，我们来学一学Spring是如何通过注解实现bean的定义开发?</p><p><strong>步骤1:删除原XML配置</strong></p><p>将配置文件中的<code>&lt;bean&gt;</code>标签删除掉</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤2:Dao上添加注解</strong></p><p>在BookDaoImpl类上添加<code>@Component</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:@Component注解不可以添加在接口上，因为接口是无法创建对象的。</p><p>XML与注解配置的对应关系:</p><p><img src="/.com//1629990315619-1719303975236-16-1719409838883-61.png" alt="1629990315619"></p><p><strong>步骤3:配置Spring的注解包扫描</strong></p><p>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>component-scan</p><ul><li>component:组件,Spring将管理的bean视作自己的一个组件</li><li>scan:扫描</li></ul><p>base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</p><ul><li>包路径越多[如:com.itheima.dao.impl]，扫描的范围越小速度越快</li><li>包路径越少[如:com.itheima],扫描的范围越大速度越慢</li><li>一般扫描到项目的组织名称即Maven的groupId下[如:com.itheima]即可。</li></ul><p><strong>步骤4：运行程序</strong></p><p>运行<code>App</code>类查看打印结果</p><p><img src="/.com//1630027590558-1719303975236-17-1719409838883-62.png" alt="1630027590558"></p><p><strong>步骤5:Service上添加注解</strong></p><p>在BookServiceImpl类上也添加<code>@Component</code>交给Spring框架管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤6:运行程序</strong></p><p>在App类中，从IOC容器中获取BookServiceImpl对应的bean对象，打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        <span class="comment">//按类型获取bean</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ctx.getBean(BookService.class);</span><br><span class="line">        System.out.println(bookService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印观察结果，两个bean对象都已经打印到控制台</p><p><img src="/.com//1630027743910-1719303975236-18-1719409838883-63.png" alt="1630027743910"></p><p><strong>说明:</strong></p><ul><li><p>BookServiceImpl类没有起名称，所以在App中是按照类型来获取bean对象</p></li><li><p>@Component注解如果不起名称，会有一个默认值就是<code>当前类名首字母小写</code>，所以也可以按照名称获取，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService)ctx.getBean(<span class="string">&quot;bookServiceImpl&quot;</span>);</span><br><span class="line">System.out.println(bookService);</span><br></pre></td></tr></table></figure></li></ul><p>对于@Component注解，还衍生出了其他三个注解<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code></p><p>通过查看源码会发现:</p><p><img src="/.com//1630028345074-1719303975236-19-1719409838883-64.png" alt="1630028345074"></p><p>这三个注解和@Component注解的作用是一样的，为什么要衍生出这三个呢?</p><p>方便我们后期在编写类的时候能很好的区分出这个类是属于<code>表现层</code>、<code>业务层</code>还是<code>数据层</code>的类。</p><h4 id="知识点1-Component等"><a href="#知识点1-Component等" class="headerlink" title="知识点1:@Component等"></a>知识点1:@Component等</h4><table><thead><tr><th>名称</th><th>@Component&#x2F;@Controller&#x2F;@Service&#x2F;@Repository</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置该类为spring管理的bean</td></tr><tr><td>属性</td><td>value（默认）：定义bean的id</td></tr></tbody></table><h3 id="纯注解开发模式"><a href="#纯注解开发模式" class="headerlink" title="纯注解开发模式"></a>纯注解开发模式</h3><p>上面已经可以使用注解来配置bean,但是依然有用到配置文件，在配置文件中对包进行了扫描，Spring在3.0版已经支持纯注解开发</p><ul><li>Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道</li></ul><p>具体如何实现?</p><h4 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h4><p><strong>步骤1:创建配置类</strong></p><p>创建一个配置类<code>SpringConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>步骤2:标识该类为配置类</strong></p><p>在配置类上添加<code>@Configuration</code>注解，将其标识为一个配置类,替换<code>applicationContext.xml</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:用注解替换包扫描配置</strong></p><p>在配置类上添加包扫描注解<code>@ComponentScan</code>替换<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4:创建运行类并执行</strong></p><p>创建一个新的运行类<code>AppForAnnotation</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAnnotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ctx.getBean(BookService.class);</span><br><span class="line">        System.out.println(bookService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行AppForAnnotation,可以看到两个对象依然被获取成功</p><p><img src="/.com//1630029110506-1719303975236-20-1719409838883-68.png" alt="1630029110506"></p><p>至此，纯注解开发的方式就已经完成了，主要内容包括:</p><ul><li><p>Java类替换Spring核心配置文件</p><p><img src="/.com//1630029254372-1719303975236-21-1719409838883-65.png" alt="1630029254372"></p></li><li><p>@Configuration注解用于设定当前类为配置类</p></li><li><p>@ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载配置文件初始化容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="comment">//加载配置类初始化容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br></pre></td></tr></table></figure></li></ul><h4 id="知识点1：-Configuration"><a href="#知识点1：-Configuration" class="headerlink" title="知识点1：@Configuration"></a>知识点1：@Configuration</h4><table><thead><tr><th>名称</th><th>@Configuration</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置该类为spring配置类</td></tr><tr><td>属性</td><td>value（默认）：定义bean的id</td></tr></tbody></table><h4 id="知识点2：-ComponentScan"><a href="#知识点2：-ComponentScan" class="headerlink" title="知识点2：@ComponentScan"></a>知识点2：@ComponentScan</h4><table><thead><tr><th>名称</th><th>@ComponentScan</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td></tr><tr><td>属性</td><td>value（默认）：扫描路径，此路径可以逐层向下扫描</td></tr></tbody></table><p><strong>小结:</strong></p><p>这一节重点掌握的是使用注解完成Spring的bean管理，需要掌握的内容为:</p><ul><li>记住@Component、@Controller、@Service、@Repository这四个注解</li><li>applicationContext.xml中<code>&lt;context:component-san/&gt;</code>的作用是指定扫描包路径，注解为@ComponentScan</li><li>@Configuration标识该类为配置类，使用类替换applicationContext.xml文件</li><li>ClassPathXmlApplicationContext是加载XML配置文件</li><li>AnnotationConfigApplicationContext是加载配置类</li></ul><h3 id="注解开发bean作用范围与生命周期管理"><a href="#注解开发bean作用范围与生命周期管理" class="headerlink" title="注解开发bean作用范围与生命周期管理"></a>注解开发bean作用范围与生命周期管理</h3><p>使用注解已经完成了bean的管理，接下来按照前面所学习的内容，将通过配置实现的内容都换成对应的注解实现，包含两部分内容:<code>bean作用范围</code>和<code>bean生命周期</code>。</p><h4 id="环境准备-3"><a href="#环境准备-3" class="headerlink" title="环境准备"></a>环境准备</h4><p>老规矩，学习之前先来准备环境:</p><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加一个配置类<code>SpringConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加BookDao、BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建运行类App</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630031112993-1719303975236-22-1719409838883-66.png" alt="1630031112993"></p><h4 id="Bean的作用范围"><a href="#Bean的作用范围" class="headerlink" title="Bean的作用范围"></a>Bean的作用范围</h4><p>(1)先运行App类,在控制台打印两个一摸一样的地址，说明默认情况下bean是单例</p><p><img src="/.com//1630031192753-1719303975236-23-1719409838883-67.png" alt="1630031192753"></p><p>(2)要想将BookDaoImpl变成非单例，只需要在其类上添加<code>@scope</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="comment">//@Scope设置bean的作用范围</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行App类，打印结果:</p><p><img src="/.com//1630031808947-1719303975236-24-1719409838883-69.png" alt="1630031808947"></p><h5 id="知识点1：-Scope"><a href="#知识点1：-Scope" class="headerlink" title="知识点1：@Scope"></a>知识点1：@Scope</h5><table><thead><tr><th>名称</th><th>@Scope</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置该类创建对象的作用范围<br>可用于设置创建出的bean是否为单例对象</td></tr><tr><td>属性</td><td>value（默认）：定义bean作用范围，<br>默认值singleton（单例），可选值prototype（非单例）</td></tr></tbody></table><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>(1)在BookDaoImpl中添加两个方法，<code>init</code>和<code>destroy</code>,方法名可以任意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)如何对方法进行标识，哪个是初始化方法，哪个是销毁方法?</p><p>只需要在对应的方法上添加<code>@PostConstruct</code>和<code>@PreDestroy</code>注解即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">//在构造方法之后执行，替换 init-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span> <span class="comment">//在销毁方法之前执行,替换 destroy-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)要想看到两个方法执行，需要注意的是<code>destroy</code>只有在容器关闭的时候，才会执行，所以需要修改App的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">        ctx.close(); <span class="comment">//关闭容器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)运行App,类查看打印结果，证明init和destroy方法都被执行了。</p><p><img src="/.com//1630032385498-1719303975236-25-1719409838883-70.png" alt="1630032385498"></p><p><strong>注意:</strong>@PostConstruct和@PreDestroy注解如果找不到，需要导入下面的jar包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.annotation&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.3</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>找不到的原因是，从JDK9以后jdk中的javax.annotation包被移除了，这两个注解刚好就在这个包中。</p><h5 id="知识点1：-PostConstruct"><a href="#知识点1：-PostConstruct" class="headerlink" title="知识点1：@PostConstruct"></a>知识点1：@PostConstruct</h5><table><thead><tr><th>名称</th><th>@PostConstruct</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>方法上</td></tr><tr><td>作用</td><td>设置该方法为初始化方法</td></tr><tr><td>属性</td><td>无</td></tr></tbody></table><h5 id="知识点2：-PreDestroy"><a href="#知识点2：-PreDestroy" class="headerlink" title="知识点2：@PreDestroy"></a>知识点2：@PreDestroy</h5><table><thead><tr><th>名称</th><th>@PreDestroy</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>方法上</td></tr><tr><td>作用</td><td>设置该方法为销毁方法</td></tr><tr><td>属性</td><td>无</td></tr></tbody></table><p><strong>小结</strong></p><p><img src="/.com//1630033039358-1719303975236-26-1719409838883-71.png" alt="1630033039358"></p><h3 id="注解开发依赖注入"><a href="#注解开发依赖注入" class="headerlink" title="注解开发依赖注入"></a>注解开发依赖注入</h3><p>Spring为了使用注解简化开发，并没有提供<code>构造函数注入</code>、<code>setter注入</code>对应的注解，只提供了自动装配的注解实现。</p><h4 id="环境准备-4"><a href="#环境准备-4" class="headerlink" title="环境准备"></a>环境准备</h4><p>在学习之前，把案例环境介绍下:</p><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加一个配置类<code>SpringConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加BookDao、BookDaoImpl、BookService、BookServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建运行类App</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ctx.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630033604129-1719303975236-27-1719409838883-72.png" alt="1630033604129"></p><p>环境准备好后，运行后会发现有问题</p><p><img src="/.com//1630033710052-1719303975236-28-1719409838883-73.png" alt="1630033710052"></p><p>出现问题的原因是，在BookServiceImpl类中添加了BookDao的属性，并提供了setter方法，但是目前是没有提供配置注入BookDao的，所以bookDao对象为Null,调用其save方法就会报<code>控指针异常</code>。</p><h4 id="注解实现按照类型注入"><a href="#注解实现按照类型注入" class="headerlink" title="注解实现按照类型注入"></a>注解实现按照类型注入</h4><p>对于这个问题使用注解该如何解决?</p><p>(1) 在BookServiceImpl类的bookDao属性上添加<code>@Autowired</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  public void setBookDao(BookDao bookDao) &#123;</span></span><br><span class="line"><span class="comment">//        this.bookDao = bookDao;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>@Autowired可以写在属性上，也可也写在setter方法上，最简单的处理方式是<code>写在属性上并将setter方法删除掉</code></li><li>为什么setter方法可以删除呢?<ul><li>自动装配基于反射设计创建对象并通过暴力反射为私有属性进行设值</li><li>普通反射只能获取public修饰的内容</li><li>暴力反射除了获取public修饰的内容还可以获取private修改的内容</li><li>所以此处无需提供setter方法</li></ul></li></ul><p>(2)@Autowired是按照类型注入，那么对应BookDao接口如果有多个实现类，比如添加BookDaoImpl2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候再次运行App，就会报错</p><p><img src="/.com//../../../Typora%E7%AC%94%E8%AE%B0/Spring/1630034272959-1719303975236-29.png" alt="1630034272959"></p><p>此时，按照类型注入就无法区分到底注入哪个对象，解决方案:<code>按照名称注入</code></p><ul><li><p>先给两个Dao类分别起个名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository(&quot;bookDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...2&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就可以注入成功，但是得思考个问题: </p><ul><li><p>@Autowired是按照类型注入的，给BookDao的两个实现起了名称，它还是有两个bean对象，为什么不报错?</p></li><li><p>@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和Bean的名称匹配。因为变量名叫<code>bookDao</code>而容器中也有一个<code>booDao</code>，所以可以成功注入。</p></li><li><p>分析下面这种情况是否能完成注入呢?</p><p><img src="/.com//1630036236150-1719303975236-30-1719409838883-75.png" alt="1630036236150"></p></li><li><p>不行，因为按照类型会找到多个bean对象，此时会按照<code>bookDao</code>名称去找，因为IOC容器只有名称叫<code>bookDao1</code>和<code>bookDao2</code>,所以找不到，会报<code>NoUniqueBeanDefinitionException</code></p></li></ul></li></ul><h4 id="注解实现按照名称注入"><a href="#注解实现按照名称注入" class="headerlink" title="注解实现按照名称注入"></a>注解实现按照名称注入</h4><p>当根据类型在容器中找到多个bean,注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;bookDao1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Qualifier注解后的值就是需要注入的bean的名称。</p><p>注意:@Qualifier不能独立使用，必须和@Autowired一起使用</p><h4 id="简单数据类型注入"><a href="#简单数据类型注入" class="headerlink" title="简单数据类型注入"></a>简单数据类型注入</h4><p>引用类型看完，简单类型注入就比较容易懂了。简单类型注入的是基本数据类型或者字符串类型，下面在<code>BookDaoImpl</code>类中添加一个<code>name</code>属性，用其进行简单类型注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据类型换了，对应的注解也要跟着换，这次使用<code>@Value</code>注解，将值写入注解的参数中就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;itheima&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意数据格式要匹配，如将”abc”注入给int值，这样程序就会报错。</p><p>介绍完后，会有一种感觉就是这个注解好像没什么用，跟直接赋值是一个效果，还没有直接赋值简单，所以这个注解存在的意义是什么?</p><h4 id="注解读取properties配置文件"><a href="#注解读取properties配置文件" class="headerlink" title="注解读取properties配置文件"></a>注解读取properties配置文件</h4><p><code>@Value</code>一般会被用在从properties配置文件中读取内容进行使用，具体如何实现?</p><p><strong>步骤1：resource下准备properties文件</strong></p><p>jdbc.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">itheima888</span></span><br></pre></td></tr></table></figure><p><strong>步骤2: 使用注解加载properties配置文件</strong></p><p>在配置类上添加<code>@PropertySource</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3：使用@Value读取配置文件中的内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤4:运行程序</p><p>运行App类，查看运行结果，说明配置文件中的内容已经被加载到</p><p><img src="/.com//1630084683663-1719303975236-31-1719409838883-76.png" alt="1630084683663"></p><p><strong>注意:</strong></p><ul><li><p>如果读取的properties配置文件有多个，可以使用<code>@PropertySource</code>的属性来指定多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;xxx.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p><code>@PropertySource</code>注解属性中不支持使用通配符<code>*</code>,运行会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;*.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p><code>@PropertySource</code>注解属性中可以把<code>classpath:</code>加上,代表从当前项目的根路径找文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="知识点1：-Autowired"><a href="#知识点1：-Autowired" class="headerlink" title="知识点1：@Autowired"></a>知识点1：@Autowired</h4><table><thead><tr><th>名称</th><th>@Autowired</th></tr></thead><tbody><tr><td>类型</td><td>属性注解  或  方法注解（了解）  或  方法形参注解（了解）</td></tr><tr><td>位置</td><td>属性定义上方  或  标准set方法上方  或  类set方法上方  或  方法形参前面</td></tr><tr><td>作用</td><td>为引用类型属性设置值</td></tr><tr><td>属性</td><td>required：true&#x2F;false，定义该属性是否允许为null</td></tr></tbody></table><h4 id="知识点2：-Qualifier"><a href="#知识点2：-Qualifier" class="headerlink" title="知识点2：@Qualifier"></a>知识点2：@Qualifier</h4><table><thead><tr><th>名称</th><th>@Qualifier</th></tr></thead><tbody><tr><td>类型</td><td>属性注解  或  方法注解（了解）</td></tr><tr><td>位置</td><td>属性定义上方  或  标准set方法上方  或  类set方法上方</td></tr><tr><td>作用</td><td>为引用类型属性指定注入的beanId</td></tr><tr><td>属性</td><td>value（默认）：设置注入的beanId</td></tr></tbody></table><h4 id="知识点3：-Value"><a href="#知识点3：-Value" class="headerlink" title="知识点3：@Value"></a>知识点3：@Value</h4><table><thead><tr><th>名称</th><th>@Value</th></tr></thead><tbody><tr><td>类型</td><td>属性注解  或  方法注解（了解）</td></tr><tr><td>位置</td><td>属性定义上方  或  标准set方法上方  或  类set方法上方</td></tr><tr><td>作用</td><td>为  基本数据类型  或  字符串类型  属性设置值</td></tr><tr><td>属性</td><td>value（默认）：要注入的属性值</td></tr></tbody></table><h4 id="知识点4：-PropertySource"><a href="#知识点4：-PropertySource" class="headerlink" title="知识点4：@PropertySource"></a>知识点4：@PropertySource</h4><table><thead><tr><th>名称</th><th>@PropertySource</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>加载properties文件中的属性值</td></tr><tr><td>属性</td><td>value（默认）：设置加载的properties文件对应的文件名或文件名组成的数组</td></tr></tbody></table><h2 id="IOC-DI注解开发管理第三方bean"><a href="#IOC-DI注解开发管理第三方bean" class="headerlink" title="IOC&#x2F;DI注解开发管理第三方bean"></a>IOC&#x2F;DI注解开发管理第三方bean</h2><p>前面定义bean的时候都是在自己开发的类上面写个注解就完成了，但如果是第三方的类，这些类都是在jar包中，我们没有办法在类上面添加注解，这个时候该怎么办?</p><p>遇到上述问题，我们就需要有一种更加灵活的方式来定义bean,这种方式不能在原始代码上面书写注解，一样能定义bean,这就用到了一个全新的注解@Bean。</p><p>这个注解该如何使用呢?</p><p>咱们把之前使用配置方式管理的数据源使用注解再来一遍，通过这个案例来学习下@Bean的使用。</p><h3 id="环境准备-5"><a href="#环境准备-5" class="headerlink" title="环境准备"></a>环境准备</h3><p>学习@Bean注解之前先来准备环境:</p><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加一个配置类<code>SpringConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加BookDao、BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建运行类App</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630122466404-1719303975236-32-1719409838883-77.png" alt="1630122466404"></p><h3 id="注解开发管理第三方bean"><a href="#注解开发管理第三方bean" class="headerlink" title="注解开发管理第三方bean"></a>注解开发管理第三方bean</h3><p>在上述环境中完成对<code>Druid</code>数据源的管理，具体的实现步骤为:</p><p><strong>步骤1:导入对应的jar包</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤2:在配置类中添加一个方法</strong></p><p>注意该方法的返回值就是要创建的Bean对象类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:在方法上添加<code>@Bean</code>注解</strong></p><p>@Bean注解的作用是将方法的返回值制作为Spring管理的一个bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:不能使用<code>DataSource ds = new DruidDataSource()</code></strong></p><p>因为DataSource接口中没有对应的setter方法来设置属性。</p><p><strong>步骤4:从IOC容器中获取对象并打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> ctx.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此使用@Bean来管理第三方bean的案例就已经完成。</p><p>如果有多个bean要被Spring管理，直接在配置类中多些几个方法，方法上添加@Bean注解即可。</p><h3 id="引入外部配置类"><a href="#引入外部配置类" class="headerlink" title="引入外部配置类"></a>引入外部配置类</h3><p>如果把所有的第三方bean都配置到Spring的配置类<code>SpringConfig</code>中，虽然可以，但是不利于代码阅读和分类管理，所有我们就想能不能按照类别将这些bean配置到不同的配置类中?</p><p>对于数据源的bean,我们新建一个<code>JdbcConfig</code>配置类，并把数据源配置到该类下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的问题是，这个配置类如何能被Spring配置类加载到，并创建DataSource对象在IOC容器中?</p><p>针对这个问题，有两个解决方案:</p><h4 id="使用包扫描引入"><a href="#使用包扫描引入" class="headerlink" title="使用包扫描引入"></a>使用包扫描引入</h4><p><strong>步骤1:在Spring的配置类上添加包扫描</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.config&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:在JdbcConfig上添加配置注解</strong></p><p>JdbcConfig类要放入到<code>com.itheima.config</code>包下，需要被Spring的配置类扫描到即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:运行程序</strong></p><p>依然能获取到bean对象并打印控制台。</p><p>这种方式虽然能够扫描到，但是不能很快的知晓都引入了哪些配置类，所有这种方式不推荐使用。</p><h4 id="使用-Import引入"><a href="#使用-Import引入" class="headerlink" title="使用@Import引入"></a>使用<code>@Import</code>引入</h4><p>方案一实现起来有点小复杂，Spring早就想到了这一点，于是又给我们提供了第二种方案。</p><p>这种方案可以不用加<code>@Configuration</code>注解，但是必须在Spring配置类上使用<code>@Import</code>注解手动引入需要加载的配置类</p><p><strong>步骤1:去除JdbcConfig类上的注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:在Spring配置类中引入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@ComponentScan(&quot;com.itheima.config&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><p>扫描注解可以移除</p></li><li><p>@Import参数需要的是一个数组，可以引入多个配置类。</p></li><li><p>@Import注解在配置类中只能写一次，下面的方式是不允许的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@ComponentScan(&quot;com.itheima.config&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="meta">@Import(Xxx.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>步骤3:运行程序</strong></p><p>依然能获取到bean对象并打印控制台</p><h3 id="知识点1：-Bean"><a href="#知识点1：-Bean" class="headerlink" title="知识点1：@Bean"></a>知识点1：@Bean</h3><table><thead><tr><th>名称</th><th>@Bean</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>方法定义上方</td></tr><tr><td>作用</td><td>设置该方法的返回值作为spring管理的bean</td></tr><tr><td>属性</td><td>value（默认）：定义bean的id</td></tr></tbody></table><h3 id="知识点2：-Import"><a href="#知识点2：-Import" class="headerlink" title="知识点2：@Import"></a>知识点2：@Import</h3><table><thead><tr><th>名称</th><th>@Import</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>导入配置类</td></tr><tr><td>属性</td><td>value（默认）：定义导入的配置类类名，<br>当配置类有多个时使用数组格式一次性导入多个配置类</td></tr></tbody></table><h3 id="注解开发实现为第三方bean注入资源"><a href="#注解开发实现为第三方bean注入资源" class="headerlink" title="注解开发实现为第三方bean注入资源"></a>注解开发实现为第三方bean注入资源</h3><p>在使用@Bean创建bean对象的时候，如果方法在创建的过程中需要其他资源该怎么办?</p><p>这些资源会有两大类，分别是<code>简单数据类型</code> 和<code>引用数据类型</code>。</p><h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><h5 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h5><p>对于下面代码关于数据库的四要素不应该写死在代码中，应该是从properties配置文件中读取。如何来优化下面的代码?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注入简单数据类型步骤"><a href="#注入简单数据类型步骤" class="headerlink" title="注入简单数据类型步骤"></a>注入简单数据类型步骤</h5><p><strong>步骤1:类中提供四个属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:使用<code>@Value</code>注解引入值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc:mysql://localhost:3306/spring_db&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;password&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h6><p>现在的数据库连接四要素还是写在代码中，需要做的是将这些内容提</p><p>取到jdbc.properties配置文件，大家思考下该如何实现?</p><blockquote><p>1.resources目录下添加jdbc.properties</p><p>2.配置文件中提供四个键值对分别是数据库的四要素</p><p>3.使用@PropertySource加载jdbc.properties配置文件</p><p>4.修改@Value注解属性的值，将其修改为<code>$&#123;key&#125;</code>，key就是键值对中的键的值</p></blockquote><p>具体的实现就交由大家自行实现下。</p><h4 id="引用数据类型-1"><a href="#引用数据类型-1" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><h5 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h5><p>假设在构建DataSource对象的时候，需要用到BookDao对象，该如何把BookDao对象注入进方法内让其使用呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注入引用数据类型步骤"><a href="#注入引用数据类型步骤" class="headerlink" title="注入引用数据类型步骤"></a>注入引用数据类型步骤</h5><p><strong>步骤1:在SpringConfig中扫描BookDao</strong></p><p>扫描的目的是让Spring能管理到BookDao,也就是说要让IOC容器中有一个bookDao对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.dao&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:在JdbcConfig类的方法上添加参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(BookDao bookDao)</span>&#123;</span><br><span class="line">    System.out.println(bookDao);</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setDriverClassName(driver);</span><br><span class="line">    ds.setUrl(url);</span><br><span class="line">    ds.setUsername(userName);</span><br><span class="line">    ds.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象。</p><p><strong>步骤3:运行程序</strong></p><p><img src="/.com//1630125475609-1719303975237-33-1719409838883-78.png" alt="1630125475609"></p><h2 id="注解开发总结"><a href="#注解开发总结" class="headerlink" title="注解开发总结"></a>注解开发总结</h2><p>前面我们已经完成了XML配置和注解的开发实现，至于两者之间的差异，咱们放在一块去对比回顾下:</p><p><img src="/.com//../../../Typora%E7%AC%94%E8%AE%B0/Spring/1630134786448-1719303975237-34.png" alt="1630134786448"></p><h2 id="Spring整合"><a href="#Spring整合" class="headerlink" title="Spring整合"></a>Spring整合</h2><p>课程学习到这里，已经对Spring有一个简单的认识了，Spring有一个容器，叫做IoC容器，里面保存bean。在进行企业级开发的时候，其实除了将自己写的类让Spring管理之外，还有一部分重要的工作就是使用第三方的技术。前面已经讲了如何管理第三方bean了，下面结合IoC和DI，整合2个常用技术，进一步加深对Spring的使用理解。</p><h3 id="Spring整合Mybatis"><a href="#Spring整合Mybatis" class="headerlink" title="Spring整合Mybatis"></a>Spring整合Mybatis</h3><p>前面我们已经分析了Spring与Mybatis的整合，大体需要做两件事，</p><p>第一件事是:Spring要管理MyBatis中的SqlSessionFactory</p><p>第二件事是:Spring要管理Mapper接口的扫描</p><p>具体该如何实现，具体的步骤为:</p><p><strong>步骤1:项目中导入整合需要的jar包</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring操作数据库需要该jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">Spring与Mybatis整合的jar包</span></span><br><span class="line"><span class="comment">这个jar包mybatis在前面，是Mybatis提供的</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤2:创建Spring的主配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置类注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//包扫描，主要扫描的是项目中的AccountServiceImpl类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:创建数据源的配置类</strong></p><p>在配置类中完成数据源的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4:主配置类中读properties并引入数据源配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤5:创建Mybatis配置类并配置SqlSessionFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="comment">//定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置模型类的别名扫描</span></span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);</span><br><span class="line">        <span class="comment">//设置数据源</span></span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义bean，返回MapperScannerConfigurer对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><p>使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息</p><p><img src="/.com//1630138835057-1719303975237-38-1719409838883-80.png" alt="1630138835057"></p><ul><li>SqlSessionFactoryBean是前面我们讲解FactoryBean的一个子类，在该类中将SqlSessionFactory的创建进行了封装，简化对象的创建，我们只需要将其需要的内容设置即可。</li><li>方法中有一个参数为dataSource,当前Spring容器中已经创建了Druid数据源，类型刚好是DataSource类型，此时在初始化SqlSessionFactoryBean这个对象的时候，发现需要使用DataSource对象，而容器中刚好有这么一个对象，就自动加载了DruidDataSource对象。</li></ul></li><li><p>使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中</p><p><img src="/.com//1630138916939-1719303975237-39-1719409838883-81.png" alt="1630138916939"></p><ul><li>这个MapperScannerConfigurer对象也是MyBatis提供的专用于整合的jar包中的类，用来处理原始配置文件中的mappers相关配置，加载数据层的Mapper接口类</li><li>MapperScannerConfigurer有一个核心属性basePackage，就是用来设置所扫描的包路径</li></ul></li></ul><p><strong>步骤6:主配置类中引入Mybatis配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤7:编写运行类</strong></p><p>在运行类中，从IOC容器中获取Service对象，调用方法获取结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> ctx.getBean(AccountService.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountService.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤8:运行程序</strong></p><p><img src="/.com//1630139036627-1719303975237-40-1719409838883-82.png" alt="1630139036627"></p><p>支持Spring与Mybatis的整合就已经完成了，其中主要用到的两个类分别是:</p><ul><li>SqlSessionFactoryBean</li><li>MapperScannerConfigurer</li></ul><h3 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h3><p>整合Junit与整合Druid和MyBatis差异比较大，为什么呢？Junit是一个搞单元测试用的工具，它不是我们程序的主体，也不会参加最终程序的运行，从作用上来说就和之前的东西不一样，它不是做功能的，看做是一个辅助工具就可以了。</p><h4 id="环境准备-6"><a href="#环境准备-6" class="headerlink" title="环境准备"></a>环境准备</h4><p>这块环境，大家可以直接使用Spring与Mybatis整合的环境即可。当然也可以重新创建一个，因为内容是一模一样，所以我们直接来看下项目结构即可:</p><p><img src="/.com//1630139720273-1719303975237-41-1719409838883-84.png" alt="1630139720273"></p><h4 id="整合Junit步骤"><a href="#整合Junit步骤" class="headerlink" title="整合Junit步骤"></a>整合Junit步骤</h4><p>在上述环境的基础上，我们来对Junit进行整合。</p><p><strong>步骤1:引入依赖</strong></p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤2:编写测试类</strong></p><p>在test\java下创建一个AccountServiceTest,这个名字任意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置类运行器</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//设置Spring环境对应的配置类</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span> <span class="comment">//加载配置类</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(locations=&#123;&quot;classpath:applicationContext.xml&quot;&#125;)//加载配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTest</span> &#123;</span><br><span class="line">    <span class="comment">//支持自动装配注入bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(accountService.findById(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(accountService.findAll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>单元测试，如果测试的是注解配置类，则使用<code>@ContextConfiguration(classes = 配置类.class)</code></li><li>单元测试，如果测试的是配置文件，则使用<code>@ContextConfiguration(locations=&#123;配置文件名,...&#125;)</code></li><li>Junit运行后是基于Spring环境运行的，所以Spring提供了一个专用的类运行器，这个务必要设置，这个类运行器就在Spring的测试专用包中提供的，导入的坐标就是这个东西<code>SpringJUnit4ClassRunner</code></li><li>上面两个配置都是固定格式，当需要测试哪个bean时，使用自动装配加载对应的对象，下面的工作就和以前做Junit单元测试完全一样了</li></ul><h4 id="知识点1：-RunWith"><a href="#知识点1：-RunWith" class="headerlink" title="知识点1：@RunWith"></a>知识点1：@RunWith</h4><table><thead><tr><th>名称</th><th>@RunWith</th></tr></thead><tbody><tr><td>类型</td><td>测试类注解</td></tr><tr><td>位置</td><td>测试类定义上方</td></tr><tr><td>作用</td><td>设置JUnit运行器</td></tr><tr><td>属性</td><td>value（默认）：运行所使用的运行期</td></tr></tbody></table><h4 id="知识点2：-ContextConfiguration"><a href="#知识点2：-ContextConfiguration" class="headerlink" title="知识点2：@ContextConfiguration"></a>知识点2：@ContextConfiguration</h4><table><thead><tr><th>名称</th><th>@ContextConfiguration</th></tr></thead><tbody><tr><td>类型</td><td>测试类注解</td></tr><tr><td>位置</td><td>测试类定义上方</td></tr><tr><td>作用</td><td>设置JUnit加载的Spring核心配置</td></tr><tr><td>属性</td><td>classes：核心配置类，可以使用数组的格式设定加载多个配置类<br>locations:配置文件，可以使用数组的格式设定加载多个配置文件名称</td></tr></tbody></table><h2 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h2><p>前面我们在介绍Spring的时候说过，Spring有两个核心的概念，一个是<code>IOC/DI</code>，一个是<code>AOP</code>。</p><p>前面已经对<code>IOC/DI</code>进行了系统的学习，接下来要学习它的另一个核心内容，就是&#x3D;&#x3D;AOP&#x3D;&#x3D;。</p><p>对于AOP,我们前面提过一句话是:&#x3D;&#x3D;AOP是在不改原有代码的前提下对其进行增强。&#x3D;&#x3D;</p><p>对于下面的内容，我们主要就是围绕着这一句话进行展开学习，主要学习两方面内容<code>AOP核心概念</code>,<code>AOP作用</code>:</p><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP?"></a>什么是AOP?</h3><ul><li>AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构。</li><li>OOP(Object Oriented Programming)面向对象编程</li></ul><p>我们都知道OOP是一种编程思想，那么AOP也是一种编程思想，编程思想主要的内容就是指导程序员该如何编写程序，所以它们两个是不同的<code>编程范式</code>。</p><h3 id="AOP作用"><a href="#AOP作用" class="headerlink" title="AOP作用"></a>AOP作用</h3><p>作用:在不惊动原始设计的基础上为其进行功能增强，前面咱们有技术就可以实现这样的功能即代理模式。</p><p>前面咱们有技术就可以实现这样的功能即<code>代理模式</code>。</p><h3 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><p>为了能更好的理解AOP的相关概念，我们准备了一个环境，整个环境的内容我们暂时可以不用关注，最主要的类为:<code>BookDaoImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//记录程序当前执行执行（开始时间）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//业务执行万次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录程序当前执行时间（结束时间）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//计算时间差</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">totalTime</span> <span class="operator">=</span> endTime-startTime;</span><br><span class="line">        <span class="comment">//输出信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行万次消耗时间：&quot;</span> + totalTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao update ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao delete ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao select ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的内容相信大家都能够读懂，对于<code>save</code>方法中有计算万次执行消耗的时间。</p><p>当在App类中从容器中获取bookDao对象后，分别执行其<code>save</code>,<code>delete</code>,<code>update</code>和<code>select</code>方法后会有如下的打印结果:</p><p><img src="/.com//../../../Typora%E7%AC%94%E8%AE%B0/Spring/1630143927489.png" alt="1630143927489"></p><p>这个时候，我们就应该有些疑问?</p><ul><li>对于计算万次执行消耗的时间只有save方法有，为什么delete和update方法也会有呢?</li><li>delete和update方法有，那什么select方法为什么又没有呢?</li></ul><p>这个案例中其实就使用了Spring的AOP，在不惊动(改动)原有设计(代码)的前提下，想给谁添加功能就给谁添加。这个也就是Spring的理念：</p><ul><li>无入侵式&#x2F;无侵入式</li></ul><p>说了这么多，Spring到底是如何实现的呢?</p><p><img src="/.com//1630144353462-1719409838883-85.png" alt="1630144353462"></p><p>(1)前面一直在强调，Spring的AOP是对一个类的方法在不进行任何修改的前提下实现增强。对于上面的案例中BookServiceImpl中有<code>save</code>,<code>update</code>,<code>delete</code>和<code>select</code>方法,这些方法我们给起了一个名字叫&#x3D;&#x3D;连接点&#x3D;&#x3D;</p><p>(2)在BookServiceImpl的四个方法中，<code>update</code>和<code>delete</code>只有打印没有计算万次执行消耗时间，但是在运行的时候已经有该功能，那也就是说<code>update</code>和<code>delete</code>方法都已经被增强，所以对于需要增强的方法我们给起了一个名字叫&#x3D;&#x3D;切入点&#x3D;&#x3D;</p><p>(3)执行BookServiceImpl的update和delete方法的时候都被添加了一个计算万次执行消耗时间的功能，将这个功能抽取到一个方法中，换句话说就是存放共性功能的方法，我们给起了个名字叫&#x3D;&#x3D;通知&#x3D;&#x3D;</p><p>(4)通知是要增强的内容，会有多个，切入点是需要被增强的方法，也会有多个，那哪个切入点需要添加哪个通知，就需要提前将它们之间的关系描述清楚，那么对于通知和切入点之间的关系描述，我们给起了个名字叫&#x3D;&#x3D;切面&#x3D;&#x3D;</p><p>(5)通知是一个方法，方法不能独立存在需要被写在一个类中，这个类我们也给起了个名字叫&#x3D;&#x3D;通知类&#x3D;&#x3D;</p><p>至此AOP中的核心概念就已经介绍完了，总结下:</p><ul><li>连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等<ul><li>在SpringAOP中，理解为方法的执行</li></ul></li><li>切入点(Pointcut):匹配连接点的式子<ul><li>在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法<ul><li>一个具体的方法:如com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法</li><li>匹配多个方法:所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法</li></ul></li><li>连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点。</li></ul></li><li>通知(Advice):在切入点处执行的操作，也就是共性功能<ul><li>在SpringAOP中，功能最终以方法的形式呈现</li></ul></li><li>通知类：定义通知的类</li><li>切面(Aspect):描述通知与切入点的对应关系。</li></ul><p><strong>小结</strong></p><p>这一节中主要讲解了AOP的概念与作用，以及AOP中的核心概念，学完以后大家需要能说出:</p><ul><li>什么是AOP?</li><li>AOP的作用是什么?</li><li>AOP中核心概念分别指的是什么?<ul><li>连接点</li><li>切入点</li><li>通知</li><li>通知类</li><li>切面</li></ul></li></ul><h2 id="AOP入门案例"><a href="#AOP入门案例" class="headerlink" title="AOP入门案例"></a>AOP入门案例</h2><h3 id="需求分析-2"><a href="#需求分析-2" class="headerlink" title="需求分析"></a>需求分析</h3><p>案例设定：测算接口执行效率，但是这个案例稍微复杂了点，我们对其进行简化。</p><p>简化设定：在方法执行前输出当前系统时间。</p><p>对于SpringAOP的开发有两种方式，XML 和 &#x3D;&#x3D;注解&#x3D;&#x3D;，我们使用哪个呢?</p><p>因为现在注解使用的比较多，所以本次课程就采用注解完成AOP的开发。</p><p>总结需求为:使用SpringAOP的注解方式完成在方法执行的前打印出当前系统时间。</p><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>需求明确后，具体该如何实现，都有哪些步骤，我们先来分析下:</p><blockquote><p>1.导入坐标(pom.xml)</p><p>2.制作连接点(原始操作，Dao接口与实现类)</p><p>3.制作共性功能(通知类与通知)</p><p>4.定义切入点</p><p>5.绑定切入点与通知关系(切面)</p></blockquote><h3 id="环境准备-7"><a href="#环境准备-7" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加BookDao和BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao update ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写App运行类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630167092142-1719409838883-86.png" alt="1630167092142"></p><p><strong>说明:</strong></p><ul><li>目前打印save方法的时候，因为方法中有打印系统时间，所以运行的时候是可以看到系统时间</li><li>对于update方法来说，就没有该功能</li><li>我们要使用SpringAOP的方式在不改变update方法的前提下让其具有打印系统时间的功能。</li></ul><h3 id="AOP实现步骤"><a href="#AOP实现步骤" class="headerlink" title="AOP实现步骤"></a>AOP实现步骤</h3><p><strong>步骤1:添加依赖</strong></p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/.com//1630146885493-1719409838883-87.png" alt="1630146885493"></p><ul><li>因为<code>spring-context</code>中已经导入了<code>spring-aop</code>,所以不需要再单独导入<code>spring-aop</code></li><li>导入AspectJ的jar包,AspectJ是AOP思想的一个具体实现，Spring有自己的AOP实现，但是相比于AspectJ来说比较麻烦，所以我们直接采用Spring整合ApsectJ的方式进行AOP开发。</li></ul><p><strong>步骤2:定义接口与实现类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环境准备的时候，BookDaoImpl已经准备好，不需要做任何修改</span><br></pre></td></tr></table></figure><p><strong>步骤3:定义通知类和通知</strong></p><p>通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类名和方法名没有要求，可以任意。</p><p><strong>步骤4:定义切入点</strong></p><p>BookDaoImpl中有两个方法，分别是save和update，我们要增强的是update方法，该如何定义呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>切入点定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑。</li><li>execution及后面编写的内容，后面会有章节专门去学习。</li></ul><p><strong>步骤5:制作切面</strong></p><p>切面是用来描述通知和切入点之间的关系，如何进行关系的绑定?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行&#x3D;&#x3D;位置&#x3D;&#x3D;</p><p><img src="/.com//1630148447689-1719409838883-88.png" alt="1630148447689"></p><p><strong>说明:</strong>@Before翻译过来是之前，也就是说通知会在切入点方法执行之前执行，除此之前还有其他四种类型，后面会讲。</p><p><strong>步骤6:将通知类配给容器并标识其为切面类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤7:开启注解格式AOP功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤8:运行程序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        bookDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到在执行update方法之前打印了系统时间戳，说明对原始方法进行了增强，AOP编程成功。</p><p><img src="/.com//1630147945888-1719409838883-89.png" alt="1630147945888"></p><h3 id="知识点1：-EnableAspectJAutoProxy"><a href="#知识点1：-EnableAspectJAutoProxy" class="headerlink" title="知识点1：@EnableAspectJAutoProxy"></a>知识点1：@EnableAspectJAutoProxy</h3><table><thead><tr><th>名称</th><th>@EnableAspectJAutoProxy</th></tr></thead><tbody><tr><td>类型</td><td>配置类注解</td></tr><tr><td>位置</td><td>配置类定义上方</td></tr><tr><td>作用</td><td>开启注解格式AOP功能</td></tr></tbody></table><h3 id="知识点2：-Aspect"><a href="#知识点2：-Aspect" class="headerlink" title="知识点2：@Aspect"></a>知识点2：@Aspect</h3><table><thead><tr><th>名称</th><th>@Aspect</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>切面类定义上方</td></tr><tr><td>作用</td><td>设置当前类为AOP切面类</td></tr></tbody></table><h3 id="知识点3：-Pointcut"><a href="#知识点3：-Pointcut" class="headerlink" title="知识点3：@Pointcut"></a>知识点3：@Pointcut</h3><table><thead><tr><th>名称</th><th>@Pointcut</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>切入点方法定义上方</td></tr><tr><td>作用</td><td>设置切入点方法</td></tr><tr><td>属性</td><td>value（默认）：切入点表达式</td></tr></tbody></table><h3 id="知识点4：-Before"><a href="#知识点4：-Before" class="headerlink" title="知识点4：@Before"></a>知识点4：@Before</h3><table><thead><tr><th>名称</th><th>@Before</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</td></tr></tbody></table><h2 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h2><p>AOP的入门案例已经完成，对于刚才案例的执行过程，我们就得来分析分析，这一节我们主要讲解两个知识点:<code>AOP工作流程</code>和<code>AOP核心概念</code>。其中核心概念是对前面核心概念的补充。</p><h3 id="AOP工作流程-1"><a href="#AOP工作流程-1" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h3><p>由于AOP是基于Spring容器管理的bean做的增强，所以整个工作过程需要从Spring加载bean说起:</p><p><strong>流程1:Spring容器启动</strong></p><ul><li>容器启动就需要去加载bean,哪些类需要被加载呢?</li><li>需要被增强的类，如:BookServiceImpl</li><li>通知类，如:MyAdvice</li><li>注意此时bean对象还没有创建成功</li></ul><p><strong>流程2:读取所有切面配置中的切入点</strong></p><p><img src="/.com//1630151682428-1719409838883-90.png" alt="1630151682428"></p><ul><li>上面这个例子中有两个切入点的配置，但是第一个<code>ptx()</code>并没有被使用，所以不会被读取。</li></ul><p><strong>流程3:初始化bean</strong></p><p>判定bean对应的类中的方法是否匹配到任意切入点</p><ul><li><p>注意第1步在容器启动的时候，bean对象还没有被创建成功。</p></li><li><p>要被实例化bean对象的类中的方法和切入点进行匹配</p><p><img src="/.com//1630152538083-1719409838883-91.png" alt="1630152538083"></p><ul><li>匹配失败，创建原始对象,如<code>UserDao</code><ul><li>匹配失败说明不需要增强，直接调用原始对象的方法即可。</li></ul></li><li>匹配成功，创建原始对象（&#x3D;&#x3D;目标对象&#x3D;&#x3D;）的&#x3D;&#x3D;代理&#x3D;&#x3D;对象,如:<code>BookDao</code><ul><li>匹配成功说明需要对其进行增强</li><li>对哪个类做增强，这个类对应的对象就叫做目标对象</li><li>因为要对目标对象进行功能增强，而采用的技术是动态代理，所以会为其创建一个代理对象</li><li>最终运行的是代理对象的方法，在该方法中会对原始方法进行功能增强</li></ul></li></ul></li></ul><p><strong>流程4:获取bean执行方法</strong></p><ul><li>获取的bean是原始对象时，调用方法并执行，完成操作</li><li>获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li></ul><h4 id="验证容器中是否为代理对象"><a href="#验证容器中是否为代理对象" class="headerlink" title="验证容器中是否为代理对象"></a>验证容器中是否为代理对象</h4><p>为了验证IOC容器中创建的对象和我们刚才所说的结论是否一致，首先先把结论理出来:</p><ul><li>如果目标对象中的方法会被增强，那么容器中将存入的是目标对象的代理对象</li><li>如果目标对象中的方法不被增强，那么容器中将存入的是目标对象本身。</li></ul><h5 id="验证思路-1"><a href="#验证思路-1" class="headerlink" title="验证思路"></a>验证思路</h5><blockquote><p>1.要执行的方法，不被定义的切入点包含，即不要增强，打印当前类的getClass()方法</p><p>2.要执行的方法，被定义的切入点包含，即要增强，打印出当前类的getClass()方法</p><p>3.观察两次打印的结果</p></blockquote><p><strong>步骤1:修改App类,获取类的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        System.out.println(bookDao.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:修改MyAdvice类，不增强</strong></p><p>因为定义的切入点中，被修改成<code>update1</code>,所以BookDao中的update方法在执行的时候，就不会被增强，</p><p>所以容器中的对象应该是目标对象本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update1())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:运行程序</strong></p><p><img src="/.com//1630154495165-1719409838883-92.png" alt="1630154495165"></p><p><strong>步骤4:修改MyAdvice类，增强</strong></p><p>因为定义的切入点中，被修改成<code>update</code>,所以BookDao中的update方法在执行的时候，就会被增强，</p><p>所以容器中的对象应该是目标对象的代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤5:运行程序</strong></p><p><img src="/.com//1630154625564-1719409838883-93.png" alt="1630154625564"></p><p>至此对于刚才的结论，我们就得到了验证，这块大家需要注意的是:</p><p>不能直接打印对象，从上面两次结果中可以看出，直接打印对象走的是对象的toString方法，不管是不是代理对象打印的结果都是一样的，原因是内部对toString方法进行了重写。</p><h3 id="AOP核心概念-1"><a href="#AOP核心概念-1" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><p>在上面介绍AOP的工作流程中，我们提到了两个核心概念，分别是:</p><ul><li>目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的</li><li>代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</li></ul><p>上面这两个概念比较抽象，简单来说，</p><p>目标对象就是要增强的类[如:BookServiceImpl类]对应的对象，也叫原始对象，不能说它不能运行，只能说它在运行的过程中对于要增强的内容是缺失的。</p><p>SpringAOP是在不改变原有设计(代码)的前提下对其进行增强的，它的底层采用的是代理模式实现的，所以要对原始对象进行增强，就需要对原始对象创建代理对象，在代理对象中的方法把通知[如:MyAdvice中的method方法]内容加进去，就实现了增强,这就是我们所说的代理(Proxy)。</p><p><strong>小结</strong></p><p>通过这一节中，我们需要掌握的内容有：</p><ul><li>能说出AOP的工作流程</li><li>AOP的核心概念<ul><li>目标对象、连接点、切入点</li><li>通知类、通知</li><li>切面</li><li>代理</li></ul></li><li>SpringAOP的本质或者可以说底层实现是通过代理模式。</li></ul><h2 id="AOP配置管理"><a href="#AOP配置管理" class="headerlink" title="AOP配置管理"></a>AOP配置管理</h2><h3 id="AOP切入点表达式"><a href="#AOP切入点表达式" class="headerlink" title="AOP切入点表达式"></a>AOP切入点表达式</h3><p>前面的案例中，有涉及到如下内容:</p><p><img src="/.com//1630155937718-1719409838883-94.png" alt="1630155937718"></p><p>对于AOP中切入点表达式，我们总共会学习三个内容，分别是<code>语法格式</code>、<code>通配符</code>和<code>书写技巧</code>。</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><p>首先我们先要明确两个概念:</p><ul><li>切入点:要进行增强的方法</li><li>切入点表达式:要进行增强的方法的描述方式</li></ul><p>对于切入点的描述，我们其实是有两中方式的，先来看下前面的例子</p><p><img src="/.com//1630156172790-1719409838883-95.png" alt="1630156172790"></p><p>描述方式一：执行com.itheima.dao包下的BookDao接口中的无参数update方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">void</span> com.itheima.dao.BookDao.update())</span><br></pre></td></tr></table></figure><p>描述方式二：执行com.itheima.dao.impl包下的BookDaoImpl类中的无参数update方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(void com.itheima.dao.impl.BookDaoImpl.update())</span><br></pre></td></tr></table></figure><p>因为调用接口方法的时候最终运行的还是其实现类的方法，所以上面两种描述方式都是可以的。</p><p>对于切入点表达式的语法为:</p><ul><li>切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类&#x2F;接口名.方法名(参数) 异常名）</li></ul><p>对于这个格式，我们不需要硬记，通过一个例子，理解它:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(public User com.itheima.service.UserService.findById(int))</span><br></pre></td></tr></table></figure><ul><li>execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点</li><li>public:访问修饰符,还可以是public，private等，可以省略</li><li>User：返回值，写返回值类型</li><li>com.itheima.service：包名，多级包使用点连接</li><li>UserService:类&#x2F;接口名称</li><li>findById：方法名</li><li>int:参数，直接写参数的类型，多个类型用逗号隔开</li><li>异常名：方法定义中抛出指定异常，可以省略</li></ul><p>切入点表达式就是要找到需要增强的方法，所以它就是对一个具体方法的描述，但是方法的定义会有很多，所以如果每一个方法对应一个切入点表达式，想想这块就会觉得将来编写起来会比较麻烦，有没有更简单的方式呢?</p><p>就需要用到下面所学习的通配符。</p><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>我们使用通配符描述切入点，主要的目的就是简化之前的配置，具体都有哪些通配符可以使用?</p><ul><li><p><code>*</code>:单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution（public * com.itheima.*.UserService.find*(*))</span><br></pre></td></tr></table></figure><p>匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法</p></li><li><p><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution（public User com..UserService.findById(..))</span><br></pre></td></tr></table></figure><p>匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法</p></li><li><p><code>+</code>：专用于匹配子类类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* *..*Service+.*(..))</span><br></pre></td></tr></table></figure><p>这个使用率较低，描述子类的，咱们做JavaEE开发，继承机会就一次，使用都很慎重，所以很少用它。*Service+，表示所有以Service结尾的接口的子类。</p></li></ul><p>接下来，我们把案例中使用到的切入点表达式来分析下:</p><p><img src="/.com//1630163744963-1719409838883-96.png" alt="1630163744963"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">void</span> com.itheima.dao.BookDao.update())</span><br><span class="line">匹配接口，能匹配到</span><br><span class="line">execution(<span class="keyword">void</span> com.itheima.dao.impl.BookDaoImpl.update())</span><br><span class="line">匹配实现类，能匹配到</span><br><span class="line">execution(* com.itheima.dao.impl.BookDaoImpl.update())</span><br><span class="line">返回值任意，能匹配到</span><br><span class="line">execution(* com.itheima.dao.impl.BookDaoImpl.update(*))</span><br><span class="line">返回值任意，但是update方法必须要有一个参数，无法匹配，要想匹配需要在update接口和实现类添加参数</span><br><span class="line">execution(<span class="keyword">void</span> com.*.*.*.*.update())</span><br><span class="line">返回值为<span class="keyword">void</span>,com包下的任意包三层包下的任意类的update方法，匹配到的是实现类，能匹配</span><br><span class="line">execution(<span class="keyword">void</span> com.*.*.*.update())</span><br><span class="line">返回值为<span class="keyword">void</span>,com包下的任意两层包下的任意类的update方法，匹配到的是接口，能匹配</span><br><span class="line">execution(<span class="keyword">void</span> *..update())</span><br><span class="line">返回值为<span class="keyword">void</span>，方法名是update的任意包下的任意类，能匹配</span><br><span class="line">execution(* *..*(..))</span><br><span class="line">匹配项目中任意类的任意方法，能匹配，但是不建议使用这种方式，影响范围广</span><br><span class="line">execution(* *..u*(..))</span><br><span class="line">匹配项目中任意包任意类下只要以u开头的方法，update方法能满足，能匹配</span><br><span class="line">execution(* *..*e(..))</span><br><span class="line">匹配项目中任意包任意类下只要以e结尾的方法，update和save方法能满足，能匹配</span><br><span class="line">execution(<span class="keyword">void</span> com..*())</span><br><span class="line">返回值为<span class="keyword">void</span>，com包下的任意包任意类任意方法，能匹配，*代表的是方法</span><br><span class="line">execution(* com.itheima.*.*Service.find*(..))</span><br><span class="line">将项目中所有业务层方法的以find开头的方法匹配</span><br><span class="line">execution(* com.itheima.*.*Service.save*(..))</span><br><span class="line">将项目中所有业务层方法的以save开头的方法匹配</span><br></pre></td></tr></table></figure><p>后面两种更符合我们平常切入点表达式的编写规则</p><h4 id="书写技巧"><a href="#书写技巧" class="headerlink" title="书写技巧"></a>书写技巧</h4><p>对于切入点表达式的编写其实是很灵活的，那么在编写的时候，有没有什么好的技巧让我们用用:</p><ul><li>所有代码按照标准规范开发，否则以下技巧全部失效</li><li>描述切入点通**&#x3D;&#x3D;常描述接口&#x3D;&#x3D;**，而不描述实现类,如果描述到实现类，就出现紧耦合了</li><li>访问控制修饰符针对接口开发均采用public描述（**&#x3D;&#x3D;可省略访问控制修饰符描述&#x3D;&#x3D;**）</li><li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述</li><li>**&#x3D;&#x3D;包名&#x3D;&#x3D;<strong>书写</strong>&#x3D;&#x3D;尽量不使用..匹配&#x3D;&#x3D;**，效率过低，常用*做单个包描述匹配，或精准匹配</li><li>**&#x3D;&#x3D;接口名&#x2F;类名&#x3D;&#x3D;<strong>书写名称与模块相关的</strong>&#x3D;&#x3D;采用*匹配&#x3D;&#x3D;**，例如UserService书写成*Service，绑定业务层接口名</li><li>**&#x3D;&#x3D;方法名&#x3D;&#x3D;<strong>书写以</strong>&#x3D;&#x3D;动词&#x3D;&#x3D;<strong>进行</strong>&#x3D;&#x3D;精准匹配&#x3D;&#x3D;*<em>，名词采用</em>匹配，例如getById书写成getBy*,selectAll书写成selectAll</li><li>参数规则较为复杂，根据业务方法灵活调整</li><li>通常**&#x3D;&#x3D;不使用异常&#x3D;&#x3D;<strong>作为</strong>&#x3D;&#x3D;匹配&#x3D;&#x3D;**规则</li></ul><h3 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h3><p>前面的案例中，有涉及到如下内容:</p><p><img src="/.com//1630164718080-1719409838883-97.png" alt="1630164718080"></p><p>它所代表的含义是将<code>通知</code>添加到<code>切入点</code>方法执行的&#x3D;&#x3D;前面&#x3D;&#x3D;。</p><p>除了这个注解外，还有没有其他的注解，换个问题就是除了可以在前面加，能不能在其他的地方加?</p><h4 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h4><p>我们先来回顾下AOP通知:</p><ul><li>AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</li></ul><p>通知具体要添加到切入点的哪里?</p><p>共提供了5种通知类型:</p><ul><li>前置通知</li><li>后置通知</li><li><strong>&#x3D;&#x3D;环绕通知(重点)&#x3D;&#x3D;</strong></li><li>返回后通知(了解)</li><li>抛出异常后通知(了解)</li></ul><p>为了更好的理解这几种通知类型，我们来看一张图</p><p><img src="/.com//1630166147697-1719409838883-98.png" alt="1630166147697"></p><p>(1)前置通知，追加功能到方法执行前,类似于在代码1或者代码2添加内容</p><p>(2)后置通知,追加功能到方法执行后,不管方法执行的过程中有没有抛出异常都会执行，类似于在代码5添加内容</p><p>(3)返回后通知,追加功能到方法执行后，只有方法正常执行结束后才进行,类似于在代码3添加内容，如果方法执行抛出异常，返回后通知将不会被添加</p><p>(4)抛出异常后通知,追加功能到方法抛出异常后，只有方法执行出异常才进行,类似于在代码4添加内容，只有方法抛出异常后才会被添加</p><p>(5)环绕通知,环绕通知功能比较强大，它可以追加功能到方法执行的前后，这也是比较常用的方式，它可以实现其他四种通知类型的功能，具体是如何实现的，需要我们往下学习。</p><h4 id="环境准备-8"><a href="#环境准备-8" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加BookDao和BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao update ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao select is running ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建通知类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写App运行类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        bookDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630167385146-1719409838883-99.png" alt="1630167385146"></p><h4 id="通知类型的使用"><a href="#通知类型的使用" class="headerlink" title="通知类型的使用"></a>通知类型的使用</h4><h5 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h5><p>修改MyAdvice,在before方法上添加<code>@Before注解</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="comment">//此处也可以写成 @Before(&quot;MyAdvice.pt()&quot;),不建议</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//1630167805723-1719409838883-100.png" alt="1630167805723"></p><h5 id="后置通知"><a href="#后置通知" class="headerlink" title="后置通知"></a>后置通知</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//1630167887131-1719409838883-101.png" alt="1630167887131"></p><h5 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h5><h6 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//1630167969051-1719409838883-102.png" alt="1630167969051"></p><p>运行结果中，通知的内容打印出来，但是原始方法的内容却没有被执行。</p><p>因为环绕通知需要在原始方法的前后进行增强，所以环绕通知就必须要能对原始操作进行调用，具体如何实现?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="comment">//表示对原始操作的调用</span></span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**说明:**proceed()为什么要抛出异常?</p><p>原因很简单，看下源码就知道了</p><p><img src="/.com//1630168248052-1719409838884-103.png" alt="1630168248052"></p><p>再次运行，程序可以看到原始方法已经被执行了</p><p><img src="/.com//1630168293492-1719409838884-104.png" alt="1630168293492"></p><h6 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h6><p>(1)原始方法有返回值的处理</p><ul><li>修改MyAdvice,对BookDao中的select方法添加环绕通知，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;pt2()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aroundSelect</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="comment">//表示对原始操作的调用</span></span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改App类，调用select方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> bookDao.select();</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会报错，错误内容为:</p><p>Exception in thread “main” org.springframework.aop.AopInvocationException: &#x3D;&#x3D;Null return value from advice does not match primitive return type for: public abstract int com.itheima.dao.BookDao.select()&#x3D;&#x3D;<br>    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:226)<br>    at com.sun.proxy.$Proxy19.select(Unknown Source)<br>    at com.itheima.App.main(App.java:12)</p><p>错误大概的意思是:<code>空的返回不匹配原始方法的int返回</code></p><ul><li>void就是返回Null</li><li>原始方法就是BookDao下的select方法</li></ul><p>所以如果我们使用环绕通知的话，要根据原始方法的返回值来设置环绕通知的返回值，具体解决方案为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;pt2()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundSelect</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="comment">//表示对原始操作的调用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>​为什么返回的是Object而不是int的主要原因是Object类型更通用。</p><p>​在环绕通知中是可以对原始方法返回值就行修改的。</p><h5 id="返回后通知"><a href="#返回后通知" class="headerlink" title="返回后通知"></a>返回后通知</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt2()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//1630169124446-1719409838884-105.png" alt="1630169124446"></p><p><strong>注意：</strong>返回后通知是需要在原始方法<code>select</code>正常执行后才会被执行，如果<code>select()</code>方法执行的过程中出现了异常，那么返回后通知是不会被执行。后置通知是不管原始方法有没有抛出异常都会被执行。这个案例大家下去可以自己练习验证下。</p><h5 id="异常后通知"><a href="#异常后通知" class="headerlink" title="异常后通知"></a>异常后通知</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt2()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//1630169357146-1719409838884-106.png" alt="1630169357146"></p><p><strong>注意：</strong>异常后通知是需要原始方法抛出异常，可以在<code>select()</code>方法中添加一行代码<code>int i = 1/0</code>即可。如果没有抛异常，异常后通知将不会被执行。</p><p>学习完这5种通知类型，我们来思考下环绕通知是如何实现其他通知类型的功能的?</p><p>因为环绕通知是可以控制原始方法执行的，所以我们把增强的代码写在调用原始方法的不同位置就可以实现不同的通知类型的功能，如:</p><p><img src="/.com//1630170090945-1719409838884-108.png" alt="1630170090945"></p><h5 id="通知类型总结"><a href="#通知类型总结" class="headerlink" title="通知类型总结"></a>通知类型总结</h5><h6 id="知识点1：-After"><a href="#知识点1：-After" class="headerlink" title="知识点1：@After"></a>知识点1：@After</h6><table><thead><tr><th>名称</th><th>@After</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行</td></tr></tbody></table><h6 id="知识点2：-AfterReturning"><a href="#知识点2：-AfterReturning" class="headerlink" title="知识点2：@AfterReturning"></a>知识点2：@AfterReturning</h6><table><thead><tr><th>名称</th><th>@AfterReturning</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法正常执行完毕后执行</td></tr></tbody></table><h6 id="知识点3：-AfterThrowing"><a href="#知识点3：-AfterThrowing" class="headerlink" title="知识点3：@AfterThrowing"></a>知识点3：@AfterThrowing</h6><table><thead><tr><th>名称</th><th>@AfterThrowing</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行</td></tr></tbody></table><h6 id="知识点4：-Around"><a href="#知识点4：-Around" class="headerlink" title="知识点4：@Around"></a>知识点4：@Around</h6><table><thead><tr><th>名称</th><th>@Around</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行</td></tr></tbody></table><p>&#x3D;&#x3D;<strong>环绕通知注意事项</strong>&#x3D;&#x3D;</p><ol><li>环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</li><li>通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行</li><li>对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型</li><li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object</li><li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常</li></ol><p>介绍完这么多种通知类型，具体该选哪一种呢?</p><p>我们可以通过一些案例加深下对通知类型的学习。</p><h3 id="业务层接口执行效率"><a href="#业务层接口执行效率" class="headerlink" title="业务层接口执行效率"></a>业务层接口执行效率</h3><h4 id="需求分析-3"><a href="#需求分析-3" class="headerlink" title="需求分析"></a>需求分析</h4><p>这个需求也比较简单，前面我们在介绍AOP的时候已经演示过:</p><ul><li>需求:任意业务层接口执行均可显示其执行效率（执行时长）</li></ul><p>这个案例的目的是查看每个业务层执行的时间，这样就可以监控出哪个业务比较耗时，将其查找出来方便优化。</p><p>具体实现的思路:</p><p>(1) 开始执行方法之前记录一个时间</p><p>(2) 执行方法</p><p>(3) 执行完方法之后记录一个时间</p><p>(4) 用后一个时间减去前一个时间的差值，就是我们需要的结果。</p><p>所以要在方法执行的前后添加业务，经过分析我们将采用<code>环绕通知</code>。</p><p>**说明:**原始方法如果只执行一次，时间太快，两个时间差可能为0，所以我们要执行万次来计算时间差。</p><h4 id="环境准备-9"><a href="#环境准备-9" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加AccountService、AccountServiceImpl、AccountDao与Account类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountDao.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>&#123;</span><br><span class="line">        accountDao.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        accountDao.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_account(name,money)values(#&#123;name&#125;,#&#123;money&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from tbl_account where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_account set name = #&#123;name&#125; , money = #&#123;money&#125; where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_account&quot;)</span></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_account where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="comment">//setter..getter..toString方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resources下提供一个jdbc.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/spring_db?useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure></li><li><p>创建相关配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Spring配置类:SpringConfig</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JdbcConfig配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MybatisConfig配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);</span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编写Spring整合Junit的测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTestCase</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountService.findById(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Account&gt; all = accountService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630214631112-1719409838884-107.png" alt="1630214631112"></p><h4 id="功能开发"><a href="#功能开发" class="headerlink" title="功能开发"></a>功能开发</h4><p><strong>步骤1:开启SpringAOP的注解功能</strong></p><p>在Spring的主配置文件SpringConfig类中添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br></pre></td></tr></table></figure><p><strong>步骤2:创建AOP的通知类</strong></p><ul><li><p>该类要被Spring管理，需要添加@Component</p></li><li><p>要标识该类是一个AOP的切面类，需要添加@Aspect</p></li><li><p>配置切入点表达式，需要添加一个方法，并添加@Pointcut</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//配置业务层的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:添加环绕通知</strong></p><p>在runSpeed()方法上添加@Around</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//配置业务层的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//@Around(&quot;ProjectAdvice.servicePt()&quot;) 可以简写为下面的方式</span></span><br><span class="line">    <span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意:**目前并没有做任何增强</p><p><strong>步骤4:完成核心业务，记录万次执行的时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//配置业务层的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//@Around(&quot;ProjectAdvice.servicePt()&quot;) 可以简写为下面的方式</span></span><br><span class="line">    <span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">           pjp.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;业务层接口万次执行时间: &quot;</span>+(end-start)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤5:运行单元测试类</strong></p><p><img src="/.com//1630215355776-1719409838884-109.png" alt="1630215355776"></p><p>**注意:**因为程序每次执行的时长是不一样的，所以运行多次最终的结果是不一样的。</p><p><strong>步骤6:程序优化</strong></p><p>目前程序所面临的问题是，多个方法一起执行测试的时候，控制台都打印的是:</p><p><code>业务层接口万次执行时间:xxxms</code></p><p>我们没有办法区分到底是哪个接口的哪个方法执行的具体时间，具体如何优化?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//配置业务层的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//@Around(&quot;ProjectAdvice.servicePt()&quot;) 可以简写为下面的方式</span></span><br><span class="line">    <span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">        <span class="comment">//获取执行签名信息</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> pjp.getSignature();</span><br><span class="line">        <span class="comment">//通过签名获取执行操作名称(接口名)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">        <span class="comment">//通过签名获取执行操作名称(方法名)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">           pjp.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;万次执行：&quot;</span>+ className+<span class="string">&quot;.&quot;</span>+methodName+<span class="string">&quot;----&gt;&quot;</span> +(end-start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤7:运行单元测试类</strong></p><p><img src="/.com//1630215743444-1719409838884-110.png" alt="1630215743444"></p><p>&#x3D;&#x3D;补充说明&#x3D;&#x3D;</p><p>当前测试的接口执行效率仅仅是一个理论值，并不是一次完整的执行过程。</p><p>这块只是通过该案例把AOP的使用进行了学习，具体的实际值是有很多因素共同决定的。</p><h3 id="AOP通知获取数据"><a href="#AOP通知获取数据" class="headerlink" title="AOP通知获取数据"></a>AOP通知获取数据</h3><p>目前我们写AOP仅仅是在原始方法前后追加一些操作，接下来我们要说说AOP中数据相关的内容，我们将从<code>获取参数</code>、<code>获取返回值</code>和<code>获取异常</code>三个方面来研究切入点的相关信息。</p><p>前面我们介绍通知类型的时候总共讲了五种，那么对于这五种类型都会有参数，返回值和异常吗?</p><p>我们先来一个个分析下:</p><ul><li>获取切入点方法的参数，所有的通知类型都可以获取参数<ul><li>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</li><li>ProceedingJoinPoint：适用于环绕通知</li></ul></li><li>获取切入点方法返回值，前置和抛出异常后通知是没有返回值，后置通知可有可无，所以不做研究<ul><li>返回后通知</li><li>环绕通知</li></ul></li><li>获取切入点方法运行异常信息，前置和返回后通知是不会有，后置通知可有可无，所以不做研究<ul><li>抛出异常后通知</li><li>环绕通知</li></ul></li></ul><h4 id="环境准备-10"><a href="#环境准备-10" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加BookDao和BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写通知类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">()</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写App运行类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> bookDao.findName(<span class="number">100</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630233154992-1719409838884-111.png" alt="1630233154992"></p><h4 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h4><h5 id="非环绕通知获取方式"><a href="#非环绕通知获取方式" class="headerlink" title="非环绕通知获取方式"></a>非环绕通知获取方式</h5><p>在方法上添加JoinPoint,通过JoinPoint来获取参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span> </span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行App类，可以获取如下内容，说明参数100已经被获取</p><p><img src="/.com//1630233291929-1719409838884-112.png" alt="1630233291929"></p><p><strong>思考:方法的参数只有一个，为什么获取的是一个数组?</strong></p><p>因为参数的个数是不固定的，所以使用数组更通配些。</p><p>如果将参数改成两个会是什么效果呢?</p><p>(1)修改BookDao接口和BookDaoImpl实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id,String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id,String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)修改App类，调用方法传入多个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> bookDao.findName(<span class="number">100</span>,<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)运行App，查看结果,说明两个参数都已经被获取到</p><p><img src="/.com//1630233548743-1719409838884-113.png" alt="1630233548743"></p><p><strong>说明:</strong></p><p>使用JoinPoint的方式获取参数适用于<code>前置</code>、<code>后置</code>、<code>返回后</code>、<code>抛出异常后</code>通知。剩下的大家自行去验证。</p><h5 id="环绕通知获取方式"><a href="#环绕通知获取方式" class="headerlink" title="环绕通知获取方式"></a>环绕通知获取方式</h5><p>环绕通知使用的是ProceedingJoinPoint，因为ProceedingJoinPoint是JoinPoint类的子类，所以对于ProceedingJoinPoint类中应该也会有对应的<code>getArgs()</code>方法，我们去验证下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span><span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行App后查看运行结果，说明ProceedingJoinPoint也是可以通过getArgs()获取参数</p><p><img src="/.com//1630233974310-1719409838884-114.png" alt="1630233974310"></p><p><strong>注意:</strong></p><ul><li><p>pjp.proceed()方法是有两个构造方法，分别是:</p><p><img src="/.com//1630234756123-1719409838884-115.png" alt="1630234756123"></p><ul><li><p>调用无参数的proceed，当原始方法有参数，会在调用的过程中自动传入参数</p></li><li><p>所以调用这两个方法的任意一个都可以完成功能</p></li><li><p>但是当需要修改原始方法的参数时，就只能采用带有参数的方法,如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        args[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(args);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个特性后，我们就可以在环绕通知中对原始方法的参数进行拦截过滤，避免由于参数的问题导致程序无法正确运行，保证代码的健壮性。</p></li></ul></li></ul><h4 id="获取返回值"><a href="#获取返回值" class="headerlink" title="获取返回值"></a>获取返回值</h4><p>对于返回值，只有返回后<code>AfterReturing</code>和环绕<code>Around</code>这两个通知类型可以获取，具体如何获取?</p><h5 id="环绕通知获取返回值"><a href="#环绕通知获取返回值" class="headerlink" title="环绕通知获取返回值"></a>环绕通知获取返回值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        args[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(args);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>ret</code>就是方法的返回值，我们是可以直接获取，不但可以获取，如果需要还可以进行修改。</p><h5 id="返回后通知获取返回值"><a href="#返回后通知获取返回值" class="headerlink" title="返回后通知获取返回值"></a>返回后通知获取返回值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pt()&quot;,returning = &quot;ret&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object ret)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>+ret);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;</p><p>(1)参数名的问题</p><p><img src="/.com//1630237320870-1719409838884-116.png" alt="1630237320870"></p><p>(2)afterReturning方法参数类型的问题</p><p>参数类型可以写成String，但是为了能匹配更多的参数类型，建议写成Object类型</p><p>(3)afterReturning方法参数的顺序问题</p><p><img src="/.com//1630237586682-1719409838884-117.png" alt="1630237586682"></p><p>运行App后查看运行结果，说明返回值已经被获取到</p><p><img src="/.com//1630237372286-1719409838884-118.png" alt="1630237372286"></p><h4 id="获取异常"><a href="#获取异常" class="headerlink" title="获取异常"></a>获取异常</h4><p>对于获取抛出的异常，只有抛出异常后<code>AfterThrowing</code>和环绕<code>Around</code>这两个通知类型可以获取，具体如何获取?</p><h5 id="环绕通知获取异常"><a href="#环绕通知获取异常" class="headerlink" title="环绕通知获取异常"></a>环绕通知获取异常</h5><p>这块比较简单，以前我们是抛出异常，现在只需要将异常捕获，就可以获取到原始方法的异常信息了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        args[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ret = pjp.proceed(args);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable throwable)&#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在catch方法中就可以获取到异常，至于获取到异常以后该如何处理，这个就和你的业务需求有关了。</p><h5 id="抛出异常后通知获取异常"><a href="#抛出异常后通知获取异常" class="headerlink" title="抛出异常后通知获取异常"></a>抛出异常后通知获取异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pt()&quot;,throwing = &quot;t&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何让原始方法抛出异常，方式有很多，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id,String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span>+id);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;</p><p><img src="/.com//1630239939043-1719409838884-119.png" alt="1630239939043"></p><p>运行App后，查看控制台，就能看的异常信息被打印到控制台</p><p><img src="/.com//1630239997560-1719409838884-120.png" alt="1630239997560"></p><p>至此，AOP通知如何获取数据就已经讲解完了，数据中包含<code>参数</code>、<code>返回值</code>、<code>异常(了解)</code>。</p><h3 id="百度网盘密码数据兼容处理"><a href="#百度网盘密码数据兼容处理" class="headerlink" title="百度网盘密码数据兼容处理"></a>百度网盘密码数据兼容处理</h3><h4 id="需求分析-4"><a href="#需求分析-4" class="headerlink" title="需求分析"></a>需求分析</h4><p>需求: 对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理。</p><p><img src="/.com//1630240203033-1719409838884-121.png" alt="1630240203033"></p><p>问题描述:</p><ul><li><p>点击链接，会提示，请输入提取码，如下图所示</p><p><img src="/.com//1630240528228-1719409838884-122.png" alt="1630240528228"></p></li><li><p>当我们从别人发给我们的内容中复制提取码的时候，有时候会多复制到一些空格，直接粘贴到百度的提取码输入框</p></li><li><p>但是百度那边记录的提取码是没有空格的</p></li><li><p>这个时候如果不做处理，直接对比的话，就会引发提取码不一致，导致无法访问百度盘上的内容</p></li><li><p>所以多输入一个空格可能会导致项目的功能无法正常使用。</p></li><li><p>此时我们就想能不能将输入的参数先帮用户去掉空格再操作呢?</p></li></ul><p>答案是可以的，我们只需要在业务方法执行之前对所有的输入参数进行格式处理——trim()</p><ul><li>是对所有的参数都需要去除空格么?</li></ul><p>也没有必要，一般只需要针对字符串处理即可。</p><ul><li>以后涉及到需要去除前后空格的业务可能会有很多，这个去空格的代码是每个业务都写么?</li></ul><p>可以考虑使用AOP来统一处理。</p><ul><li>AOP有五种通知类型，该使用哪种呢?</li></ul><p>我们的需求是将原始方法的参数处理后在参与原始方法的调用，能做这件事的就只有环绕通知。</p><p>综上所述，我们需要考虑两件事:<br>①：在业务方法执行之前对所有的输入参数进行格式处理——trim()<br>②：使用处理后的参数调用原始方法——环绕通知中存在对原始方法的调用</p><h4 id="环境准备-11"><a href="#环境准备-11" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加ResourcesService，ResourcesServiceImpl,ResourcesDao和ResourcesDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourcesDao</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">readResources</span><span class="params">(String url, String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcesDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">ResourcesDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">readResources</span><span class="params">(String url, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//模拟校验</span></span><br><span class="line">        <span class="keyword">return</span> password.equals(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourcesService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">openURL</span><span class="params">(String url ,String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcesServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ResourcesService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourcesDao resourcesDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">openURL</span><span class="params">(String url, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resourcesDao.readResources(url,password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建Spring的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写App运行类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">ResourcesService</span> <span class="variable">resourcesService</span> <span class="operator">=</span> ctx.getBean(ResourcesService.class);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> resourcesService.openURL(<span class="string">&quot;http://pan.baidu.com/haha&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630241681697-1719409838884-123.png" alt="1630241681697"></p><p>现在项目的效果是，当输入密码为”root”控制台打印为true,如果密码改为”root  “控制台打印的是false</p><p>需求是使用AOP将参数进行统一处理，不管输入的密码<code>root</code>前后包含多少个空格，最终控制台打印的都是true。</p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p><strong>步骤1:开启SpringAOP的注解功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:编写通知类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(boolean com.itheima.service.*Service.*(*,*))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:添加环绕通知</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(boolean com.itheima.service.*Service.*(*,*))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;DataAdvice.servicePt()&quot;)</span></span><br><span class="line">    <span class="comment">// @Around(&quot;servicePt()&quot;)这两种写法都对</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">trimStr</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4:完成核心业务，处理参数中的空格</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(boolean com.itheima.service.*Service.*(*,*))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;DataAdvice.servicePt()&quot;)</span></span><br><span class="line">    <span class="comment">// @Around(&quot;servicePt()&quot;)这两种写法都对</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">trimStr</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//获取原始方法的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            <span class="comment">//判断参数是不是字符串</span></span><br><span class="line">            <span class="keyword">if</span>(args[i].getClass().equals(String.class))&#123;</span><br><span class="line">                args[i] = args[i].toString().trim();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将修改后的参数传入到原始方法的执行中</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(args);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤5:运行程序</strong></p><p>不管密码<code>root</code>前后是否加空格，最终控制台打印的都是true</p><p><strong>步骤6:优化测试</strong></p><p>为了能更好的看出AOP已经生效，我们可以修改ResourcesImpl类，在方法中将密码的长度进行打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcesDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">ResourcesDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">readResources</span><span class="params">(String url, String password)</span> &#123;</span><br><span class="line">        System.out.println(password.length());</span><br><span class="line">        <span class="comment">//模拟校验</span></span><br><span class="line">        <span class="keyword">return</span> password.equals(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行成功，就可以根据最终打印的长度来看看，字符串的空格有没有被去除掉。</p><p><strong>注意：</strong></p><p><img src="/.com//1630242491831-1719409838884-124.png" alt="1630242491831"></p><h2 id="AOP总结"><a href="#AOP总结" class="headerlink" title="AOP总结"></a>AOP总结</h2><p>AOP的知识就已经讲解完了，接下来对于AOP的知识进行一个总结:</p><h3 id="AOP的核心概念"><a href="#AOP的核心概念" class="headerlink" title="AOP的核心概念"></a>AOP的核心概念</h3><ul><li>概念：AOP(Aspect Oriented Programming)面向切面编程，一种编程范式</li><li>作用：在不惊动原始设计的基础上为方法进行功能&#x3D;&#x3D;增强&#x3D;&#x3D;</li><li>核心概念<ul><li>代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的</li><li>连接点（JoinPoint）：在SpringAOP中，理解为任意方法的执行</li><li>切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述</li><li>通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法</li><li>切面（Aspect）：描述通知与切入点的对应关系</li><li>目标对象（Target）：被代理的原始对象成为目标对象</li></ul></li></ul><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><ul><li><p>切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类&#x2F;接口名.方法名（参数）异常名)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.service.*Service.*(..))</span><br></pre></td></tr></table></figure></li><li><p>切入点表达式描述通配符：</p><ul><li>作用：用于快速描述，范围描述</li><li><code>*</code>：匹配任意符号（常用）</li><li><code>..</code> ：匹配多个连续的任意符号（常用）</li><li><code>+</code>：匹配子类类型</li></ul></li><li><p>切入点表达式书写技巧</p><p>1.按&#x3D;&#x3D;标准规范&#x3D;&#x3D;开发<br>2.查询操作的返回值建议使用*匹配<br>3.减少使用..的形式描述包<br>4.&#x3D;&#x3D;对接口进行描述&#x3D;&#x3D;，使用*表示模块名，例如UserService的匹配描述为*Service<br>5.方法名书写保留动词，例如get，使用*表示名词，例如getById匹配描述为getBy*<br>6.参数根据实际情况灵活调整</p></li></ul><h3 id="五种通知类型"><a href="#五种通知类型" class="headerlink" title="五种通知类型"></a>五种通知类型</h3><ul><li>前置通知</li><li>后置通知</li><li>环绕通知（重点）<ul><li>环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用</li><li>环绕通知可以隔离原始方法的调用执行</li><li>环绕通知返回值设置为Object类型</li><li>环绕通知中可以对原始方法调用过程中出现的异常进行处理</li></ul></li><li>返回后通知</li><li>抛出异常后通知</li></ul><h3 id="通知中获取参数"><a href="#通知中获取参数" class="headerlink" title="通知中获取参数"></a>通知中获取参数</h3><ul><li>获取切入点方法的参数，所有的通知类型都可以获取参数<ul><li>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</li><li>ProceedingJoinPoint：适用于环绕通知</li></ul></li><li>获取切入点方法返回值，前置和抛出异常后通知是没有返回值，后置通知可有可无，所以不做研究<ul><li>返回后通知</li><li>环绕通知</li></ul></li><li>获取切入点方法运行异常信息，前置和返回后通知是不会有，后置通知可有可无，所以不做研究<ul><li>抛出异常后通知</li><li>环绕通知</li></ul></li></ul><h2 id="AOP事务管理"><a href="#AOP事务管理" class="headerlink" title="AOP事务管理"></a>AOP事务管理</h2><h3 id="Spring事务简介"><a href="#Spring事务简介" class="headerlink" title="Spring事务简介"></a>Spring事务简介</h3><h4 id="相关概念介绍"><a href="#相关概念介绍" class="headerlink" title="相关概念介绍"></a>相关概念介绍</h4><ul><li>事务作用：在数据层保障一系列的数据库操作同成功同失败</li><li>Spring事务作用：在数据层或**&#x3D;&#x3D;业务层&#x3D;&#x3D;**保障一系列的数据库操作同成功同失败</li></ul><p>数据层有事务我们可以理解，为什么业务层也需要处理事务呢?</p><p>举个简单的例子，</p><ul><li>转账业务会有两次数据层的调用，一次是加钱一次是减钱</li><li>把事务放在数据层，加钱和减钱就有两个事务</li><li>没办法保证加钱和减钱同时成功或者同时失败</li><li>这个时候就需要将事务放在业务层进行处理。</li></ul><p>Spring为了管理事务，提供了一个平台事务管理器<code>PlatformTransactionManager</code></p><p><img src="/.com//1630243651541-1719409838884-125.png" alt="1630243651541"></p><p>commit是用来提交事务，rollback是用来回滚事务。</p><p>PlatformTransactionManager只是一个接口，Spring还为其提供了一个具体的实现:</p><p><img src="/.com//1630243993380-1719409838884-126.png" alt="1630243993380"></p><p>从名称上可以看出，我们只需要给它一个DataSource对象，它就可以帮你去在业务层管理事务。其内部采用的是JDBC的事务。所以说如果你持久层采用的是JDBC相关的技术，就可以采用这个事务管理器来管理你的事务。而Mybatis内部采用的就是JDBC的事务，所以后期我们Spring整合Mybatis就采用的这个DataSourceTransactionManager事务管理器。</p><h4 id="转账案例-需求分析"><a href="#转账案例-需求分析" class="headerlink" title="转账案例-需求分析"></a>转账案例-需求分析</h4><p>接下来通过一个案例来学习下Spring是如何来管理事务的。</p><p>先来分析下需求:</p><p>需求: 实现任意两个账户间转账操作</p><p>需求微缩: A账户减钱，B账户加钱</p><p>为了实现上述的业务需求，我们可以按照下面步骤来实现下:<br>①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney）</p><p>②：业务层提供转账操作（transfer），调用减钱与加钱的操作</p><p>③：提供2个账号和操作金额执行转账操作</p><p>④：基于Spring整合MyBatis环境搭建上述操作</p><h4 id="转账案例-环境搭建"><a href="#转账案例-环境搭建" class="headerlink" title="转账案例-环境搭建"></a>转账案例-环境搭建</h4><p><strong>步骤1:准备数据库表</strong></p><p>之前我们在整合Mybatis的时候已经创建了这个表,可以直接使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database spring_db <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line">use spring_db;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_account(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">35</span>),</span><br><span class="line">    money <span class="keyword">double</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_account <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_account <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><strong>步骤2:创建项目导入jar包</strong></p><p>项目的pom.xml添加相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤3:根据表创建模型类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"><span class="comment">//setter...getter...toString...方法略    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4:创建Dao接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">outMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤5:创建Service接口和实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 传出方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 转入方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> &#123;</span><br><span class="line">        accountDao.outMoney(out,money);</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤6:添加jdbc.properties文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/spring_db?useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><p><strong>步骤7:创建JdbcConfig配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤8:创建MybatisConfig配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);</span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤9:创建SpringConfig配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>步骤10:编写测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransfer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        accountService.transfer(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Jerry&quot;</span>,<span class="number">100D</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630247220645-1719409838884-127.png" alt="1630247220645"></p><h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><p>上述环境，运行单元测试类，会执行转账操作，<code>Tom</code>的账户会减少100，<code>Jerry</code>的账户会加100。</p><p>这是正常情况下的运行结果，但是如果在转账的过程中出现了异常，如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> &#123;</span><br><span class="line">        accountDao.outMoney(out,money);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候就模拟了转账过程中出现异常的情况，正确的操作应该是转账出问题了，<code>Tom</code>应该还是900，<code>Jerry</code>应该还是1100，但是真正运行后会发现，并没有像我们想象的那样，<code>Tom</code>账户为800而<code>Jerry</code>还是1100,100块钱凭空消息了，银行乐疯了。如果把转账换个顺序，银行就该哭了。</p><p>不管哪种情况，都是不允许出现的，对刚才的结果我们做一个分析:</p><p>①：程序正常执行时，账户金额A减B加，没有问题</p><p>②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败</p><p>当程序出问题后，我们需要让事务进行回滚，而且这个事务应该是加在业务层上，而Spring的事务管理就是用来解决这类问题的。</p><p>Spring事务管理具体的实现步骤为:</p><p><strong>步骤1:在需要被事务管理的方法上添加注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 传出方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 转入方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//配置当前接口方法具有事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> &#123;</span><br><span class="line">        accountDao.outMoney(out,money);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;</p><p>@Transactional可以写在接口类上、接口方法上、实现类上和实现类方法上</p><ul><li>写在接口类上，该接口的所有实现类的所有方法都会有事务</li><li>写在接口方法上，该接口的所有实现类的该方法都会有事务</li><li>写在实现类上，该类中的所有方法都会有事务</li><li>写在实现类方法上，该方法上有事务</li><li>&#x3D;&#x3D;建议写在实现类或实现类的方法上&#x3D;&#x3D;</li></ul><p><strong>步骤2:在JdbcConfig类中配置事务管理器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置事务管理器，mybatis使用的是jdbc事务</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>事务管理器要根据使用技术进行选择，Mybatis框架使用的是JDBC事务，可以直接使用<code>DataSourceTransactionManager</code></p><p><strong>步骤3：开启事务注解</strong></p><p>在SpringConfig的配置类中开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class</span></span><br><span class="line"><span class="meta">//开启注解式事务驱动</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">public class SpringConfig &#123;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta"></span></span><br></pre></td></tr></table></figure><p><strong>步骤4:运行测试类</strong></p><p>会发现在转换的业务出现错误后，事务就可以控制回顾，保证数据的正确性。</p><h5 id="知识点1：-EnableTransactionManagement"><a href="#知识点1：-EnableTransactionManagement" class="headerlink" title="知识点1：@EnableTransactionManagement"></a>知识点1：@EnableTransactionManagement</h5><table><thead><tr><th>名称</th><th>@EnableTransactionManagement</th></tr></thead><tbody><tr><td>类型</td><td>配置类注解</td></tr><tr><td>位置</td><td>配置类定义上方</td></tr><tr><td>作用</td><td>设置当前Spring环境中开启注解式事务支持</td></tr></tbody></table><h5 id="知识点2：-Transactional"><a href="#知识点2：-Transactional" class="headerlink" title="知识点2：@Transactional"></a>知识点2：@Transactional</h5><table><thead><tr><th>名称</th><th>@Transactional</th></tr></thead><tbody><tr><td>类型</td><td>接口注解  类注解  方法注解</td></tr><tr><td>位置</td><td>业务层接口上方  业务层实现类上方  业务方法上方</td></tr><tr><td>作用</td><td>为当前业务层方法添加事务（如果设置在类或接口上方则类或接口中所有方法均添加事务）</td></tr></tbody></table><h3 id="Spring事务角色"><a href="#Spring事务角色" class="headerlink" title="Spring事务角色"></a>Spring事务角色</h3><p>这节中我们重点要理解两个概念，分别是<code>事务管理员</code>和<code>事务协调员</code>。</p><ol><li>未开启Spring事务之前:</li></ol><p><img src="/.com//../../../Typora%E7%AC%94%E8%AE%B0/Spring/1630248794837.png" alt="1630248794837"></p><ul><li>AccountDao的outMoney因为是修改操作，会开启一个事务T1</li><li>AccountDao的inMoney因为是修改操作，会开启一个事务T2</li><li>AccountService的transfer没有事务，<ul><li>运行过程中如果没有抛出异常，则T1和T2都正常提交，数据正确</li><li>如果在两个方法中间抛出异常，T1因为执行成功提交事务，T2因为抛异常不会被执行</li><li>就会导致数据出现错误</li></ul></li></ul><ol start="2"><li>开启Spring的事务管理后</li></ol><p><img src="/.com//../../../Typora%E7%AC%94%E8%AE%B0/Spring/1630249111055.png" alt="1630249111055"></p><ul><li>transfer上添加了@Transactional注解，在该方法上就会有一个事务T</li><li>AccountDao的outMoney方法的事务T1加入到transfer的事务T中</li><li>AccountDao的inMoney方法的事务T2加入到transfer的事务T中</li><li>这样就保证他们在同一个事务中，当业务层中出现异常，整个事务就会回滚，保证数据的准确性。</li></ul><p>通过上面例子的分析，我们就可以得到如下概念:</p><ul><li>事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法</li><li>事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法</li></ul><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;</p><p>目前的事务管理是基于<code>DataSourceTransactionManager</code>和<code>SqlSessionFactoryBean</code>使用的是同一个数据源。</p><h3 id="Spring事务属性"><a href="#Spring事务属性" class="headerlink" title="Spring事务属性"></a>Spring事务属性</h3><p>上一节我们介绍了两个概念，事务的管理员和事务的协同员，对于这两个概念具体做什么的，我们待会通过案例来使用下。除了这两个概念，还有就是事务的其他相关配置都有哪些，就是我们接下来要学习的内容。</p><p>在这一节中，我们主要学习三部分内容<code>事务配置</code>、<code>转账业务追加日志</code>、<code>事务传播行为</code>。</p><h4 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h4><p><img src="/.com//1630250069844-1719409838884-132.png" alt="1630250069844"></p><p>上面这些属性都可以在<code>@Transactional</code>注解的参数上进行设置。</p><ul><li><p>readOnly：true只读事务，false读写事务，增删改要设为false,查询设为true。</p></li><li><p>timeout:设置超时时间单位秒，在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。</p></li><li><p>rollbackFor:当出现指定异常进行事务回滚</p></li><li><p>noRollbackFor:当出现指定异常不进行事务回滚</p><ul><li><p>思考:出现异常事务会自动回滚，这个是我们之前就已经知道的</p></li><li><p>noRollbackFor是设定对于指定的异常不回滚，这个好理解</p></li><li><p>rollbackFor是指定回滚异常，对于异常事务不应该都回滚么，为什么还要指定?</p><ul><li><p>这块需要更正一个知识点，并不是所有的异常都会回滚事务，比如下面的代码就不会回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 传出方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 转入方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//配置当前接口方法具有事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        accountDao.outMoney(out,money);</span><br><span class="line">        <span class="comment">//int i = 1/0; //这个异常事务会回滚</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(); <span class="comment">//这个异常事务就不会回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>出现这个问题的原因是，Spring的事务只会对<code>Error异常</code>和<code>RuntimeException异常</code>及其子类进行事务回顾，其他的异常类型是不会回滚的，对应IOException不符合上述条件所以不回滚</p><ul><li><p>此时就可以使用rollbackFor属性来设置出现IOException异常不回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"> <span class="meta">@Transactional(rollbackFor = &#123;IOException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        accountDao.outMoney(out,money);</span><br><span class="line">        <span class="comment">//int i = 1/0; //这个异常事务会回滚</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(); <span class="comment">//这个异常事务就不会回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>rollbackForClassName等同于rollbackFor,只不过属性为异常的类全名字符串</p></li><li><p>noRollbackForClassName等同于noRollbackFor，只不过属性为异常的类全名字符串</p></li><li><p>isolation设置事务的隔离级别</p><ul><li>DEFAULT   :默认隔离级别, 会采用数据库的隔离级别</li><li>READ_UNCOMMITTED : 读未提交</li><li>READ_COMMITTED : 读已提交</li><li>REPEATABLE_READ : 重复读取</li><li>SERIALIZABLE: 串行化</li></ul></li></ul><p>介绍完上述属性后，还有最后一个事务的传播行为，为了讲解该属性的设置，我们需要完成下面的案例。</p><h4 id="转账业务追加日志案例"><a href="#转账业务追加日志案例" class="headerlink" title="转账业务追加日志案例"></a>转账业务追加日志案例</h4><h5 id="需求分析-5"><a href="#需求分析-5" class="headerlink" title="需求分析"></a>需求分析</h5><p>在前面的转案例的基础上添加新的需求，完成转账后记录日志。</p><ul><li>需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕</li><li>需求微缩：A账户减钱，B账户加钱，数据库记录日志</li></ul><p>基于上述的业务需求，我们来分析下该如何实现:</p><p>①：基于转账操作案例添加日志模块，实现数据库中记录日志</p><p>②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能</p><p>需要注意一点就是，我们这个案例的预期效果为:</p><p>&#x3D;&#x3D;无论转账操作是否成功，均进行转账操作的日志留痕&#x3D;&#x3D;</p><h5 id="环境准备-12"><a href="#环境准备-12" class="headerlink" title="环境准备"></a>环境准备</h5><p>该环境是基于转账环境来完成的，所以环境的准备可以参考<code>6.1.3的环境搭建步骤</code>，在其基础上，我们继续往下写</p><p><strong>步骤1:创建日志表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_log(</span><br><span class="line">   id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">   info <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">   createDate datetime</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>步骤2:添加LogDao接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_log (info,createDate) values(#&#123;info&#125;,now())&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String info)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>步骤3:添加LogService接口与实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out, String in, Double money)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out,String in,Double money )</span> &#123;</span><br><span class="line">        logDao.log(<span class="string">&quot;转账操作由&quot;</span>+out+<span class="string">&quot;到&quot;</span>+in+<span class="string">&quot;,金额：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4:在转账的业务中添加记录日志</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 传出方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 转入方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//配置当前接口方法具有事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span><span class="keyword">throws</span> IOException ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            accountDao.outMoney(out,money);</span><br><span class="line">            accountDao.inMoney(in,money);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            logService.log(out,in,money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤5:运行程序</strong></p><ul><li><p>当程序正常运行，tbl_account表中转账成功，tbl_log表中日志记录成功</p></li><li><p>当转账业务之间出现异常(int i &#x3D;1&#x2F;0),转账失败，tbl_account成功回滚，但是tbl_log表未添加数据</p></li><li><p>这个结果和我们想要的不一样，什么原因?该如何解决?</p></li><li><p>失败原因:日志的记录与转账操作隶属同一个事务，同成功同失败</p></li><li><p>最终效果:无论转账操作是否成功，日志必须保留</p></li></ul><h4 id="6-3-3-事务传播行为"><a href="#6-3-3-事务传播行为" class="headerlink" title="6.3.3 事务传播行为"></a>6.3.3 事务传播行为</h4><p><img src="/.com//1630253779575-1719409838884-130.png" alt="1630253779575"></p><p>对于上述案例的分析:</p><ul><li>log方法、inMoney方法和outMoney方法都属于增删改，分别有事务T1,T2,T3</li><li>transfer因为加了@Transactional注解，也开启了事务T</li><li>前面我们讲过Spring事务会把T1,T2,T3都加入到事务T中</li><li>所以当转账失败后，所有的事务都回滚，导致日志没有记录下来</li><li>这和我们的需求不符，这个时候我们就想能不能让log方法单独是一个事务呢?</li></ul><p>要想解决这个问题，就需要用到事务传播行为，所谓的事务传播行为指的是:</p><p>事务传播行为：事务协调员对事务管理员所携带事务的处理态度。</p><p>具体如何解决，就需要用到之前我们没有说的<code>propagation属性</code>。</p><p><strong>1.修改logService改变事务的传播行为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line"><span class="comment">//propagation设置事务属性：传播行为设置为当前操作需要新事务</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out,String in,Double money )</span> &#123;</span><br><span class="line">        logDao.log(<span class="string">&quot;转账操作由&quot;</span>+out+<span class="string">&quot;到&quot;</span>+in+<span class="string">&quot;,金额：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，就能实现我们想要的结果，不管转账是否成功，都会记录日志。</p><p><strong>2.事务传播行为的可选值</strong></p><p><img src="/.com//1630254257628-1719409838884-131.png" alt="1630254257628"></p><p>对于我们开发实际中使用的话，因为默认值需要事务是常态的。根据开发过程选择其他的就可以了，例如案例中需要新事务就需要手工配置。其实入账和出账操作上也有事务，采用的就是默认值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-plus</title>
      <link href="/2024/05/05/MyBatis-plus/"/>
      <url>/2024/05/05/MyBatis-plus/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2024/05/05/Maven/"/>
      <url>/2024/05/05/Maven/</url>
      
        <content type="html"><![CDATA[<h2 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h2><h3 id="分模块开发设计"><a href="#分模块开发设计" class="headerlink" title="分模块开发设计"></a>分模块开发设计</h3><p>(1)按照功能拆分</p><p>我们现在的项目都是在一个模块中，比如前面的SSM整合开发。虽然这样做功能也都实现了，但是也存在了一些问题，我们拿银行的项目为例来聊聊这个事。</p><ul><li>网络没有那么发达的时候，我们需要到银行柜台或者取款机进行业务操作</li><li>随着互联网的发展,我们有了电脑以后，就可以在网页上登录银行网站使用U盾进行业务操作</li><li>再来就是随着智能手机的普及，我们只需要用手机登录APP就可以进行业务操作</li></ul><p>上面三个场景出现的时间是不相同的，如果非要把三个场景的模块代码放入到一个项目，那么当其中某一个模块代码出现问题，就会导致整个项目无法正常启动，从而导致银行的多个业务都无法正常班理。所以我们会&#x3D;&#x3D;按照功能&#x3D;&#x3D;将项目进行拆分。</p><p>(2)按照模块拆分</p><p>比如电商的项目中，有订单和商品两个模块，订单中需要包含商品的详细信息，所以需要商品的模型类，商品模块也会用到商品的模型类，这个时候如果两个模块中都写模型类，就会出现重复代码，后期的维护成本就比较高。我们就想能不能将它们公共的部分抽取成一个独立的模块，其他模块要想使用可以像添加第三方jar包依赖一样来使用我们自己抽取的模块，这样就解决了代码重复的问题,这种拆分方式就说我们所说的&#x3D;&#x3D;按照模块&#x3D;&#x3D;拆分。</p><p><img src="/.com//1630768703430-1719410661546-1.png" alt="1630768703430"></p><p>经过两个案例的分析，我们就知道:</p><ul><li>将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用，接口共享。</li></ul><p>刚刚我们说了可以将domain层进行拆分，除了domain层，我们也可以将其他的层也拆成一个个对立的模块，如:</p><p><img src="/.com//1630768869208-1719410661546-2.png" alt="1630768869208"></p><p>这样的话，项目中的每一层都可以单独维护，也可以很方便的被别人使用。关于分模块开发的意义，我们就说完了，说了这么多好处，那么该如何实现呢?</p><h3 id="分模块开发实现"><a href="#分模块开发实现" class="headerlink" title="分模块开发实现"></a>分模块开发实现</h3><p>前面我们已经完成了SSM整合，接下来，咱们就基于SSM整合的项目来实现对项目的拆分。</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>将<code>资料\maven_02_ssm</code>部署到IDEA中，将环境快速准备好，部署成功后，项目的格式如下:</p><p><img src="/.com//1630769969416-1719410661547-3.png" alt="1630769969416"></p><h4 id="抽取domain层"><a href="#抽取domain层" class="headerlink" title="抽取domain层"></a>抽取domain层</h4><p><strong>步骤1:创建新模块</strong></p><p>创建一个名称为<code>maven_03_pojo</code>的jar项目,为什么项目名是从02到03这样创建，原因后面我们会提到，这块的名称可以任意。</p><p><img src="/.com//1630771178137-1719410661547-4.png" alt="1630771178137"></p><p><strong>步骤2:项目中创建domain包</strong></p><p>在<code>maven_03_pojo</code>项目中创建<code>com.itheima.domain</code>包，并将<code>maven_02_ssm</code>中Book类拷贝到该包中</p><p><img src="/.com//1630771371487-1719410661547-5.png" alt="1630771371487"></p><p><strong>步骤3:删除原项目中的domain包</strong></p><p>删除后，<code>maven_02_ssm</code>项目中用到<code>Book</code>的类中都会有红色提示，如下:</p><p><img src="/.com//1630771505703-1719410661547-6.png" alt="1630771505703"></p><p>**说明:**出错的原因是<code>maven_02_ssm</code>中已经将Book类删除，所以该项目找不到Book类，所以报错</p><p>要想解决上述问题，我们需要在<code>maven_02_ssm</code>中添加<code>maven_03_pojo</code>的依赖。</p><p><strong>步骤4:建立依赖关系</strong></p><p>在<code>maven_02_ssm</code>项目的pom.xml添加<code>maven_03_pojo</code>的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为添加了依赖，所以在<code>maven_02_ssm</code>中就已经能找到Book类，所以刚才的报红提示就会消失。</p><p><strong>步骤5:编译<code>maven_02_ssm</code>项目</strong></p><p>编译<code>maven_02_ssm</code>你会在控制台看到如下错误</p><p><img src="/.com//1630771987325-1719410661547-7.png" alt="1630771987325"></p><p>错误信息为：不能解决<code>maven_02_ssm</code>项目的依赖问题，找不到<code>maven_03_pojo</code>这个jar包。</p><p>为什么找不到呢?</p><p>原因是Maven会从本地仓库找对应的jar包，但是本地仓库又不存在该jar包所以会报错。</p><p>在IDEA中是有<code>maven_03_pojo</code>这个项目，所以我们只需要将<code>maven_03_pojo</code>项目安装到本地仓库即可。</p><p><strong>步骤6:将项目安装本地仓库</strong></p><p>将需要被依赖的项目<code>maven_03_pojo</code>，使用maven的install命令，把其安装到Maven的本地仓库中。</p><p><img src="/.com//1630773180969-1719410661547-8.png" alt="1630773180969"></p><p>安装成功后，在对应的路径下就看到安装好的jar包</p><p><img src="/.com//1630773262441-1719410661547-9.png" alt="1630773262441"></p><p>**说明:**具体安装在哪里，和你们自己电脑上Maven的本地仓库配置的位置有关。</p><p>当再次执行<code>maven_02_ssm</code>的compile的命令后，就已经能够成功编译。</p><h4 id="抽取Dao层"><a href="#抽取Dao层" class="headerlink" title="抽取Dao层"></a>抽取Dao层</h4><p><strong>步骤1:创建新模块</strong></p><p>创建一个名称为<code>maven_04_dao</code>的jar项目</p><p><img src="/.com//1630773580067-1719410661547-10.png" alt="1630773580067"></p><p><strong>步骤2:项目中创建dao包</strong></p><p>在<code>maven_04_dao</code>项目中创建<code>com.itheima.dao</code>包，并将<code>maven_02_ssm</code>中BookDao类拷贝到该包中</p><p><img src="/.com//1630773695062-1719410661547-11.png" alt="1630773695062"></p><p>在<code>maven_04_dao</code>中会有如下几个问题需要解决下:</p><p><img src="/.com//1630773958756-1719410661547-12.png" alt="1630773958756"></p><ul><li><p>项目<code>maven_04_dao</code>的BookDao接口中Book类找不到报错</p><ul><li><p>解决方案在<code>maven_04_dao</code>项目的pom.xml中添加<code>maven_03_pojo</code>项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>项目<code>maven_04_dao</code>的BookDao接口中，Mybatis的增删改查注解报错</p><ul><li><p>解决方案在<code>maven_04_dao</code>项目的pom.xml中添加<code>mybatis</code>的相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>步骤3:删除原项目中的dao包</strong></p><p>删除Dao包以后，因为<code>maven_02_ssm</code>中的BookServiceImpl类中有使用到Dao的内容，所以需要在<code>maven_02_ssm</code>的pom.xml添加<code>maven_04_dao</code>的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_04_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时在<code>maven_02_ssm</code>项目中就已经添加了<code>maven_03_pojo</code>和<code>maven_04_dao</code>包</p><p><img src="/.com//1630774696344-1719410661547-13.png" alt="1630774696344"></p><p>再次对<code>maven_02_ssm</code>项目进行编译，又会报错，如下:</p><p><img src="/.com//1630774780211-1719410661547-14.png" alt="1630774780211"></p><p>和刚才的错误原因是一样的，maven在仓库中没有找到<code>maven_04_dao</code>,所以此时我们只需要将<code>maven_04_dao</code>安装到Maven的本地仓库即可。</p><p><strong>步骤4:将项目安装到本地仓库</strong></p><p>将需要被依赖的项目<code>maven_04_dao</code>，使用maven的install命令，把其安装到Maven的本地仓库中。</p><p><img src="/.com//1630774917743-1719410661547-15.png" alt="1630774917743"></p><p>安装成功后，在对应的路径下就看到了安装好对应的jar包</p><p><img src="/.com//1630774946856-1719410661547-16.png" alt="1630774946856"></p><p>当再次执行<code>maven_02_ssm</code>的compile的指令后，就已经能够成功编译。</p><h4 id="运行测试并总结"><a href="#运行测试并总结" class="headerlink" title="运行测试并总结"></a>运行测试并总结</h4><p>将抽取后的项目进行运行，测试之前的增删改查功能依然能够使用。</p><p>所以对于项目的拆分，大致会有如下几个步骤:</p><p>(1) 创建Maven模块</p><p>(2) 书写模块代码</p><p>分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。拆分方式可以按照功能拆也可以按照模块拆。</p><p>(3)通过maven指令安装模块到本地仓库(install 指令)</p><p>团队内部开发需要发布模块功能到团队内部可共享的仓库中(私服)，私服我们后面会讲解。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>我们现在已经能把项目拆分成一个个独立的模块，当在其他项目中想要使用独立出来的这些模块，只需要在其pom.xml使用<dependency>标签来进行jar包的引入即可。</dependency></p><p><dependency>其实就是依赖，关于依赖管理里面都涉及哪些内容，我们就一个个来学习下:</dependency></p><ul><li>依赖传递</li><li>可选依赖</li><li>排除依赖</li></ul><p>我们先来说说什么是依赖:</p><p>依赖指当前项目运行所需的jar，一个项目可以设置多个依赖。</p><p>格式为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置当前项目所依赖的所有jar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置具体的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属群组id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属项目id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖传递与冲突问题"><a href="#依赖传递与冲突问题" class="headerlink" title="依赖传递与冲突问题"></a>依赖传递与冲突问题</h3><p>回到我们刚才的项目案例中，打开Maven的面板，你会发现:</p><p><img src="/.com//1630818930387-1719410661547-17.png"></p><p>在项目所依赖的这些jar包中，有一个比较大的区别就是<strong>有的依赖前面有箭头<code>&gt;</code>,有的依赖前面没有。</strong></p><p>那么这个箭头所代表的含义是什么?</p><p>打开前面的箭头，你会发现这个jar包下面还包含有其他的jar包</p><p><img src="/.com//1630819455928-1719410661547-18.png" alt="1630819455928"></p><p>你会发现有两个<code>maven_03_pojo</code>的依赖被加载到Dependencies中，那么<code>maven_04_dao</code>中的<code>maven_03_pojo</code>能不能使用呢?</p><p>要想验证非常简单，只需要把<code>maven_02_ssm</code>项目中pom.xml关于<code>maven_03_pojo</code>的依赖注释或删除掉</p><p><img src="/.com//1630819768305-1719410661547-19.png" alt="1630819768305"></p><p>在Dependencies中移除自己所添加<code>maven_03_pojo</code>依赖后，打开BookServiceImpl的类，你会发现Book类依然存在，可以被正常使用</p><p><img src="/.com//1630819826163-1719410661547-20.png" alt="1630819826163"></p><p>这个特性其实就是我们要讲解的&#x3D;&#x3D;依赖传递&#x3D;&#x3D;。</p><p>依赖是具有传递性的:</p><p><img src="/.com//1630853726532-1719410661547-21.png" alt="1630853726532"></p><p>**说明:**A代表自己的项目；B,C,D,E,F,G代表的是项目所依赖的jar包；D1和D2 E1和E2代表是相同jar包的不同版本</p><p>(1) A依赖了B和C,B和C有分别依赖了其他jar包，所以在A项目中就可以使用上面所有jar包，这就是所说的依赖传递</p><p>(2) 依赖传递有直接依赖和间接依赖</p><ul><li>相对于A来说，A直接依赖B和C,间接依赖了D1,E1,G，F,D2和E2</li><li>相对于B来说，B直接依赖了D1和E1,间接依赖了G</li><li>直接依赖和间接依赖是一个相对的概念</li></ul><p>(3)因为有依赖传递的存在，就会导致jar包在依赖的过程中出现冲突问题，具体什么是冲突?Maven是如何解决冲突的?</p><p>这里所说的&#x3D;&#x3D;依赖冲突&#x3D;&#x3D;是指项目依赖的某一个jar包，有多个不同的版本，因而造成类包版本冲突。</p><p>情况一: 在<code>maven_02_ssm</code>的pom.xml中添加两个不同版本的Junit依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/.com//1630820964663-1719410661547-22.png" alt="1630820964663"></p><p>通过对比，会发现一个结论</p><ul><li>特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的。</li></ul><p>情况二: 路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高</p><ul><li>A通过B间接依赖到E1</li><li>A通过C间接依赖到E2</li><li>A就会间接依赖到E1和E2,Maven会按照层级来选择，E1是2度，E2是3度，所以最终会选择E1</li></ul><p>情况三: 声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的</p><ul><li>A通过B间接依赖到D1</li><li>A通过C间接依赖到D2</li><li>D1和D2都是两度，这个时候就不能按照层级来选择，需要按照声明来，谁先声明用谁，也就是说B在C之前声明，这个时候使用的是D1，反之则为D2</li></ul><p>但是对应上面这些结果，大家不需要刻意去记它。因为不管Maven怎么选，最终的结果都会在Maven的<code>Dependencies</code>面板中展示出来，展示的是哪个版本，也就是说它选择的就是哪个版本，如:</p><p><img src="/.com//1630853443920-1719410661547-23.png" alt="1630853443920"></p><p>如果想更全面的查看Maven中各个坐标的依赖关系，可以点击Maven面板中的<code>show Dependencies</code></p><p><img src="/.com//1630853519736-1719410661547-24.png" alt="1630853519736"></p><p>在这个视图中就能很明显的展示出jar包之间的相互依赖关系。</p><h3 id="可选依赖和排除依赖"><a href="#可选依赖和排除依赖" class="headerlink" title="可选依赖和排除依赖"></a>可选依赖和排除依赖</h3><p>依赖传递介绍完以后，我们来思考一个问题，</p><p><img src="/.com//1630854436435-1719410661547-25.png" alt="1630854436435"></p><ul><li>maven_02_ssm 依赖了 maven_04_dao</li><li>maven_04_dao 依赖了 maven_03_pojo</li><li>因为现在有依赖传递，所以maven_02_ssm能够使用到maven_03_pojo的内容</li><li>如果说现在不想让maven_02_ssm依赖到maven_03_pojo，有哪些解决方案?</li></ul><p>**说明:**在真实使用的过程中，maven_02_ssm中是需要用到maven_03_pojo的，我们这里只是用这个例子描述我们的需求。因为有时候，maven_04_dao出于某些因素的考虑，就是不想让别人使用自己所依赖的maven_03_pojo。</p><p><strong>方案一:可选依赖</strong></p><ul><li>可选依赖指对外隐藏当前所依赖的资源—不透明</li></ul><p>在<code>maven_04_dao</code>的pom.xml,在引入<code>maven_03_pojo</code>的时候，添加<code>optional</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时BookServiceImpl就已经报错了,说明由于maven_04_dao将maven_03_pojo设置成可选依赖，导致maven_02_ssm无法引用到maven_03_pojo中的内容，导致Book类找不到。</p><p><img src="/.com//1630854923484-1719410661547-27.png" alt="1630854923484"></p><p><strong>方案二:排除依赖</strong></p><ul><li>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本—不需要</li></ul><p>前面我们已经通过可选依赖实现了阻断maven_03_pojo的依赖传递，对于排除依赖，则指的是已经有依赖的事实，也就是说maven_02_ssm项目中已经通过依赖传递用到了maven_03_pojo，此时我们需要做的是将其进行排除，所以接下来需要修改maven_02_ssm的pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_04_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样操作后，BookServiceImpl中的Book类一样也会报错。</p><p>当然<code>exclusions</code>标签带<code>s</code>说明我们是可以依次排除多个依赖到的jar包，比如maven_04_dao中有依赖junit和mybatis,我们也可以一并将其排除。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_04_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>介绍我这两种方式后，简单来梳理下，就是</p><ul><li><code>A依赖B,B依赖C</code>,<code>C</code>通过依赖传递会被<code>A</code>使用到，现在要想办法让<code>A</code>不去依赖<code>C</code></li><li>可选依赖是在B上设置<code>&lt;optional&gt;</code>,<code>A</code>不知道有<code>C</code>的存在，</li><li>排除依赖是在A上设置<code>&lt;exclusions&gt;</code>,<code>A</code>知道有<code>C</code>的存在，主动将其排除掉。</li></ul><h2 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h2><p>我们的项目已经从以前的单模块，变成了现在的多模块开发。项目一旦变成了多模块开发以后，就会引发一些问题，在这一节中我们主要会学习两个内容<code>聚合</code>和<code>继承</code>，用这两个知识来解决下分模块后的一些问题。</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><img src="/.com//1630858596147-1719410661547-26.png" alt="1630858596147"></p><ul><li>分模块开发后，需要将这四个项目都安装到本地仓库，目前我们只能通过项目Maven面板的<code>install</code>来安装，并且需要安装四个，如果我们的项目足够多，那么一个个安装起来还是比较麻烦的</li><li>如果四个项目都已经安装成功，当ssm_pojo发生变化后，我们就得将ssm_pojo重新安装到maven仓库，但是为了确保我们对ssm_pojo的修改不会影响到其他项目模块，我们需要对所有的模块进行重新编译，那又需要将所有的模块再来一遍</li></ul><p>项目少的话还好，但是如果项目多的话，一个个操作项目就容易出现漏掉或重复操作的问题，所以我们就想能不能抽取一个项目，把所有的项目管理起来，以后我们要想操作这些项目，只需要操作这一个项目，其他所有的项目都走一样的流程，这个不就很省事省力。</p><p>这就用到了我们接下来要讲解的&#x3D;&#x3D;聚合&#x3D;&#x3D;，</p><ul><li>所谓聚合:将多个模块组织成一个整体，同时进行项目构建的过程称为聚合</li><li>聚合工程：通常是一个不具有业务功能的”空”工程（有且仅有一个pom文件）</li><li>作用：使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建<ul><li>当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。</li></ul></li></ul><p>关于聚合具体的实现步骤为:</p><p><strong>步骤1:创建一个空的maven项目</strong></p><p><img src="/.com//1630859532119-1719410661547-29.png" alt="1630859532119"></p><p><strong>步骤2:将项目的打包方式改为pom</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**说明:**项目的打包方式，我们接触到的有三种，分别是</p><ul><li>jar:默认情况，说明该项目为java项目</li><li>war:说明该项目为web项目</li><li>pom:说明该项目为聚合或继承(后面会讲)项目</li></ul><p><strong>步骤3:pom.xml添加所要管理的项目</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--设置管理的模块名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_02_ssm<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_03_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_04_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤4:使用聚合统一管理项目</strong></p><p><img src="/.com//1630859797123-1719410661547-28.png" alt="1630859797123"></p><p>测试发现，当<code>maven_01_parent</code>的<code>compile</code>被点击后，所有被其管理的项目都会被执行编译操作。这就是聚合工程的作用。</p><p><strong>说明：</strong>聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。</p><p>聚合的知识我们就讲解完了，最后总结一句话就是，<strong>聚合工程主要是用来管理项目</strong>。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>我们已经完成了使用聚合工程去管理项目，聚合工程进行某一个构建操作，其他被其管理的项目也会执行相同的构建操作。那么接下来，我们再来分析下，多模块开发存在的另外一个问题，<code>重复配置</code>的问题，我们先来看张图:</p><p><img src="/.com//1630860344968-1719410661547-30.png" alt="1630860344968"></p><ul><li><code>spring-webmvc</code>、<code>spring-jdbc</code>在三个项目模块中都有出现，这样就出现了重复的内容</li><li><code>spring-test</code>只在ssm_crm和ssm_goods中出现，而在ssm_order中没有，这里是部分重复的内容</li><li>我们使用的spring版本目前是<code>5.2.10.RELEASE</code>,假如后期要想升级spring版本，所有跟Spring相关jar包都得被修改，涉及到的项目越多，维护成本越高</li></ul><p>面对上面的这些问题，我们就得用到接下来要学习的&#x3D;&#x3D;继承&#x3D;&#x3D;</p><ul><li>所谓继承:描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</li><li>作用：<ul><li>简化配置</li><li>减少版本冲突</li></ul></li></ul><p>接下来，我们到程序中去看看继承该如何实现?</p><p><strong>步骤1:创建一个空的Maven项目并将其打包方式设置为pom</strong></p><p>因为这一步和前面maven创建聚合工程的方式是一摸一样，所以我们可以单独创建一个新的工程，也可以直接和聚合公用一个工程。实际开发中，聚合和继承一般也都放在同一个项目中，但是这两个的功能是不一样的。</p><p><strong>步骤2:在子项目中设置其父工程</strong></p><p>分别在<code>maven_02_ssm</code>,<code>maven_03_pojo</code>,<code>maven_04_dao</code>的pom.xml中添加其父项目为<code>maven_01_parent</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置当前工程继承自parent工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置父项目pom.xml位置路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../maven_01_parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤3:优化子项目共有依赖导入问题</strong></p><ol><li>将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--设置管理的模块名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_02_ssm<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_03_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_04_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>删除子项目中已经被抽取到父项目的pom.xml中的jar包，如在<code>maven_02_ssm</code>的pom.xml中将已经出现在父项目的jar包删除掉</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_02_ssm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--配置当前工程继承自parent工程--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../maven_01_parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_04_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除完后，你会发现父项目中有依赖对应的jar包，子项目虽然已经将重复的依赖删除掉了，但是刷新的时候，子项目中所需要的jar包依然存在。</p><p>当项目的<code>&lt;parent&gt;</code>标签被移除掉，会发现多出来的jar包依赖也会随之消失。</p><ol start="3"><li>将<code>maven_04_dao</code>项目的pom.xml中的所有依赖删除，然后添加上<code>maven_01_parent</code>的父项目坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_04_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置当前工程继承自parent工程--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../maven_01_parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>刷新并查看Maven的面板，会发现maven_04_dao同样引入了父项目中的所有依赖。</p><p><img src="/.com//1630862406709-1719410661547-31.png" alt="1630862406709"></p><p>这样我们就可以解决刚才提到的第一个问题，将子项目中的公共jar包抽取到父工程中进行统一添加依赖，这样做的可以简化配置，并且当父工程中所依赖的jar包版本发生变化，所有子项目中对应的jar包版本也会跟着更新。</p><p><img src="/.com//1630943390187-1719410661547-32.png" alt="1630943390187"></p><p><strong>步骤4:优化子项目依赖版本问题</strong></p><p>如果把所有用到的jar包都管理在父项目的pom.xml，看上去更简单些，但是这样就会导致有很多项目引入了过多自己不需要的jar包。如上面看到的这张图:</p><p><img src="/.com//1630860344968-1719410661547-30.png"></p><p>如果把所有的依赖都放在了父工程中进行统一维护，就会导致ssm_order项目中多引入了<code>spring-test</code>的jar包，如果这样的jar包过多的话，对于ssm_order来说也是一种”负担”。</p><p>那针对于这种部分项目有的jar包，我们该如何管理优化呢?</p><ol><li>在父工程mavne_01_parent的pom.xml来定义依赖管理</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义依赖管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>将maven_02_ssm的pom.xml中的junit依赖删除掉，刷新Maven</li></ol><p><img src="/.com//1630944335419-1719410661547-33.png" alt="1630944335419"></p><p>刷新完会发现，在maven_02_ssm项目中的junit依赖并没有出现，所以我们得到一个结论:</p><p>&#x3D;&#x3D;<code>&lt;dependencyManagement&gt;</code>标签不真正引入jar包，而是配置可供子项目选择的jar包依赖&#x3D;&#x3D;</p><p>子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定<code>&lt;version&gt;</code></p><ol start="3"><li>在maven_02_ssm的pom.xml添加junit的依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：这里就不需要添加版本了，这样做的好处就是当父工程dependencyManagement标签中的版本发生变化后，子项目中的依赖版本也会跟着发生变化</strong></p><ol start="4"><li>在maven_04_dao的pom.xml添加junit的依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个时候，maven_02_ssm和maven_04_dao这两个项目中的junit版本就会跟随着父项目中的标签dependencyManagement中junit的版本发生变化而变化。不需要junit的项目就不需要添加对应的依赖即可。</p><p>至此继承就已经学习完了，总结来说，继承可以帮助做两件事</p><ul><li>将所有项目公共的jar包依赖提取到父工程的pom.xml中，子项目就可以不用重复编写，简化开发</li><li>将所有项目的jar包配置到父工程的dependencyManagement标签下，实现版本管理，方便维护<ul><li>&#x3D;&#x3D;dependencyManagement标签不真正引入jar包，只是管理jar包的版本&#x3D;&#x3D;</li><li>子项目在引入的时候，只需要指定groupId和artifactId，不需要加version</li><li>当dependencyManagement标签中jar包版本发生变化，所有子项目中有用到该jar包的地方对应的版本会自动随之更新</li></ul></li></ul><p>最后总结一句话就是，<strong>父工程主要是用来快速配置依赖jar包和管理项目中所使用的资源</strong>。</p><p><strong>小结</strong></p><p>继承的实现步骤:</p><ul><li><p>创建Maven模块，设置打包类型为pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在父工程的pom文件中配置依赖关系(子工程将沿用父工程中的依赖关系),一般只抽取子项目中公有的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在父工程中配置子工程中可选的依赖关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在子工程中配置当前工程所继承的父工程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义该工程的父工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--填写父工程的pom文件,可以不写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../maven_01_parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在子工程中配置使用父工程中可选依赖的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意事项:</p><p>1.子工程中使用父工程中的可选依赖时，仅需要提供群组id和项目id，无需提供版本，版本由父工程统一提供，避免版本冲突</p><p>2.子工程中还可以定义父工程中没有定义的依赖关系,只不过不能被父工程进行版本统一管理。</p></li></ul><h3 id="聚合与继承的区别"><a href="#聚合与继承的区别" class="headerlink" title="聚合与继承的区别"></a>聚合与继承的区别</h3><h4 id="聚合与继承的区别-1"><a href="#聚合与继承的区别-1" class="headerlink" title="聚合与继承的区别"></a>聚合与继承的区别</h4><p>两种之间的作用:</p><ul><li>聚合用于快速构建项目，对项目进行管理</li><li>继承用于快速配置和管理子项目中所使用jar包的版本</li></ul><p>聚合和继承的相同点:</p><ul><li>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li><li>聚合与继承均属于设计型模块，并无实际的模块内容</li></ul><p>聚合和继承的不同点:</p><ul><li>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul><p>相信到这里，大家已经能区分开什么是聚合和继承，但是有一个稍微麻烦的地方就是聚合和继承的工程构建，需要在聚合项目中手动添加<code>modules</code>标签，需要在所有的子项目中添加<code>parent</code>标签，万一写错了咋办?</p><h4 id="构建聚合与继承工程"><a href="#构建聚合与继承工程" class="headerlink" title="构建聚合与继承工程"></a>构建聚合与继承工程</h4><p>其实对于聚合和继承工程的创建，IDEA已经能帮助我们快速构建，具体的实现步骤为:</p><p><strong>步骤1:创建一个Maven项目</strong></p><p>创建一个空的Maven项目，可以将项目中的<code>src</code>目录删除掉，这个项目作为聚合工程和父工程。</p><p><img src="/.com//1630946592924-1719410661547-34.png" alt="1630946592924"></p><p><strong>步骤2:创建子项目</strong></p><p>该项目可以被聚合工程管理，同时会继承父工程。</p><p><img src="/.com//1630947082716-1719410661547-35.png" alt="1630947082716"></p><p>创建成功后，maven_parent即是聚合工程又是父工程，maven_web中也有parent标签，继承的就是maven_parent,对于难以配置的内容都自动生成。</p><p>按照上面这种方式，大家就可以根据自己的需要来构建分模块项目。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>在这一章节内容中，我们将学习两个内容，分别是</p><ul><li>属性</li><li>版本管理</li></ul><p>属性中会继续解决分模块开发项目存在的问题，版本管理主要是认识下当前主流的版本定义方式。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>讲解内容之前，我们还是先来分析问题:</p><p>前面我们已经在父工程中的dependencyManagement标签中对项目中所使用的jar包版本进行了统一的管理，但是如果在标签中有如下的内容:</p><p><img src="/.com//1630947403475-1719410661547-36.png" alt="1630947403475"></p><p>你会发现，如果我们现在想更新Spring的版本，你会发现我们依然需要更新多个jar包的版本，这样的话还是有可能出现漏改导致程序出问题，而且改起来也是比较麻烦。</p><p>问题清楚后，我们需要解决的话，就可以参考咱们java基础所学习的变量，声明一个变量，在其他地方使用该变量，当变量的值发生变化后，所有使用变量的地方，就会跟着修改，即:</p><p><img src="/.com//1630947749661-1719410661547-37.png" alt="1630947749661"></p><h4 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h4><p><strong>步骤1:父工程中定义属性</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-spring.version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">mybatis-spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤2:修改依赖的version</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，我们只需要更新父工程中properties标签中所维护的jar包版本，所有子项目中的版本也就跟着更新。当然除了将spring相关版本进行维护，我们可以将其他的jar包版本也进行抽取，这样就可以对项目中所有jar包的版本进行统一维护，如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-spring.version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">mybatis-spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件加载属性"><a href="#配置文件加载属性" class="headerlink" title="配置文件加载属性"></a>配置文件加载属性</h3><p>Maven中的属性我们已经介绍过了，现在也已经能够通过Maven来集中管理Maven中依赖jar包的版本。但是又有新的需求，就是想让Maven对于属性的管理范围能更大些，比如我们之前项目中的<code>jdbc.properties</code>，这个配置文件中的属性，能不能也来让Maven进行管理呢?</p><p>答案是肯定的，具体的实现步骤为:</p><p><strong>步骤1:父工程定义属性</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤2:jdbc.properties文件中引用属性</strong></p><p>在jdbc.properties，将jdbc.url的值直接获取Maven配置的属性</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">$&#123;jdbc.url&#125;</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><p><strong>步骤3:设置maven过滤文件范围</strong></p><p>Maven在默认情况下是从当前项目的<code>src\main\resources</code>下读取文件进行打包。现在我们需要打包的资源文件是在maven_02_ssm下,需要我们通过配置来指定下具体的资源目录。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置资源目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>../maven_02_ssm/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置能够解析$&#123;&#125;，默认是false --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**说明:**directory路径前要添加<code>../</code>的原因是maven_02_ssm相对于父工程的pom.xml路径是在其上一层的目录中，所以需要添加。</p><p>修改完后，注意maven_02_ssm项目的resources目录就多了些东西，如下:</p><p><img src="/.com//1630977419627-1719410661547-38.png" alt="1630977419627"></p><p><strong>步骤4:测试是否生效</strong></p><p>测试的时候，只需要将maven_02_ssm项目进行打包，然后观察打包结果中最终生成的内容是否为Maven中配置的内容。</p><p><img src="/.com//1630977885030-1719410661547-39.png" alt="1630977885030"></p><p>上面的属性管理就已经完成，但是有一个问题没有解决，因为不只是maven_02_ssm项目需要有属性被父工程管理，如果有多个项目需要配置，该如何实现呢?</p><p>方式一:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置资源目录，并设置能够解析$&#123;&#125;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>../maven_02_ssm/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>../maven_03_pojo/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以配，但是如果项目够多的话，这个配置也是比较繁琐</p><p>方式二:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">$&#123;project.basedir&#125;: 当前项目所在目录,子项目继承了父项目，</span></span><br><span class="line"><span class="comment">相当于所有的子项目都添加了资源目录的过滤</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**说明:**打包的过程中如果报如下错误:</p><p><img src="/.com//1630948929828-1719410661547-40.png" alt="1630948929828"></p><p>原因就是Maven发现你的项目为web项目，就会去找web项目的入口web.xml[配置文件配置的方式]，发现没有找到，就会报错。</p><p>解决方案1：在maven_02_ssm项目的<code>src\main\webapp\WEB-INF\</code>添加一个web.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解决方案2: 配置maven打包war时，忽略web.xml检查</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">failOnMissingWebXml</span>&gt;</span>false<span class="tag">&lt;/<span class="name">failOnMissingWebXml</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面我们所使用的都是Maven的自定义属性，除了${project.basedir},它属于Maven的内置系统属性。</p><p>在Maven中的属性分为:</p><ul><li>自定义属性（常用）</li><li>内置属性</li><li>Setting属性</li><li>Java系统属性</li><li>环境变量属性</li></ul><p><img src="/.com//1630981519370-1719410661547-41.png" alt="1630981519370"></p><p>具体如何查看这些属性:</p><p>在cmd命令行中输入<code>mvn help:system</code></p><p><img src="/.com//1630981585748-1719410661547-42.png" alt="1630981585748"></p><p>具体使用，就是使用 <code>$&#123;key&#125;</code>来获取，key为等号左边的，值为等号右边的，比如获取红线的值，对应的写法为 <code>$&#123;java.runtime.name&#125;</code>。</p><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>关于这个版本管理解决的问题是，在Maven创建项目和引用别人项目的时候，我们都看到过如下内容:</p><p><img src="/.com//1630982018031-1719410661547-43.png" alt="1630982018031"></p><p>这里面有两个单词，SNAPSHOT和RELEASE，它们所代表的含义是什么呢?</p><p>我们打开Maven仓库地址<code>https://mvnrepository.com/</code></p><p><img src="/.com//1630983148662-1719410661547-44.png" alt="1630983148662"></p><p>在我们jar包的版本定义中，有两个工程版本用的比较多:</p><ul><li>SNAPSHOT（快照版本）<ul><li>项目开发过程中临时输出的版本，称为快照版本</li><li>快照版本会随着开发的进展不断更新</li></ul></li><li>RELEASE（发布版本）<ul><li>项目开发到一定阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的</li><li>即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本</li></ul></li></ul><p>除了上面的工程版本，我们还经常能看到一些发布版本:</p><ul><li>alpha版:内测版，bug多不稳定内部版本不断添加新功能</li><li>beta版:公测版，不稳定(比alpha稳定些)，bug相对较多不断添加新功能</li><li>纯数字版</li></ul><p>对于这些版本，大家只需要简单认识下即可。</p><h2 id="多环境配置与应用"><a href="#多环境配置与应用" class="headerlink" title="多环境配置与应用"></a>多环境配置与应用</h2><p>这一节中，我们会讲两个内容，分别是<code>多环境开发</code>和<code>跳过测试</code></p><h3 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h3><p><img src="/.com//1630983617755-1719410661547-45.png" alt="1630983617755"></p><ul><li>我们平常都是在自己的开发环境进行开发，</li><li>当开发完成后，需要把开发的功能部署到测试环境供测试人员进行测试使用，</li><li>等测试人员测试通过后，我们会将项目部署到生成环境上线使用。</li><li>这个时候就有一个问题是，不同环境的配置是不相同的，如不可能让三个环境都用一个数据库，所以就会有三个数据库的url配置，</li><li>我们在项目中如何配置?</li><li>要想实现不同环境之间的配置切换又该如何来实现呢?</li></ul><p>maven提供配置多种环境的设定，帮助开发者在使用过程中快速切换环境。具体实现步骤:</p><p><strong>步骤1:父工程配置多个环境,并指定默认激活环境</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开发环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dep<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设定是否为默认启动环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--生产环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.2.2.2:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.3.3.3:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤2:执行安装查看env_dep环境是否生效</strong></p><p><img src="/.com//1630983967960-1719410661547-46.png" alt="1630983967960"></p><p>查看到的结果为:</p><p><img src="/.com//1630977885030-1719410661547-39.png"></p><p><strong>步骤3:切换默认环境为生产环境</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开发环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dep<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--生产环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.2.2.2:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设定是否为默认启动环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.3.3.3:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤4:执行安装并查看env_pro环境是否生效</strong></p><p>查看到的结果为<code>jdbc:mysql://127.2.2.2:3306/ssm_db</code></p><p><img src="/.com//1630977885031-1719410661547-47.png"></p><p>虽然已经能够实现不同环境的切换，但是每次切换都是需要手动修改，如何来实现在不改变代码的前提下完成环境的切换呢?</p><p><strong>步骤5:命令行实现环境切换</strong></p><p><img src="/.com//1630984476202-1719410661547-48.png" alt="1630984476202"></p><p><strong>步骤6:执行安装并查看env_test环境是否生效</strong></p><p>查看到的结果为<code>jdbc:mysql://127.3.3.3:3306/ssm_db</code></p><p><img src="/.com//1630977885032-1719410661548-49.png"></p><p>所以总结来说，对于多环境切换只需要两步即可:</p><ul><li><p>父工程中定义多环境</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>环境名称<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>value<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用多环境(构建过程)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn 指令 -P 环境定义ID[环境定义中获取]</span><br></pre></td></tr></table></figure></li></ul><h3 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h3><p>前面在执行<code>install</code>指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行<code>test</code>,</p><p>对于<code>test</code>来说有它存在的意义，</p><ul><li>可以确保每次打包或者安装的时候，程序的正确性，假如测试已经通过在我们没有修改程序的前提下再次执行打包或安装命令，由于顺序执行，测试会被再次执行，就有点耗费时间了。</li><li>功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。</li></ul><p>遇到上面这些情况的时候，我们就想跳过测试执行下面的构建命令，具体实现方式有很多：</p><p><strong>方式一:IDEA工具实现跳过测试</strong></p><p><img src="/.com//1630985300814-1719410661548-50.png" alt="1630985300814"></p><p>图中的按钮为<code>Toggle &#39;Skip Tests&#39; Mode</code>,</p><p>Toggle翻译为切换的意思，也就是说在测试与不测试之间进行切换。</p><p>点击一下，出现测试画横线的图片，如下:</p><p><img src="/.com//1630985411766-1719410661548-51.png" alt="1630985411766"></p><p>说明测试已经被关闭，再次点击就会恢复。</p><p>这种方式最简单，但是有点”暴力”，会把所有的测试都跳过，如果我们想更精细的控制哪些跳过哪些不跳过，就需要使用配置插件的方式。</p><p><strong>方式二:配置插件实现跳过测试</strong></p><p>在父工程中的pom.xml中添加测试插件配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>false<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--排除掉不参与测试的内容--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/BookServiceTest.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>skipTests:如果为true，则跳过所有测试，如果为false，则不跳过测试</p><p>excludes：哪些测试类不参与测试，即排除，针对skipTests为false来设置的</p><p>includes: 哪些测试类要参与测试，即包含,针对skipTests为true来设置的</p><p><strong>方式三:命令行跳过测试</strong></p><p><img src="/.com//1630986926124-1719410661548-52.png" alt="1630986926124"></p><p>使用Maven的命令行，<code>mvn 指令 -D skipTests</code></p><p>注意事项:</p><ul><li>执行的项目构建指令必须包含测试生命周期，否则无效果。例如执行compile生命周期，不经过test生命周期。</li><li>该命令可以不借助IDEA，直接使用cmd命令行进行跳过测试，需要注意的是cmd要在pom.xml所在目录下进行执行。</li></ul><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><p>这一节，我们主要学习的内容是:</p><ul><li>私服简介</li><li>私服仓库分类</li><li>资源上传与下载</li></ul><p>首先来说一说什么是私服?</p><h3 id="私服简介"><a href="#私服简介" class="headerlink" title="私服简介"></a>私服简介</h3><p>团队开发现状分析</p><p><img src="/.com//1630987192620-1719410661548-53.png" alt="1630987192620"></p><p>(1)张三负责ssm_crm的开发，自己写了一个ssm_pojo模块，要想使用直接将ssm_pojo安装到本地仓库即可</p><p>(2)李四负责ssm_order的开发，需要用到张三所写的ssm_pojo模块，这个时候如何将张三写的ssm_pojo模块交给李四呢?</p><p>(3)如果直接拷贝，那么团队之间的jar包管理会非常混乱而且容器出错，这个时候我们就想能不能将写好的项目上传到中央仓库，谁想用就直接联网下载即可</p><p>(4)Maven的中央仓库不允许私人上传自己的jar包,那么我们就得换种思路，自己搭建一个类似于中央仓库的东西，把自己的内容上传上去，其他人就可以从上面下载jar包使用</p><p>(5)这个类似于中央仓库的东西就是我们接下来要学习的&#x3D;&#x3D;私服&#x3D;&#x3D;</p><p>所以到这就有两个概念，一个是私服，一个是中央仓库</p><p>私服:公司内部搭建的用于存储Maven资源的服务器</p><p>远程仓库:Maven开发团队维护的用于存储Maven资源的服务器</p><p>所以说:</p><ul><li>私服是一台独立的服务器，用于解决团队内部的资源共享与资源同步问题</li></ul><p>搭建Maven私服的方式有很多，我们来介绍其中一种使用量比较大的实现方式:</p><ul><li>Nexus<ul><li>Sonatype公司的一款maven私服产品</li><li>下载地址：<a href="https://help.sonatype.com/repomanager3/download">https://help.sonatype.com/repomanager3/download</a></li></ul></li></ul><h3 id="私服安装"><a href="#私服安装" class="headerlink" title="私服安装"></a>私服安装</h3><p><strong>步骤1:下载解压</strong></p><p>将<code>资料\latest-win64.zip</code>解压到一个空目录下。</p><p><img src="/.com//1630988572349-1719410661548-54.png" alt="1630988572349"></p><p><strong>步骤2:启动Nexus</strong></p><p><img src="/.com//1630988673245-1719410661548-55.png" alt="1630988673245"></p><p>使用cmd进入到解压目录下的<code>nexus-3.30.1-01\bin</code>,执行如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nexus.exe /run nexus</span><br></pre></td></tr></table></figure><p>看到如下内容，说明启动成功。</p><p><img src="/.com//1630988939301-1719410661548-56.png" alt="1630988939301"></p><p><strong>步骤3:浏览器访问</strong></p><p>访问地址为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8081</span><br></pre></td></tr></table></figure><p><img src="/.com//1630988857125-1719410661548-57.png" alt="1630988857125"></p><p><strong>步骤4:首次登录重置密码</strong></p><p><img src="/.com//1630988983159-1719410661548-58.png" alt="1630988983159"></p><p>输入用户名和密码进行登录，登录成功后，出现如下页面</p><p><img src="/.com//1630989052183-1719410661548-59.png" alt="1630989052183"></p><p>点击下一步，需要重新输入新密码，为了和后面的保持一致，密码修改为<code>admin</code></p><p><img src="/.com//1630989094756-1719410661548-60.png" alt="1630989094756"></p><p>设置是否运行匿名访问</p><p><img src="/.com//1630989122737-1719410661548-61.png" alt="1630989122737"></p><p>点击完成</p><p><img src="/.com//1630989136097-1719410661548-62.png" alt="1630989136097"></p><p>至此私服就已经安装成功。如果要想修改一些基础配置信息，可以使用:</p><ul><li>修改基础配置信息<ul><li>安装路径下etc目录中nexus-default.properties文件保存有nexus基础配置信息，例如默认访问端口。</li></ul></li><li>修改服务器运行配置信息<ul><li>安装路径下bin目录中nexus.vmoptions文件保存有nexus服务器启动对应的配置信息，例如默认占用内存空间。</li></ul></li></ul><h3 id="私服仓库分类"><a href="#私服仓库分类" class="headerlink" title="私服仓库分类"></a>私服仓库分类</h3><p>私服资源操作流程分析:</p><p><img src="/.com//1630989320979-1719410661548-63.png" alt="1630989320979"></p><p>(1)在没有私服的情况下，我们自己创建的服务都是安装在Maven的本地仓库中</p><p>(2)私服中也有仓库，我们要把自己的资源上传到私服，最终也是放在私服的仓库中</p><p>(3)其他人要想使用你所上传的资源，就需要从私服的仓库中获取</p><p>(4)当我们要使用的资源不是自己写的，是远程中央仓库有的第三方jar包，这个时候就需要从远程中央仓库下载，每个开发者都去远程中央仓库下速度比较慢(中央仓库服务器在国外)</p><p>(5)私服就再准备一个仓库，用来专门存储从远程中央仓库下载的第三方jar包，第一次访问没有就会去远程中央仓库下载，下次再访问就直接走私服下载</p><p>(6)前面在介绍版本管理的时候提到过有<code>SNAPSHOT</code>和<code>RELEASE</code>，如果把这两类的都放到同一个仓库，比较混乱，所以私服就把这两个种jar包放入不同的仓库</p><p>(7)上面我们已经介绍了有三种仓库，一种是存放<code>SNAPSHOT</code>的，一种是存放<code>RELEASE</code>还有一种是存放从远程仓库下载的第三方jar包，那么我们在获取资源的时候要从哪个仓库种获取呢?</p><p>(8)为了方便获取，我们将所有的仓库编成一个组，我们只需要访问仓库组去获取资源。</p><p>所有私服仓库总共分为三大类:</p><p>宿主仓库hosted </p><ul><li>保存无法从中央仓库获取的资源<ul><li>自主研发</li><li>第三方非开源项目,比如Oracle,因为是付费产品，所以中央仓库没有</li></ul></li></ul><p>代理仓库proxy </p><ul><li>代理远程仓库，通过nexus访问其他公共仓库，例如中央仓库</li></ul><p>仓库组group </p><ul><li>将若干个仓库组成一个群组，简化配置</li><li>仓库组不能保存资源，属于设计型仓库</li></ul><p><img src="/.com//1630990244010-1719410661548-64.png" alt="1630990244010"></p><h3 id="本地仓库访问私服配置"><a href="#本地仓库访问私服配置" class="headerlink" title="本地仓库访问私服配置"></a>本地仓库访问私服配置</h3><ul><li>我们通过IDEA将开发的模块上传到私服，中间是要经过本地Maven的</li><li>本地Maven需要知道私服的访问地址以及私服访问的用户名和密码</li><li>私服中的仓库很多，Maven最终要把资源上传到哪个仓库?</li><li>Maven下载的时候，又需要携带用户名和密码到私服上找对应的仓库组进行下载，然后再给IDEA</li></ul><p><img src="/.com//1630990538229-1719410661548-65.png" alt="1630990538229"></p><p>上面所说的这些内容，我们需要在本地Maven的配置文件<code>settings.xml</code>中进行配置。</p><p><strong>步骤1:私服上配置仓库</strong></p><p><img src="/.com//1630991211000-1719410661548-66.png" alt="1630991211000"></p><p><strong>说明:</strong></p><p>第5，6步骤是创建itheima-snapshot仓库</p><p>第7，8步骤是创建itheima-release仓库</p><p><strong>步骤2:配置本地Maven对私服的访问权限</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>itheima-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>itheima-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤3:配置私服的访问路径</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置仓库组的ID--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--*代表所有内容都从私服获取--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--私服仓库组maven-public的访问路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了避免阿里云Maven私服地址的影响，建议先将之前配置的阿里云Maven私服镜像地址注释掉，等练习完后，再将其恢复。</p><p><img src="/.com//1630991535107-1719410661548-67.png" alt="1630991535107"></p><p>至此本地仓库就能与私服进行交互了。</p><h3 id="私服资源上传与下载"><a href="#私服资源上传与下载" class="headerlink" title="私服资源上传与下载"></a>私服资源上传与下载</h3><p>本地仓库与私服已经建立了连接，接下来我们就需要往私服上上传资源和下载资源，具体的实现步骤为:</p><p><strong>步骤1:配置工程上传私服的具体位置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--配置当前工程保存在私服中的具体位置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--和maven/settings.xml中server中的id一致，表示使用该id对应的用户名和密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>itheima-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--release版本上传仓库的具体地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/itheima-release/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--和maven/settings.xml中server中的id一致，表示使用该id对应的用户名和密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>itheima-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--snapshot版本上传仓库的具体地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/itheima-snapshot/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤2:发布资源到私服</strong></p><p><img src="/.com//1630992305191-1719410661548-68.png" alt="1630992305191"></p><p>或者执行Maven命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>要发布的项目都需要配置<code>distributionManagement</code>标签，要么在自己的pom.xml中配置，要么在其父项目中配置，然后子项目中继承父项目即可。</p><p>发布成功，在私服中就能看到:</p><p><img src="/.com//1630992513299-1719410661548-69.png" alt="1630992513299"></p><p>现在发布是在itheima-snapshot仓库中，如果想发布到itheima-release仓库中就需要将项目pom.xml中的version修改成RELEASE即可。</p><p>如果想删除已经上传的资源，可以在界面上进行删除操作:</p><p><img src="/.com//1630992952378-1719410661548-70.png" alt="1630992952378"></p><p>如果私服中没有对应的jar，会去中央仓库下载，速度很慢。可以配置让私服去阿里云中下载依赖。</p><p><img src="/.com//1630993028454-1719410661548-71.png" alt="1630993028454"></p><p>至此私服的搭建就已经完成，相对来说有点麻烦，但是步骤都比较固定，后期大家如果需要的话，就可以参考上面的步骤一步步完成搭建即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVc</title>
      <link href="/2024/05/05/SpringMVc/"/>
      <url>/2024/05/05/SpringMVc/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h2><p>学习SpringMVC我们先来回顾下现在web程序是如何做的，咱们现在web程序大都基于三层架构来实现。</p><p>三层架构</p><p><img src="/.com//1630427303762.png" alt="1630427303762"></p><ul><li>浏览器发送一个请求给后端服务器，后端服务器现在是使用Servlet来接收请求和数据</li><li>如果所有的处理都交给Servlet来处理的话，所有的东西都耦合在一起，对后期的维护和扩展极为不利</li><li>将后端服务器Servlet拆分成三层，分别是<code>web</code>、<code>service</code>和<code>dao</code><ul><li>web层主要由servlet来处理，负责页面请求和数据的收集以及响应结果给前端</li><li>service层主要负责业务逻辑的处理</li><li>dao层主要负责数据的增删改查操作</li></ul></li><li>servlet处理请求和数据的时候，存在的问题是一个servlet只能处理一个请求</li><li>针对web层进行了优化，采用了MVC设计模式，将其设计为<code>controller</code>、<code>view</code>和<code>Model</code><ul><li>controller负责请求和数据的接收，接收后将其转发给service进行业务处理</li><li>service根据需要会调用dao对数据进行增删改查</li><li>dao把数据处理完后将结果交给service,service再交给controller</li><li>controller根据需求组装成Model和View,Model和View组合起来生成页面转发给前端浏览器</li><li>这样做的好处就是controller可以处理多个请求，并对请求进行分发，执行不同的业务操作。</li></ul></li></ul><p>随着互联网的发展，上面的模式因为是同步调用，性能慢慢的跟不是需求，所以异步调用慢慢的走到了前台，是现在比较流行的一种处理方式。</p><p><img src="/.com//1630427769938.png" alt="1630427769938"></p><ul><li>因为是异步调用，所以后端不需要返回view视图，将其去除</li><li>前端如果通过异步调用的方式进行交互，后台就需要将返回的数据转换成json格式进行返回</li><li>SpringMVC主要负责的就是<ul><li>controller如何接收请求和数据</li><li>如何将请求和数据转发给业务层</li><li>如何将响应数据转换成json发回到前端</li></ul></li></ul><p>介绍了这么多，对SpringMVC进行一个定义</p><ul><li><p>SpringMVC是一种基于Java实现MVC模型的轻量级Web框架</p></li><li><p>优点</p><ul><li>使用简单、开发便捷(相比于Servlet)</li><li>灵活性强</li></ul><p>这里所说的优点，就需要我们在使用的过程中慢慢体会。</p></li></ul><h2 id="SpringMVC入门案例"><a href="#SpringMVC入门案例" class="headerlink" title="SpringMVC入门案例"></a>SpringMVC入门案例</h2><p>因为SpringMVC是一个Web框架，将来是要替换Servlet,所以先来回顾下以前Servlet是如何进行开发的?</p><p>1.创建web工程(Maven结构)</p><p>2.设置tomcat服务器，加载web工程(tomcat插件)</p><p>3.导入坐标(Servlet)</p><p>4.定义处理请求的功能类(UserServlet)</p><p>5.设置请求映射(配置映射关系)</p><p>SpringMVC的制作过程和上述流程几乎是一致的，具体的实现流程是什么?</p><p>1.创建web工程(Maven结构)</p><p>2.设置tomcat服务器，加载web工程(tomcat插件)</p><p>3.导入坐标(SpringMVC+Servlet)</p><p>4.定义处理请求的功能类(UserController)</p><p>5.设置请求映射(配置映射关系)</p><p>6.将SpringMVC设定加载到Tomcat容器中</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h3 id="案例制作"><a href="#案例制作" class="headerlink" title="案例制作"></a>案例制作</h3><p><strong>步骤1:创建Maven项目</strong></p><p>打开IDEA,创建一个新的web项目</p><p><img src="/.com//1630428920116.png" alt="1630428920116"></p><p><strong>步骤2:补全目录结构</strong></p><p>因为使用骨架创建的项目结构不完整，需要手动补全</p><p><img src="/.com//1630429288339.png" alt="1630429288339"></p><p><strong>步骤3:导入jar包</strong></p><p>将pom.xml中多余的内容删除掉，再添加SpringMVC需要的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springmvc_01_quickstart&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;port&gt;80&lt;/port&gt;</span><br><span class="line">          &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**说明:**servlet的坐标为什么需要添加<code>&lt;scope&gt;provided&lt;/scope&gt;</code>?</p><ul><li>scope是maven中jar包依赖作用范围的描述，</li><li>如果不设置默认是<code>compile</code>在在编译、运行、测试时均有效</li><li>如果运行有效的话就会和tomcat中的servlet-api包发生冲突，导致启动报错</li><li>provided代表的是该包只在编译和测试的时候用，运行的时候无效直接使用tomcat中的，就避免冲突</li></ul><p><strong>步骤4:创建配置类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.itheima.controller&quot;)</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤5:创建Controller类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    public void save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>步骤6:使用配置类替换web.xml</strong></p><p>将web.xml删除，换成ServletContainersInitConfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;</span><br><span class="line">    //加载springmvc配置类</span><br><span class="line">    protected WebApplicationContext createServletApplicationContext() &#123;</span><br><span class="line">        //初始化WebApplicationContext对象</span><br><span class="line">        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        //加载指定配置类</span><br><span class="line">        ctx.register(SpringMvcConfig.class);</span><br><span class="line">        return ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置由springmvc控制器处理的请求映射路径</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加载spring配置类</span><br><span class="line">    protected WebApplicationContext createRootApplicationContext() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤7:配置Tomcat环境</strong></p><p><img src="/.com//1630430302683.png" alt="1630430302683"></p><p><strong>步骤8:启动运行项目</strong></p><p><img src="/.com//1630430345246.png" alt="1630430345246"></p><p><strong>步骤9:浏览器访问</strong></p><p>浏览器输入<code>http://localhost/save</code>进行访问，会报如下错误:</p><p><img src="/.com//1630430401561.png" alt="1630430401561"></p><p>页面报错的原因是后台没有指定返回的页面，目前只需要关注控制台看<code>user save ...</code>有没有被执行即可。</p><p><strong>步骤10:修改Controller返回值解决上述问题</strong></p><p>前面我们说过现在主要的是前端发送异步请求，后台响应json数据，所以接下来我们把Controller类的save方法进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ...&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次重启tomcat服务器，然后重新通过浏览器测试访问,会发现还是会报错，这次的错是404</p><p><img src="/.com//1630430658028.png" alt="1630430658028"></p><p>出错的原因是，如果方法直接返回字符串，springmvc会把字符串当成页面的名称在项目中进行查找返回，因为不存在对应返回值名称的页面，所以会报404错误，找不到资源。</p><p>而我们其实是想要直接返回的是json数据，具体如何修改呢?</p><p><strong>步骤11:设置返回数据为json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ...&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次重启tomcat服务器，然后重新通过浏览器测试访问，就能看到返回的结果数据</p><p><img src="/.com//1630430835628.png" alt="1630430835628"></p><p>至此SpringMVC的入门案例就已经完成。</p><p><strong>注意事项</strong></p><ul><li>SpringMVC是基于Spring的，在pom.xml只导入了<code>spring-webmvc</code>jar包的原因是它会自动依赖spring相关坐标</li><li>AbstractDispatcherServletInitializer类是SpringMVC提供的快速初始化Web3.0容器的抽象类</li><li>AbstractDispatcherServletInitializer提供了三个接口方法供用户实现<ul><li>createServletApplicationContext方法，创建Servlet容器时，加载SpringMVC对应的bean并放入WebApplicationContext对象范围中，而WebApplicationContext的作用范围为ServletContext范围，即整个web容器范围</li><li>getServletMappings方法，设定SpringMVC对应的请求映射路径，即SpringMVC拦截哪些请求</li><li>createRootApplicationContext方法，如果创建Servlet容器时需要加载非SpringMVC对应的bean,使用当前方法进行，使用方式和createServletApplicationContext相同。</li><li>createServletApplicationContext用来加载SpringMVC环境</li><li>createRootApplicationContext用来加载Spring环境</li></ul></li></ul><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><table><thead><tr><th>名称</th><th>@Controller</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>SpringMVC控制器类定义上方</td></tr><tr><td>作用</td><td>设定SpringMVC的核心控制器bean</td></tr></tbody></table><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><table><thead><tr><th>名称</th><th>@RequestMapping</th></tr></thead><tbody><tr><td>类型</td><td>类注解或方法注解</td></tr><tr><td>位置</td><td>SpringMVC控制器类或方法定义上方</td></tr><tr><td>作用</td><td>设置当前控制器方法请求访问路径</td></tr><tr><td>相关属性</td><td>value(默认)，请求访问路径</td></tr></tbody></table><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><table><thead><tr><th>名称</th><th>@ResponseBody</th></tr></thead><tbody><tr><td>类型</td><td>类注解或方法注解</td></tr><tr><td>位置</td><td>SpringMVC控制器类或方法定义上方</td></tr><tr><td>作用</td><td>设置当前控制器方法响应内容为当前返回值，无需解析</td></tr></tbody></table><h3 id="bean加载控制"><a href="#bean加载控制" class="headerlink" title="bean加载控制"></a>bean加载控制</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>入门案例的内容已经做完了，在入门案例中我们创建过一个<code>SpringMvcConfig</code>的配置类，再回想前面咱们学习Spring的时候也创建过一个配置类<code>SpringConfig</code>。这两个配置类都需要加载资源，那么它们分别都需要加载哪些内容?</p><p>我们先来看下目前我们的项目目录结构:</p><p><img src="/.com//1630459727575.png" alt="1630459727575"></p><ul><li>config目录存入的是配置类,写过的配置类有:<ul><li>ServletContainersInitConfig</li><li>SpringConfig</li><li>SpringMvcConfig</li><li>JdbcConfig</li><li>MybatisConfig</li></ul></li><li>controller目录存放的是SpringMVC的controller类</li><li>service目录存放的是service接口和实现类</li><li>dao目录存放的是dao&#x2F;Mapper接口</li></ul><p>controller、service和dao这些类都需要被容器管理成bean对象，那么到底是该让SpringMVC加载还是让Spring加载呢?</p><ul><li>SpringMVC加载其相关bean(表现层bean),也就是controller包下的类</li><li>Spring控制的bean<ul><li>业务bean(Service)</li><li>功能bean(DataSource,SqlSessionFactoryBean,MapperScannerConfigurer等)</li></ul></li></ul><p>分析清楚谁该管哪些bean以后，接下来要解决的问题是如何让Spring和SpringMVC分开加载各自的内容。</p><p>在SpringMVC的配置类<code>SpringMvcConfig</code>中使用注解<code>@ComponentScan</code>，我们只需要将其扫描范围设置到controller即可，如</p><p><img src="/.com//1630460319004.png" alt="1630460319004"></p><p>在Spring的配置类<code>SpringConfig</code>中使用注解<code>@ComponentScan</code>,当时扫描的范围中其实是已经包含了controller,如:</p><p><img src="/.com//1630460408159.png" alt="1630460408159"></p><p>从包结构来看的话，Spring已经多把SpringMVC的controller类也给扫描到，所以针对这个问题该如何解决，就是咱们接下来要学习的内容。</p><p>概括的描述下咱们现在的问题就是因为功能不同，如何避免Spring错误加载到SpringMVC的bean?</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>针对上面的问题，解决方案也比较简单，就是:</p><ul><li>加载Spring控制的bean的时候排除掉SpringMVC控制的bean</li></ul><p>具体该如何排除：</p><ul><li>方式一:Spring加载的bean设定扫描范围为精准范围，例如service包、dao包等</li><li>方式二:Spring加载的bean设定扫描范围为com.itheima,排除掉controller包中的bean</li><li>方式三:不区分Spring与SpringMVC的环境，加载到同一个环境中[了解即可]</li></ul><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>创建一个Web的Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springmvc_02_bean_load&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;port&gt;80&lt;/port&gt;</span><br><span class="line">          &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建对应的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;</span><br><span class="line">    protected WebApplicationContext createServletApplicationContext() &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        ctx.register(SpringMvcConfig.class);</span><br><span class="line">        return ctx;</span><br><span class="line">    &#125;</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    protected WebApplicationContext createRootApplicationContext() &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.itheima.controller&quot;)</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编写Controller，Service，Dao，Domain类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ...&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    public void save(User user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    public void save(User user) &#123;</span><br><span class="line">        System.out.println(&quot;user service ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface UserDao &#123;</span><br><span class="line">    @Insert(&quot;insert into tbl_user(name,age)values(#&#123;name&#125;,#&#123;age&#125;)&quot;)</span><br><span class="line">    public void save(User user);</span><br><span class="line">&#125;</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    //setter..getter..toString略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630461261820.png" alt="1630461261820"></p><h4 id="设置bean加载控制"><a href="#设置bean加载控制" class="headerlink" title="设置bean加载控制"></a>设置bean加载控制</h4><p>方式一:修改Spring配置类，设定扫描范围为精准范围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;comitheima.dao&quot;&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>上述只是通过例子说明可以精确指定让Spring扫描对应的包结构，真正在做开发的时候，因为Dao最终是交给<code>MapperScannerConfigurer</code>对象来进行扫描处理的，我们只需要将其扫描到service包即可。</p><p>方式二:修改Spring配置类，设定扫描范围为com.itheima,排除掉controller包中的bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(value=&quot;com.itheima&quot;,</span><br><span class="line">    excludeFilters=@ComponentScan.Filter(</span><br><span class="line">        type = FilterType.ANNOTATION,</span><br><span class="line">        classes = Controller.class</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>excludeFilters属性：设置扫描加载bean时，排除的过滤规则</p></li><li><p>type属性：设置排除规则，当前使用按照bean定义时的注解类型进行排除</p><ul><li>ANNOTATION：按照注解排除</li><li>ASSIGNABLE_TYPE:按照指定的类型过滤</li><li>ASPECTJ:按照Aspectj表达式排除，基本上不会用</li><li>REGEX:按照正则表达式排除</li><li>CUSTOM:按照自定义规则排除</li></ul><p>大家只需要知道第一种ANNOTATION即可</p></li><li><p>classes属性：设置排除的具体注解类，当前设置排除@Controller定义的bean</p></li></ul><p>如何测试controller类已经被排除掉了?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class App&#123;</span><br><span class="line">    public static void main (String[] args)&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        System.out.println(ctx.getBean(UserController.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果被排除了，该方法执行就会报bean未被定义的错误</p><p><img src="/.com//1630462200947.png" alt="1630462200947"></p><p>注意:测试的时候，需要把SpringMvcConfig配置类上的@ComponentScan注解注释掉，否则不会报错</p><p>出现问题的原因是，</p><ul><li>Spring配置类扫描的包是<code>com.itheima</code></li><li>SpringMVC的配置类，<code>SpringMvcConfig</code>上有一个@Configuration注解，也会被Spring扫描到</li><li>SpringMvcConfig上又有一个@ComponentScan，把controller类又给扫描进来了</li><li>所以如果不把@ComponentScan注释掉，Spring配置类将Controller排除，但是因为扫描到SpringMVC的配置类，又将其加载回来，演示的效果就出不来</li><li>解决方案，也简单，把SpringMVC的配置类移出Spring配置类的扫描范围即可。</li></ul><p>最后一个问题，有了Spring的配置类，要想在tomcat服务器启动将其加载，我们需要修改ServletContainersInitConfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;</span><br><span class="line">    protected WebApplicationContext createServletApplicationContext() &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        ctx.register(SpringMvcConfig.class);</span><br><span class="line">        return ctx;</span><br><span class="line">    &#125;</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    protected WebApplicationContext createRootApplicationContext() &#123;</span><br><span class="line">      AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        ctx.register(SpringConfig.class);</span><br><span class="line">        return ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述的配置方式，Spring还提供了一种更简单的配置方式，可以不用再去创建<code>AnnotationConfigWebApplicationContext</code>对象，不用手动<code>register</code>对应的配置类，如何实现?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><table><thead><tr><th>名称</th><th>@ComponentScan</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td></tr><tr><td>相关属性</td><td>excludeFilters:排除扫描路径中加载的bean,需要指定类别(type)和具体项(classes)<br>includeFilters:加载指定的bean，需要指定类别(type)和具体项(classes)</td></tr></tbody></table><h2 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h2><p>前面我们已经完成了入门案例相关的知识学习，接来了我们就需要针对SpringMVC相关的知识点进行系统的学习，之前我们提到过，SpringMVC是web层的框架，主要的作用是接收请求、接收数据、响应结果，所以这一章节是学习SpringMVC的重点内容，我们主要会讲解四部分内容:</p><ul><li>请求映射路径</li><li>请求参数</li><li>日期类型参数传递</li><li>响应json数据</li></ul><h3 id="设置请求映射路径"><a href="#设置请求映射路径" class="headerlink" title="设置请求映射路径"></a>设置请求映射路径</h3><h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>创建一个Web的Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springmvc_03_request_mapping&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;port&gt;80&lt;/port&gt;</span><br><span class="line">          &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建对应的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写BookController和UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user delete ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book save ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630466431549.png" alt="1630466431549"></p><p>把环境准备好后，启动Tomcat服务器，后台会报错:</p><p><img src="/.com//1630466555934.png" alt="1630466555934"></p><p>从错误信息可以看出:</p><ul><li>UserController有一个save方法，访问路径为<code>http://localhost/save</code></li><li>BookController也有一个save方法，访问路径为<code>http://localhost/save</code></li><li>当访问<code>http://localhost/saved</code>的时候，到底是访问UserController还是BookController?</li></ul><h4 id="4-1-2-问题分析"><a href="#4-1-2-问题分析" class="headerlink" title="4.1.2 问题分析"></a>4.1.2 问题分析</h4><p>团队多人开发，每人设置不同的请求路径，冲突问题该如何解决?</p><p>解决思路:为不同模块设置模块名作为请求路径前置</p><p>对于Book模块的save,将其访问路径设置<code>http://localhost/book/save</code></p><p>对于User模块的save,将其访问路径设置<code>http://localhost/user/save</code></p><p>这样在同一个模块中出现命名冲突的情况就比较少了。</p><h4 id="4-1-3-设置映射路径"><a href="#4-1-3-设置映射路径" class="headerlink" title="4.1.3 设置映射路径"></a>4.1.3 设置映射路径</h4><h5 id="步骤1-修改Controller"><a href="#步骤1-修改Controller" class="headerlink" title="步骤1:修改Controller"></a>步骤1:修改Controller</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/delete&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user delete ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/book/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book save ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是解决了，但是每个方法前面都需要进行修改，写起来比较麻烦而且还有很多重复代码，如果&#x2F;user后期发生变化，所有的方法都需要改，耦合度太高。</p><h5 id="步骤2-优化路径配置"><a href="#步骤2-优化路径配置" class="headerlink" title="步骤2:优化路径配置"></a>步骤2:优化路径配置</h5><p>优化方案:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user delete ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book save ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>当类上和方法上都添加了<code>@RequestMapping</code>注解，前端发送请求的时候，要和两个注解的value值相加匹配才能访问到。</li><li>@RequestMapping注解value属性前面加不加<code>/</code>都可以</li></ul><p>扩展小知识:</p><p>对于PostMan如何觉得字小不好看，可以使用<code>ctrl+=</code>调大，<code>ctrl+-</code>调小。</p><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>请求路径设置好后，只要确保页面发送请求地址和后台Controller类中配置的路径一致，就可以接收到前端的请求，接收到请求后，如何接收页面传递的参数?</p><p>关于请求参数的传递与接收是和请求方式有关系的，目前比较常见的两种请求方式为：</p><ul><li>GET</li><li>POST</li></ul><p>针对于不同的请求前端如何发送，后端如何接收?</p><h4 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>创建一个Web的Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springmvc_03_request_mapping&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;port&gt;80&lt;/port&gt;</span><br><span class="line">          &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建对应的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.itheima.controller&quot;)</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编写UserController</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/commonParam&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String commonParam()&#123;</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写模型类，User和Address</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Address &#123;</span><br><span class="line">    private String province;</span><br><span class="line">    private String city;</span><br><span class="line">    //setter...getter...略</span><br><span class="line">&#125;</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    //setter...getter...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630467830654.png" alt="1630467830654"></p><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><h5 id="GET发送单个参数"><a href="#GET发送单个参数" class="headerlink" title="GET发送单个参数"></a>GET发送单个参数</h5><p>发送请求与参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/commonParam?name=itcast</span><br></pre></td></tr></table></figure><p><img src="/.com//1630467921300.png" alt="1630467921300"></p><p>接收参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/commonParam&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String commonParam(String name)&#123;</span><br><span class="line">        System.out.println(&quot;普通参数传递 name ==&gt; &quot;+name);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="GET发送多个参数"><a href="#GET发送多个参数" class="headerlink" title="GET发送多个参数"></a>GET发送多个参数</h5><p>发送请求与参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/commonParam?name=itcast&amp;age=15</span><br></pre></td></tr></table></figure><p><img src="/.com//1630468045733.png" alt="1630468045733"></p><p>接收参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递 name ==&gt; &quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递 age ==&gt; &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="GET请求中文乱码"><a href="#GET请求中文乱码" class="headerlink" title="GET请求中文乱码"></a>GET请求中文乱码</h5><p>如果我们传递的参数中有中文，你会发现接收到的参数会出现中文乱码问题。</p><p>发送请求:<code>http://localhost/commonParam?name=张三&amp;age=18</code></p><p>控制台:</p><p><img src="/.com//1630480536510.png" alt="1630480536510"></p><p>出现乱码的原因相信大家都清楚，Tomcat8.5以后的版本已经处理了中文乱码的问题，但是IDEA中的Tomcat插件目前只到Tomcat7，所以需要修改pom.xml来解决GET请求中文乱码问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span><span class="comment">&lt;!--tomcat端口号--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span> <span class="comment">&lt;!--虚拟目录--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span><span class="comment">&lt;!--访问路径编解码字符集--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="POST发送参数"><a href="#POST发送参数" class="headerlink" title="POST发送参数"></a>POST发送参数</h5><p>发送请求与参数:</p><p><img src="/.com//1630480812809.png" alt="1630480812809">接收参数：</p><p>和GET一致，不用做任何修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递 name ==&gt; &quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递 age ==&gt; &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="POST请求中文乱码"><a href="#POST请求中文乱码" class="headerlink" title="POST请求中文乱码"></a>POST请求中文乱码</h5><p>发送请求与参数:</p><p><img src="/.com//1630480964421.png" alt="1630480964421"></p><p>接收参数:</p><p>控制台打印，会发现有中文乱码问题。</p><p><img src="/.com//1630481008109.png" alt="1630481008109"></p><p>解决方案:配置过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乱码处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        filter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CharacterEncodingFilter是在spring-web包中，所以用之前需要导入对应的jar包。</p><h3 id="五种类型参数传递"><a href="#五种类型参数传递" class="headerlink" title="五种类型参数传递"></a>五种类型参数传递</h3><p>前面我们已经能够使用GET或POST来发送请求和数据，所携带的数据都是比较简单的数据，接下来在这个基础上，我们来研究一些比较复杂的参数传递，常见的参数种类有:</p><ul><li>普通参数</li><li>POJO类型参数</li><li>嵌套POJO类型参数</li><li>数组类型参数</li><li>集合类型参数</li></ul><p>这些参数如何发送，后台改如何接收?我们一个个来学习。</p><h4 id="普通参数"><a href="#普通参数" class="headerlink" title="普通参数"></a>普通参数</h4><ul><li>普通参数:url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数。</li></ul><p><img src="/.com//1630481585729.png" alt="1630481585729"></p><p>如果形参与地址参数名不一致该如何解决?</p><p>发送请求与参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/commonParamDifferentName?name=张三&amp;age=18</span><br></pre></td></tr></table></figure><p>后台接收参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/commonParamDifferentName&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String commonParamDifferentName(String userName , int age)&#123;</span><br><span class="line">    System.out.println(&quot;普通参数传递 userName ==&gt; &quot;+userName);</span><br><span class="line">    System.out.println(&quot;普通参数传递 age ==&gt; &quot;+age);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;common param different name&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为前端给的是<code>name</code>,后台接收使用的是<code>userName</code>,两个名称对不上，导致接收数据失败:</p><p><img src="/.com//1630481772035.png" alt="1630481772035"></p><p>解决方案:使用@RequestParam注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/commonParamDifferentName&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String commonParamDifferentName(@RequestPaam(&quot;name&quot;) String userName , int age)&#123;</span><br><span class="line">        System.out.println(&quot;普通参数传递 userName ==&gt; &quot;+userName);</span><br><span class="line">        System.out.println(&quot;普通参数传递 age ==&gt; &quot;+age);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;common param different name&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意:写上@RequestParam注解框架就不需要自己去解析注入，能提升框架处理性能</strong></p><h4 id="POJO数据类型"><a href="#POJO数据类型" class="headerlink" title="POJO数据类型"></a>POJO数据类型</h4><p>简单数据类型一般处理的是参数个数比较少的请求，如果参数比较多，那么后台接收参数的时候就比较复杂，这个时候我们可以考虑使用POJO数据类型。</p><ul><li>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数</li></ul><p>此时需要使用前面准备好的POJO类，先来看下User</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    //setter...getter...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送请求和参数:</p><p><img src="/.com//1630482186745.png" alt="1630482186745"></p><p>后台接收参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//POJO参数：请求参数与形参对象中的属性对应即可完成参数传递</span><br><span class="line">@RequestMapping(&quot;/pojoParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String pojoParam(User user)&#123;</span><br><span class="line">    System.out.println(&quot;pojo参数传递 user ==&gt; &quot;+user);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>POJO参数接收，前端GET和POST发送请求数据的方式不变。</li><li>请求参数key的名称要和POJO中属性的名称一致，否则无法封装。</li></ul><h4 id="嵌套POJO类型参数"><a href="#嵌套POJO类型参数" class="headerlink" title="嵌套POJO类型参数"></a>嵌套POJO类型参数</h4><p>如果POJO对象中嵌套了其他的POJO类，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Address &#123;</span><br><span class="line">    private String province;</span><br><span class="line">    private String city;</span><br><span class="line">    //setter...getter...略</span><br><span class="line">&#125;</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private Address address;</span><br><span class="line">    //setter...getter...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</li></ul><p>发送请求和参数:</p><p><img src="/.com//1630482363291.png" alt="1630482363291"></p><p>后台接收参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//POJO参数：请求参数与形参对象中的属性对应即可完成参数传递</span><br><span class="line">@RequestMapping(&quot;/pojoParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String pojoParam(User user)&#123;</span><br><span class="line">    System.out.println(&quot;pojo参数传递 user ==&gt; &quot;+user);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>请求参数key的名称要和POJO中属性的名称一致，否则无法封装</p><h4 id="数组类型参数"><a href="#数组类型参数" class="headerlink" title="数组类型参数"></a>数组类型参数</h4><p>举个简单的例子，如果前端需要获取用户的爱好，爱好绝大多数情况下都是多个，如何发送请求数据和接收数据呢?</p><ul><li>数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型即可接收参数</li></ul><p>发送请求和参数:</p><p><img src="/.com//1630482999626.png" alt="1630482999626"></p><p>后台接收参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//数组参数：同名请求参数可以直接映射到对应名称的形参数组对象中</span><br><span class="line">  @RequestMapping(&quot;/arrayParam&quot;)</span><br><span class="line">  @ResponseBody</span><br><span class="line">  public String arrayParam(String[] likes)&#123;</span><br><span class="line">      System.out.println(&quot;数组参数传递 likes ==&gt; &quot;+ Arrays.toString(likes));</span><br><span class="line">      return &quot;&#123;&#x27;module&#x27;:&#x27;array param&#x27;&#125;&quot;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="集合类型参数"><a href="#集合类型参数" class="headerlink" title="集合类型参数"></a>集合类型参数</h4><p>数组能接收多个值，那么集合是否也可以实现这个功能呢?</p><p>发送请求和参数:</p><p><img src="/.com//1630484283773.png" alt="1630484283773"></p><p>后台接收参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//集合参数：同名请求参数可以使用@RequestParam注解映射到对应名称的集合对象中作为数据</span><br><span class="line">@RequestMapping(&quot;/listParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String listParam(List&lt;String&gt; likes)&#123;</span><br><span class="line">    System.out.println(&quot;集合参数传递 likes ==&gt; &quot;+ likes);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行会报错，</p><p><img src="/.com//1630484339065.png" alt="1630484339065"></p><p>错误的原因是:SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数据封装到对象中，但是List是一个接口无法创建对象，所以报错。</p><p>解决方案是:使用<code>@RequestParam</code>注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//集合参数：同名请求参数可以使用@RequestParam注解映射到对应名称的集合对象中作为数据</span><br><span class="line">@RequestMapping(&quot;/listParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String listParam(@RequestParam List&lt;String&gt; likes)&#123;</span><br><span class="line">    System.out.println(&quot;集合参数传递 likes ==&gt; &quot;+ likes);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>集合保存普通参数：请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam绑定参数关系</li><li>对于简单数据类型使用数组会比集合更简单些。</li></ul><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><table><thead><tr><th>名称</th><th>@RequestParam</th></tr></thead><tbody><tr><td>类型</td><td>形参注解</td></tr><tr><td>位置</td><td>SpringMVC控制器方法形参定义前面</td></tr><tr><td>作用</td><td>绑定请求参数与处理器方法形参间的关系</td></tr><tr><td>相关参数</td><td>required：是否为必传参数 <br>defaultValue：参数默认值</td></tr></tbody></table><h3 id="JSON数据传输参数"><a href="#JSON数据传输参数" class="headerlink" title="JSON数据传输参数"></a>JSON数据传输参数</h3><p>前面我们说过，现在比较流行的开发方式为异步调用。前后台以异步方式进行交换，传输的数据使用的是JSON,所以前端如果发送的是JSON数据，后端该如何接收?</p><p>对于JSON数据类型，我们常见的有三种:</p><ul><li>json普通数组（[“value1”,”value2”,”value3”,…]）</li><li>json对象（{key1:value1,key2:value2,…}）</li><li>json对象数组（[{key1:value1,…},{key2:value2,…}]）</li></ul><p>对于上述数据，前端如何发送，后端如何接收?</p><h4 id="JSON普通数组"><a href="#JSON普通数组" class="headerlink" title="JSON普通数组"></a>JSON普通数组</h4><p><strong>步骤1:pom.xml添加依赖</strong></p><p>SpringMVC默认使用的是jackson来处理json的转换，所以需要在pom.xml添加jackson依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>步骤2:PostMan发送JSON数据</strong></p><p><img src="/.com//1630485135061.png" alt="1630485135061"></p><p><strong>步骤3:开启SpringMVC注解支持</strong></p><p>在SpringMVC的配置类中开启SpringMVC的注解支持，这里面就包含了将JSON转换成对象的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.itheima.controller&quot;)</span><br><span class="line">//开启json数据类型自动转换</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4:参数前添加@RequestBody</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据</span><br><span class="line">@RequestMapping(&quot;/listParamForJson&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String listParamForJson(@RequestBody List&lt;String&gt; likes)&#123;</span><br><span class="line">    System.out.println(&quot;list common(json)参数传递 list ==&gt; &quot;+likes);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;list common for json param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤5:启动运行程序</strong></p><p><img src="/.com//1630492624684.png" alt="1630492624684"></p><p>JSON普通数组的数据就已经传递完成，下面针对JSON对象数据和JSON对象数组的数据该如何传递呢?</p><h4 id="JSON对象数据"><a href="#JSON对象数据" class="headerlink" title="JSON对象数据"></a>JSON对象数据</h4><p>我们会发现，只需要关注请求和数据如何发送?后端数据如何接收?</p><p>请求和数据的发送:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;itcast&quot;,</span><br><span class="line">    &quot;age&quot;:15</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//1630493105450.png" alt="1630493105450"></p><p>后端接收数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/pojoParamForJson&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String pojoParamForJson(@RequestBody User user)&#123;</span><br><span class="line">    System.out.println(&quot;pojo(json)参数传递 user ==&gt; &quot;+user);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;pojo for json param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序访问测试</p><p><img src="/.com//1630493233550.png" alt="1630493233550"></p><p><strong>说明:</strong></p><p>address为null的原因是前端没有传递数据给后端。</p><p>如果想要address也有数据，我们需求修改前端传递的数据内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;itcast&quot;,</span><br><span class="line">    &quot;age&quot;:15,</span><br><span class="line">    &quot;address&quot;:&#123;</span><br><span class="line">        &quot;province&quot;:&quot;beijing&quot;,</span><br><span class="line">        &quot;city&quot;:&quot;beijing&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次发送请求，就能看到address中的数据</p><p><img src="/.com//1630493450694.png" alt="1630493450694"></p><h4 id="JSON对象数组"><a href="#JSON对象数组" class="headerlink" title="JSON对象数组"></a>JSON对象数组</h4><p>集合中保存多个POJO该如何实现?</p><p>请求和数据的发送:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;&quot;name&quot;:&quot;itcast&quot;,&quot;age&quot;:15&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;itheima&quot;,&quot;age&quot;:12&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p> <img src="/.com//1630493501205.png" alt="1630493501205"></p><p>后端接收数据:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/listPojoParamForJson&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String listPojoParamForJson(@RequestBody List&lt;User&gt; list)&#123;</span><br><span class="line">    System.out.println(&quot;list pojo(json)参数传递 list ==&gt; &quot;+list);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;list pojo for json param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序访问测试</p><p><img src="/.com//1630493561137.png" alt="1630493561137"></p><p><strong>小结</strong></p><p>SpringMVC接收JSON数据的实现步骤为:</p><p>(1)导入jackson包</p><p>(2)使用PostMan发送JSON数据</p><p>(3)开启SpringMVC注解驱动，在配置类上添加@EnableWebMvc注解</p><p>(4)Controller方法的参数前添加@RequestBody注解</p><h4 id="EnableWebMvc"><a href="#EnableWebMvc" class="headerlink" title="@EnableWebMvc"></a>@EnableWebMvc</h4><table><thead><tr><th>名称</th><th>@EnableWebMvc</th></tr></thead><tbody><tr><td>类型</td><td>配置类注解</td></tr><tr><td>位置</td><td>SpringMVC配置类定义上方</td></tr><tr><td>作用</td><td>开启SpringMVC多项辅助功能</td></tr></tbody></table><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><table><thead><tr><th>名称</th><th>@RequestBody</th></tr></thead><tbody><tr><td>类型</td><td>形参注解</td></tr><tr><td>位置</td><td>SpringMVC控制器方法形参定义前面</td></tr><tr><td>作用</td><td>将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次</td></tr></tbody></table><h4 id="RequestBody与-RequestParam区别"><a href="#RequestBody与-RequestParam区别" class="headerlink" title="@RequestBody与@RequestParam区别"></a>@RequestBody与@RequestParam区别</h4><ul><li>区别<ul><li>@RequestParam用于接收url地址传参，表单传参【application&#x2F;x-www-form-urlencoded】</li><li>@RequestBody用于接收json数据【application&#x2F;json】</li></ul></li><li>应用<ul><li>后期开发中，发送json格式数据为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li></ul></li></ul><h3 id="日期类型参数传递"><a href="#日期类型参数传递" class="headerlink" title="日期类型参数传递"></a>日期类型参数传递</h3><p>前面我们处理过简单数据类型、POJO数据类型、数组和集合数据类型以及JSON数据类型，接下来我们还得处理一种开发中比较常见的一种数据类型，<code>日期类型</code></p><p>日期类型比较特殊，因为对于日期的格式有N多中输入方式，比如:</p><ul><li>2088-08-18</li><li>2088&#x2F;08&#x2F;18</li><li>08&#x2F;18&#x2F;2088</li><li>……</li></ul><p>针对这么多日期格式，SpringMVC该如何接收，它能很好的处理日期类型数据么?</p><p><strong>步骤1:编写方法接收日期数据</strong></p><p>在UserController类中添加方法，把参数设置为日期类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/dataParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String dataParam(Date date)</span><br><span class="line">    System.out.println(&quot;参数传递 date ==&gt; &quot;+date);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:启动Tomcat服务器</strong></p><p>查看控制台是否报错，如果有错误，先解决错误。</p><p><strong>步骤3:使用PostMan发送请求</strong></p><p>使用PostMan发送GET请求，并设置date参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/dataParam?date=2088/08/08</span><br></pre></td></tr></table></figure><p><img src="/.com//1630494320917.png" alt="1630494320917"></p><p><strong>步骤4:查看控制台</strong></p><p><img src="/.com//1630494443738.png" alt="1630494443738"></p><p>通过打印，我们发现SpringMVC可以接收日期数据类型，并将其打印在控制台。</p><p>这个时候，我们就想如果把日期参数的格式改成其他的，SpringMVC还能处理么?</p><p><strong>步骤5:更换日期格式</strong></p><p>为了能更好的看到程序运行的结果，我们在方法中多添加一个日期参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/dataParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String dataParam(Date date,Date date1)</span><br><span class="line">    System.out.println(&quot;参数传递 date ==&gt; &quot;+date);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用PostMan发送请求，携带两个不同的日期格式，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/dataParam?date=2088/08/08&amp;date1=2088-08-08</span><br></pre></td></tr></table></figure><p><img src="/.com//1630494565970.png" alt="1630494565970"></p><p>发送请求和数据后，页面会报400，控制台会报出一个错误</p><p>Resolved [org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type ‘java.lang.String’ to required type ‘java.util.Date’; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.util.Date] for value ‘2088-08-08’; nested exception is java.lang.IllegalArgumentException]</p><p>从错误信息可以看出，错误的原因是在将<code>2088-08-08</code>转换成日期类型的时候失败了，原因是SpringMVC默认支持的字符串转日期的格式为<code>yyyy/MM/dd</code>,而我们现在传递的不符合其默认格式，SpringMVC就无法进行格式转换，所以报错。</p><p>解决方案也比较简单，需要使用<code>@DateTimeFormat</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/dataParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String dataParam(Date date,</span><br><span class="line">                        @DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;) Date date1)</span><br><span class="line">    System.out.println(&quot;参数传递 date ==&gt; &quot;+date);</span><br><span class="line">    System.out.println(&quot;参数传递 date1(yyyy-MM-dd) ==&gt; &quot;+date1);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动服务器，重新发送请求测试，SpringMVC就可以正确的进行日期转换了</p><p><img src="/.com//1630495221038.png" alt="1630495221038"></p><p><strong>步骤6:携带时间的日期</strong></p><p>接下来我们再来发送一个携带时间的日期，看下SpringMVC该如何处理?</p><p>先修改UserController类，添加第三个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/dataParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String dataParam(Date date,</span><br><span class="line">                        @DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;) Date date1,</span><br><span class="line">                        @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;) Date date2)</span><br><span class="line">    System.out.println(&quot;参数传递 date ==&gt; &quot;+date);</span><br><span class="line">    System.out.println(&quot;参数传递 date1(yyyy-MM-dd) ==&gt; &quot;+date1);</span><br><span class="line">    System.out.println(&quot;参数传递 date2(yyyy/MM/dd HH:mm:ss) ==&gt; &quot;+date2);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用PostMan发送请求，携带两个不同的日期格式，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/dataParam?date=2088/08/08&amp;date1=2088-08-08&amp;date2=2088/08/08 8:08:08</span><br></pre></td></tr></table></figure><p><img src="/.com//1630495347289.png" alt="1630495347289"></p><p>重新启动服务器，重新发送请求测试，SpringMVC就可以将日期时间的数据进行转换</p><p><img src="/.com//1630495507353.png" alt="1630495507353"></p><h4 id="DateTimeFormat"><a href="#DateTimeFormat" class="headerlink" title="@DateTimeFormat"></a>@DateTimeFormat</h4><table><thead><tr><th>名称</th><th>@DateTimeFormat</th></tr></thead><tbody><tr><td>类型</td><td>形参注解</td></tr><tr><td>位置</td><td>SpringMVC控制器方法形参前面</td></tr><tr><td>作用</td><td>设定日期时间型数据格式</td></tr><tr><td>相关属性</td><td>pattern：指定日期时间格式字符串</td></tr></tbody></table><h4 id="内部实现原理"><a href="#内部实现原理" class="headerlink" title="内部实现原理"></a>内部实现原理</h4><p>讲解内部原理之前，我们需要先思考个问题:</p><ul><li>前端传递字符串，后端使用日期Date接收</li><li>前端传递JSON数据，后端使用对象接收</li><li>前端传递字符串，后端使用Integer接收</li><li>后台需要的数据类型有很多中</li><li>在数据的传递过程中存在很多类型的转换</li></ul><p>问:谁来做这个类型转换?</p><p>答:SpringMVC</p><p>问:SpringMVC是如何实现类型转换的?</p><p>答:SpringMVC中提供了很多类型转换接口和实现类</p><p>在框架中，有一些类型转换接口，其中有:</p><ul><li>(1) Converter接口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*   S: the source type</span><br><span class="line">*   T: the target type</span><br><span class="line">*/</span><br><span class="line">public interface Converter&lt;S, T&gt; &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    //该方法就是将从页面上接收的数据(S)转换成我们想要的数据类型(T)返回</span><br><span class="line">    T convert(S source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:Converter所属的包为<code>org.springframework.core.convert.converter</code></strong></p><p>Converter接口的实现类</p><p><img src="/.com//1630496385398.png" alt="1630496385398"></p><p>框架中有提供很多对应Converter接口的实现类，用来实现不同数据类型之间的转换,如:</p><p>请求参数年龄数据（String→Integer）</p><p>日期格式转换（String → Date）</p><ul><li>(2) HttpMessageConverter接口</li></ul><p>该接口是实现对象与JSON之间的转换工作</p><p><strong>注意:SpringMVC的配置类把@EnableWebMvc当做标配配置上去，不要省略</strong></p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>SpringMVC接收到请求和数据后，进行一些了的处理，当然这个处理可以是转发给Service，Service层再调用Dao层完成的，不管怎样，处理完以后，都需要将结果告知给用户。</p><p>比如:根据用户ID查询用户信息、查询用户列表、新增用户等。</p><p>对于响应，主要就包含两部分内容：</p><ul><li>响应页面</li><li>响应数据<ul><li>文本数据</li><li>json数据</li></ul></li></ul><p>因为异步调用是目前常用的主流方式，所以我们需要更关注的就是如何返回JSON数据，对于其他只需要认识了解即可。</p><h4 id="环境准备-3"><a href="#环境准备-3" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>创建一个Web的Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springmvc_05_response&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;port&gt;80&lt;/port&gt;</span><br><span class="line">          &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建对应的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //乱码处理</span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new CharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        return new Filter[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.itheima.controller&quot;)</span><br><span class="line">//开启json数据类型自动转换</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编写模型类User</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    //getter...setter...toString省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>webapp下创建page.jsp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello Spring MVC!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写UserController</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630497314131.png" alt="1630497314131"></p><h4 id="响应页面-了解"><a href="#响应页面-了解" class="headerlink" title="响应页面[了解]"></a>响应页面[了解]</h4><p><strong>步骤1:设置返回页面</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/toJumpPage&quot;)</span><br><span class="line">    //注意</span><br><span class="line">    //1.此处不能添加@ResponseBody,如果加了该注入，会直接将page.jsp当字符串返回前端</span><br><span class="line">    //2.方法需要返回String</span><br><span class="line">    public String toJumpPage()&#123;</span><br><span class="line">        System.out.println(&quot;跳转页面&quot;);</span><br><span class="line">        return &quot;page.jsp&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:启动程序测试</strong></p><p>此处涉及到页面跳转，所以不适合采用PostMan进行测试，直接打开浏览器，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/toJumpPage</span><br></pre></td></tr></table></figure><p><img src="/.com//1630497496785.png" alt="1630497496785"></p><h4 id="返回文本数据-了解"><a href="#返回文本数据-了解" class="headerlink" title="返回文本数据[了解]"></a>返回文本数据[了解]</h4><p><strong>步骤1:设置返回文本内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/toText&quot;)</span><br><span class="line">    //注意此处该注解就不能省略，如果省略了,会把response text当前页面名称去查找，如果没有回报404错误</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String toText()&#123;</span><br><span class="line">        System.out.println(&quot;返回纯文本数据&quot;);</span><br><span class="line">        return &quot;response text&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:启动程序测试</strong></p><p>此处不涉及到页面跳转，因为我们现在发送的是GET请求，可以使用浏览器也可以使用PostMan进行测试，输入地址<code>http://localhost/toText</code>访问</p><p><img src="/.com//1630497741388.png" alt="1630497741388"></p><h4 id="响应JSON数据"><a href="#响应JSON数据" class="headerlink" title="响应JSON数据"></a>响应JSON数据</h4><p><strong>响应POJO对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/toJsonPOJO&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public User toJsonPOJO()&#123;</span><br><span class="line">        System.out.println(&quot;返回json对象数据&quot;);</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setName(&quot;itcast&quot;);</span><br><span class="line">        user.setAge(15);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖@ResponseBody注解和@EnableWebMvc注解</p><p>重新启动服务器，访问<code>http://localhost/toJsonPOJO</code></p><p><img src="/.com//1630497954896.png" alt="1630497954896"></p><p><strong>响应POJO集合对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/toJsonList&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public List&lt;User&gt; toJsonList()&#123;</span><br><span class="line">        System.out.println(&quot;返回json集合数据&quot;);</span><br><span class="line">        User user1 = new User();</span><br><span class="line">        user1.setName(&quot;传智播客&quot;);</span><br><span class="line">        user1.setAge(15);</span><br><span class="line"></span><br><span class="line">        User user2 = new User();</span><br><span class="line">        user2.setName(&quot;黑马程序员&quot;);</span><br><span class="line">        user2.setAge(12);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = new ArrayList&lt;User&gt;();</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line"></span><br><span class="line">        return userList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重新启动服务器，访问<code>http://localhost/toJsonList</code></p><p><img src="/.com//1630498084047.png" alt="1630498084047"></p><h4 id="ResponseBody-1"><a href="#ResponseBody-1" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><table><thead><tr><th>名称</th><th>@ResponseBody</th></tr></thead><tbody><tr><td>类型</td><td>方法\类注解</td></tr><tr><td>位置</td><td>SpringMVC控制器方法定义上方和控制类上</td></tr><tr><td>作用</td><td>设置当前控制器返回值作为响应体,<br>写在类上，该类的所有方法都有该注解功能</td></tr><tr><td>相关属性</td><td>pattern：指定日期时间格式字符串</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li>该注解可以写在类上或者方法上</li><li>写在类上就是该类下的所有方法都有@ReponseBody功能</li><li>当方法上有@ReponseBody注解后<ul><li>方法的返回值为字符串，会将其作为文本内容直接响应给前端</li><li>方法的返回值为对象，会将对象转换成JSON响应给前端</li></ul></li></ul><p>此处又使用到了类型转换，内部还是通过Converter接口的实现类完成的，所以Converter除了前面所说的功能外，它还可以实现:</p><ul><li>对象转Json数据(POJO -&gt; json)</li><li>集合转Json数据(Collection -&gt; json)</li></ul><h2 id="Rest风格"><a href="#Rest风格" class="headerlink" title="Rest风格"></a>Rest风格</h2><ul><li><p>REST（Representational State Transfer），表现形式状态转换,它是一种软件架构风格</p><p>当我们想表示一个网络资源的时候，可以使用两种方式:</p><ul><li>传统风格资源描述形式<ul><li><code>http://localhost/user/getById?id=1</code> 查询id为1的用户信息</li><li><code>http://localhost/user/saveUser</code> 保存用户信息</li></ul></li><li>REST风格描述形式<ul><li><code>http://localhost/user/1</code> </li><li><code>http://localhost/user</code></li></ul></li></ul></li></ul><p>传统方式一般是一个请求url对应一种操作，这样做不仅麻烦，也不安全，因为会程序的人读取了你的请求url地址，就大概知道该url实现的是一个什么样的操作。</p><p>查看REST风格的描述，你会发现请求地址变的简单了，并且光看请求URL并不是很能猜出来该URL的具体功能</p><p>所以REST的优点有:</p><ul><li>隐藏资源的访问行为，无法通过地址得知对资源是何种操作</li><li>书写简化</li></ul><p>但是我们的问题也随之而来了，一个相同的url地址即可以是新增也可以是修改或者查询，那么到底我们该如何区分该请求到底是什么操作呢?</p><ul><li>按照REST风格访问资源时使用行为动作区分对资源进行了何种操作<ul><li><code>http://localhost/users</code>查询全部用户信息 GET（查询）</li><li><code>http://localhost/users/1</code>  查询指定用户信息 GET（查询）</li><li><code>http://localhost/users</code>    添加用户信息    POST（新增&#x2F;保存）</li><li><code>http://localhost/users</code>    修改用户信息    PUT（修改&#x2F;更新）</li><li><code>http://localhost/users/1</code>  删除用户信息    DELETE（删除）</li></ul></li></ul><p>请求的方式比较多，但是比较常用的就4种，分别是<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>。</p><p>按照不同的请求方式代表不同的操作类型。</p><ul><li>发送GET请求是用来做查询</li><li>发送POST请求是用来做新增</li><li>发送PUT请求是用来做修改</li><li>发送DELETE请求是用来做删除</li></ul><p>但是注意:</p><ul><li>上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范<ul><li>REST提供了对应的架构方式，按照这种架构设计项目可以降低开发的复杂性，提高系统的可伸缩性</li><li>REST中规定GET&#x2F;POST&#x2F;PUT&#x2F;DELETE针对的是查询&#x2F;新增&#x2F;修改&#x2F;删除，但是我们如果非要用GET请求做删除，这点在程序上运行是可以实现的</li><li>但是如果绝大多数人都遵循这种风格，你写的代码让别人读起来就有点莫名其妙了。</li></ul></li><li>描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如:users、books、accounts……</li></ul><p>清楚了什么是REST风格后，我们后期会经常提到一个概念叫<code>RESTful</code>，那什么又是RESTful呢?</p><ul><li>根据REST风格对资源进行访问称为RESTful。</li></ul><p>后期我们在进行开发的过程中，大多是都是遵从REST风格来访问我们的后台服务，所以可以说咱们以后都是基于RESTful来进行开发的。</p><h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><p>前面我们已经把<code>Mybatis</code>、<code>Spring</code>和<code>SpringMVC</code>三个框架进行了学习，今天主要的内容就是把这三个框架整合在一起完成我们的业务功能开发，具体如何来整合，我们一步步来学习。</p><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>(1) 创建工程</p><ul><li>创建一个Maven的web工程</li><li>pom.xml添加SSM需要的依赖jar包</li><li>编写Web项目的入口配置类，实现<code>AbstractAnnotationConfigDispatcherServletInitializer</code>重写以下方法<ul><li>getRootConfigClasses()：返回Spring的配置类-&gt;需要SpringConfig配置类</li><li>getServletConfigClasses() ：返回SpringMVC的配置类-&gt;需要SpringMvcConfig配置类</li><li>getServletMappings()      : 设置SpringMVC请求拦截路径规则</li><li>getServletFilters()       ：设置过滤器，解决POST请求中文乱码问题</li></ul></li></ul><p>(2)SSM整合[重点是各个配置的编写]</p><ul><li>SpringConfig<ul><li>标识该类为配置类 @Configuration</li><li>扫描Service所在的包 @ComponentScan</li><li>在Service层要管理事务 @EnableTransactionManagement</li><li>读取外部的properties配置文件 @PropertySource</li><li>整合Mybatis需要引入Mybatis相关配置类 @Import<ul><li>第三方数据源配置类 JdbcConfig<ul><li>构建DataSource数据源，DruidDataSouroce,需要注入数据库连接四要素， @Bean @Value</li><li>构建平台事务管理器，DataSourceTransactionManager,@Bean</li></ul></li><li>Mybatis配置类 MybatisConfig<ul><li>构建SqlSessionFactoryBean并设置别名扫描与数据源，@Bean</li><li>构建MapperScannerConfigurer并设置DAO层的包扫描</li></ul></li></ul></li></ul></li><li>SpringMvcConfig<ul><li>标识该类为配置类 @Configuration</li><li>扫描Controller所在的包 @ComponentScan</li><li>开启SpringMVC注解支持 @EnableWebMvc</li></ul></li></ul><p>(3)功能模块[与具体的业务模块有关]</p><ul><li>创建数据库表</li><li>根据数据库表创建对应的模型类</li><li>通过Dao层完成数据库表的增删改查(接口+自动代理)</li><li>编写Service层[Service接口+实现类]<ul><li>@Service</li><li>@Transactional</li><li>整合Junit对业务层进行单元测试<ul><li>@RunWith</li><li>@ContextConfiguration</li><li>@Test</li></ul></li></ul></li><li>编写Controller层<ul><li>接收请求 @RequestMapping @GetMapping @PostMapping @PutMapping @DeleteMapping</li><li>接收数据 简单、POJO、嵌套POJO、集合、数组、JSON数据类型<ul><li>@RequestParam</li><li>@PathVariable</li><li>@RequestBody</li></ul></li><li>转发业务层 <ul><li>@Autowired</li></ul></li><li>响应结果<ul><li>@ResponseBody</li></ul></li></ul></li></ul><h3 id="整合配置"><a href="#整合配置" class="headerlink" title="整合配置"></a>整合配置</h3><p>掌握上述的知识点后，接下来，我们就可以按照上述的步骤一步步的来完成SSM的整合。</p><p><strong>步骤1：创建Maven的web项目</strong></p><p>可以使用Maven的骨架创建</p><p><img src="/.com//1630561266760.png" alt="1630561266760"></p><p><strong>步骤2:添加依赖</strong></p><p>pom.xml添加SSM所需要的依赖jar包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springmvc_08_ssm&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;port&gt;80&lt;/port&gt;</span><br><span class="line">          &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>步骤3:创建项目包结构</strong></p><p><img src="/.com//1630561591931.png" alt="1630561591931"></p><ul><li>config目录存放的是相关的配置类</li><li>controller编写的是Controller类</li><li>dao存放的是Dao接口，因为使用的是Mapper接口代理方式，所以没有实现类包</li><li>service存的是Service接口，impl存放的是Service实现类</li><li>resources:存入的是配置文件，如Jdbc.properties</li><li>webapp:目录可以存放静态资源</li><li>test&#x2F;java:存放的是测试类</li></ul><p><strong>步骤4:创建SpringConfig配置类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;com.itheima.service&quot;&#125;)</span><br><span class="line">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="line">@Import(&#123;JdbcConfig.class,MyBatisConfig.class&#125;)</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤5:创建JdbcConfig配置类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource()&#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PlatformTransactionManager transactionManager(DataSource dataSource)&#123;</span><br><span class="line">        DataSourceTransactionManager ds = new DataSourceTransactionManager();</span><br><span class="line">        ds.setDataSource(dataSource);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤6:创建MybatisConfig配置类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123;</span><br><span class="line">        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();</span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        factoryBean.setTypeAliasesPackage(&quot;com.itheima.domain&quot;);</span><br><span class="line">        return factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MapperScannerConfigurer mapperScannerConfigurer()&#123;</span><br><span class="line">        MapperScannerConfigurer msc = new MapperScannerConfigurer();</span><br><span class="line">        msc.setBasePackage(&quot;com.itheima.dao&quot;);</span><br><span class="line">        return msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤7:创建jdbc.properties</strong></p><p>在resources下提供jdbc.properties,设置数据库连接四要素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/ssm_db</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><p><strong>步骤8:创建SpringMVC配置类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.itheima.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤9:创建Web项目入口配置类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ServletConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line">    //加载Spring配置类</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    //加载SpringMVC配置类</span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置SpringMVC请求地址拦截规则</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">        //设置post请求中文乱码过滤器</span><br><span class="line">        @Override</span><br><span class="line">        protected Filter[] getServletFilters() &#123;</span><br><span class="line">            CharacterEncodingFilter filter = new CharacterEncodingFilter();</span><br><span class="line">            filter.setEncoding(&quot;utf-8&quot;);</span><br><span class="line">            return new Filter[]&#123;filter&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此SSM整合的环境就已经搭建好了。在这个环境上，我们如何进行功能模块的开发呢?</p><h3 id="功能模块开发"><a href="#功能模块开发" class="headerlink" title="功能模块开发"></a>功能模块开发</h3><blockquote><p>需求:对表tbl_book进行新增、修改、删除、根据ID查询和查询所有</p></blockquote><p><strong>步骤1:创建数据库及表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create database ssm_db character set utf8;</span><br><span class="line">use ssm_db;</span><br><span class="line">create table tbl_book(</span><br><span class="line">  id int primary key auto_increment,</span><br><span class="line">  type varchar(20),</span><br><span class="line">  name varchar(50),</span><br><span class="line">  description varchar(255)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">insert  into `tbl_book`(`id`,`type`,`name`,`description`) values (1,&#x27;计算机理论&#x27;,&#x27;Spring实战 第五版&#x27;,&#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;),(2,&#x27;计算机理论&#x27;,&#x27;Spring 5核心原理与30个类手写实践&#x27;,&#x27;十年沉淀之作，手写Spring精华思想&#x27;),(3,&#x27;计算机理论&#x27;,&#x27;Spring 5设计模式&#x27;,&#x27;深入Spring源码刨析Spring源码中蕴含的10大设计模式&#x27;),(4,&#x27;计算机理论&#x27;,&#x27;Spring MVC+Mybatis开发从入门到项目实战&#x27;,&#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;),(5,&#x27;计算机理论&#x27;,&#x27;轻量级Java Web企业应用实战&#x27;,&#x27;源码级刨析Spring框架，适合已掌握Java基础的读者&#x27;),(6,&#x27;计算机理论&#x27;,&#x27;Java核心技术 卷Ⅰ 基础知识(原书第11版)&#x27;,&#x27;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;),(7,&#x27;计算机理论&#x27;,&#x27;深入理解Java虚拟机&#x27;,&#x27;5个纬度全面刨析JVM,大厂面试知识点全覆盖&#x27;),(8,&#x27;计算机理论&#x27;,&#x27;Java编程思想(第4版)&#x27;,&#x27;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;),(9,&#x27;计算机理论&#x27;,&#x27;零基础学Java(全彩版)&#x27;,&#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;),(10,&#x27;市场营销&#x27;,&#x27;直播就这么做:主播高效沟通实战指南&#x27;,&#x27;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&#x27;),(11,&#x27;市场营销&#x27;,&#x27;直播销讲实战一本通&#x27;,&#x27;和秋叶一起学系列网络营销书籍&#x27;),(12,&#x27;市场营销&#x27;,&#x27;直播带货:淘宝、天猫直播从新手到高手&#x27;,&#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure><p><strong>步骤2:编写模型类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line">    //getter...setter...toString省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:编写Dao接口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line"></span><br><span class="line">//    @Insert(&quot;insert into tbl_book values(null,#&#123;type&#125;,#&#123;name&#125;,#&#123;description&#125;)&quot;)</span><br><span class="line">    @Insert(&quot;insert into tbl_book (type,name,description) values(#&#123;type&#125;,#&#123;name&#125;,#&#123;description&#125;)&quot;)</span><br><span class="line">    public void save(Book book);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update tbl_book set type = #&#123;type&#125;, name = #&#123;name&#125;, description = #&#123;description&#125; where id = #&#123;id&#125;&quot;)</span><br><span class="line">    public void update(Book book);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from tbl_book where id = #&#123;id&#125;&quot;)</span><br><span class="line">    public void delete(Integer id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span><br><span class="line">    public Book getById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from tbl_book&quot;)</span><br><span class="line">    public List&lt;Book&gt; getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4:编写Service接口和实现类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public interface BookService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 保存</span><br><span class="line">     * @param book</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean save(Book book);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改</span><br><span class="line">     * @param book</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean update(Book book);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按id删除</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean delete(Integer id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按id查询</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Book getById(Integer id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询全部</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;Book&gt; getAll();</span><br><span class="line">&#125;</span><br><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public boolean save(Book book) &#123;</span><br><span class="line">        bookDao.save(book);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean update(Book book) &#123;</span><br><span class="line">        bookDao.update(book);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean delete(Integer id) &#123;</span><br><span class="line">        bookDao.delete(id);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Book getById(Integer id) &#123;</span><br><span class="line">        return bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><p>bookDao在Service中注入的会提示一个红线提示，为什么呢?</p><ul><li>BookDao是一个接口，没有实现类，接口是不能创建对象的，所以最终注入的应该是代理对象</li><li>代理对象是由Spring的IOC容器来创建管理的</li><li>IOC容器又是在Web服务器启动的时候才会创建</li><li>IDEA在检测依赖关系的时候，没有找到适合的类注入，所以会提示错误提示</li><li>但是程序运行的时候，代理对象就会被创建，框架会使用DI进行注入，所以程序运行无影响。</li></ul></li><li><p>如何解决上述问题?</p><ul><li><p>可以不用理会，因为运行是正常的</p></li><li><p>设置错误提示级别</p><p><img src="/.com//1630600227357.png" alt="img"></p></li></ul></li></ul><p><strong>步骤5:编写Contorller类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public boolean save(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public boolean update(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Book getById(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于图书模块的增删改查就已经完成了编写，我们可以从后往前写也可以从前往后写，最终只需要能把功能实现即可。</p><p>接下来我们就先把业务层的代码使用<code>Spring整合Junit</code>的知识点进行单元测试:</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><strong>步骤1:新建测试类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class BookServiceTest &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:注入Service类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class BookServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:编写测试方法</strong></p><p>我们先来对查询进行单元测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class BookServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testGetById()&#123;</span><br><span class="line">        Book book = bookService.getById(1);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testGetAll()&#123;</span><br><span class="line">        List&lt;Book&gt; all = bookService.getAll();</span><br><span class="line">        System.out.println(all);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据ID查询，测试的结果为:</p><p><img src="/.com//1630600844191.png" alt="1630600844191"></p><p>查询所有，测试的结果为:</p><p><img src="/.com//1630600927486.png" alt="1630600927486"></p><h3 id="PostMan测试"><a href="#PostMan测试" class="headerlink" title="PostMan测试"></a>PostMan测试</h3><h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/books</span><br><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;:&quot;类别测试数据&quot;,</span><br><span class="line">    &quot;name&quot;:&quot;书名测试数据&quot;,</span><br><span class="line">    &quot;description&quot;:&quot;描述测试数据&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//1630652582425.png" alt="1630652582425"></p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/books</span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;:13,</span><br><span class="line">&quot;type&quot;:&quot;类别测试数据&quot;,</span><br><span class="line">    &quot;name&quot;:&quot;书名测试数据&quot;,</span><br><span class="line">    &quot;description&quot;:&quot;描述测试数据&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//1630652758221.png" alt="1630652758221"></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/books/14</span><br></pre></td></tr></table></figure><p><img src="/.com//1630652796605.png" alt="1630652796605"></p><h4 id="查询单个"><a href="#查询单个" class="headerlink" title="查询单个"></a>查询单个</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/books/1</span><br></pre></td></tr></table></figure><p><img src="/.com//1630652837682.png" alt="1630652837682"></p><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/books</span><br></pre></td></tr></table></figure><p><img src="/.com//1630652867493.png" alt="1630652867493"></p><h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在讲解这一部分知识点之前，我们先来演示个效果，修改BookController类的<code>getById</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">    //手动添加一个错误信息</span><br><span class="line">    if(id==1)&#123;</span><br><span class="line">        int i = 1/0;</span><br><span class="line">    &#125;</span><br><span class="line">    Book book = bookService.getById(id);</span><br><span class="line">    Integer code = book != null ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">    String msg = book != null ? &quot;&quot; : &quot;数据查询失败，请重试！&quot;;</span><br><span class="line">    return new Result(code,book,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动运行项目，使用PostMan发送请求，当传入的id为1，则会出现如下效果：</p><p><img src="/.com//1630656982337.png" alt="1630656982337"></p><p>前端接收到这个信息后和之前我们约定的格式不一致，这个问题该如何解决?</p><p>在解决问题之前，我们先来看下异常的种类及出现异常的原因:</p><ul><li>框架内部抛出的异常：因使用不合规导致</li><li>数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）</li><li>业务层抛出的异常：因业务逻辑书写错误导致（例如：遍历业务书写操作，导致索引异常等）</li><li>表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）</li><li>工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放等）</li></ul><p>看完上面这些出现异常的位置，你会发现，在我们开发的任何一个位置都有可能出现异常，而且这些异常是不能避免的。所以我们就得将异常进行处理。</p><p><strong>思考</strong></p><ol><li><p>各个层级均出现异常，异常处理代码书写在哪一层?</p><p>所有的异常均抛出到表现层进行处理</p></li><li><p>异常的种类很多，表现层如何将所有的异常都处理到呢?</p><p>异常分类</p></li><li><p>表现层处理异常，每个方法中单独书写，代码书写量巨大且意义不强，如何解决?</p><p>AOP</p></li></ol><p>对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案:</p><ul><li><p>异常处理器:</p><ul><li><p>集中的、统一的处理项目中出现的异常。</p><p><img src="/.com//1630657791653.png" alt="1630657791653"></p></li></ul></li></ul><h3 id="异常处理器的使用"><a href="#异常处理器的使用" class="headerlink" title="异常处理器的使用"></a>异常处理器的使用</h3><h4 id="环境准备-4"><a href="#环境准备-4" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li>创建一个Web的Maven项目</li><li>pom.xml添加SSM整合所需jar包</li><li>创建对应的配置类</li><li>编写Controller、Service接口、Service实现类、Dao接口和模型类</li><li>resources下提供jdbc.properties配置文件</li></ul><p>内容参考前面的项目或者直接使用前面的项目进行本节内容的学习。</p><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630657972564.png" alt="1630657972564"></p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><p><strong>步骤1:创建异常处理器类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//@RestControllerAdvice用于标识当前类为REST风格对应的异常处理器</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    //除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public void doException(Exception ex)&#123;</span><br><span class="line">        System.out.println(&quot;嘿嘿,异常你哪里跑！&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>确保SpringMvcConfig能够扫描到异常处理器类</p><p><strong>步骤2:让程序抛出异常</strong></p><p>修改<code>BookController</code>的getById方法，添加<code>int i = 1/0</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">    int i = 1/0;</span><br><span class="line">    Book book = bookService.getById(id);</span><br><span class="line">    Integer code = book != null ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">    String msg = book != null ? &quot;&quot; : &quot;数据查询失败，请重试！&quot;;</span><br><span class="line">    return new Result(code,book,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:运行程序，测试</strong></p><p><img src="/.com//1630658350945.png" alt="1630658350945"></p><p>说明异常已经被拦截并执行了<code>doException</code>方法。</p><h5 id="异常处理器类返回结果给前端"><a href="#异常处理器类返回结果给前端" class="headerlink" title="异常处理器类返回结果给前端"></a>异常处理器类返回结果给前端</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//@RestControllerAdvice用于标识当前类为REST风格对应的异常处理器</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    //除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception ex)&#123;</span><br><span class="line">        System.out.println(&quot;嘿嘿,异常你哪里跑！&quot;)</span><br><span class="line">        return new Result(666,null,&quot;嘿嘿,异常你哪里跑！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动运行程序，测试</p><p><img src="/.com//1630658606549.png" alt="1630658606549"></p><p>至此，就算后台执行的过程中抛出异常，最终也能按照我们和前端约定好的格式返回给前端。</p><h4 id="RestControllerAdvice"><a href="#RestControllerAdvice" class="headerlink" title="@RestControllerAdvice"></a>@RestControllerAdvice</h4><table><thead><tr><th>名称</th><th>@RestControllerAdvice</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>Rest风格开发的控制器增强类定义上方</td></tr><tr><td>作用</td><td>为Rest风格开发的控制器类做增强</td></tr></tbody></table><p>**说明:**此注解自带@ResponseBody注解与@Component注解，具备对应的功能</p><p><img src="/.com//1630659060451.png" alt="1630659060451"></p><h4 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h4><table><thead><tr><th>名称</th><th>@ExceptionHandler</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>专用于异常处理的控制器方法上方</td></tr><tr><td>作用</td><td>设置指定异常的处理方案，功能等同于控制器方法，<br>出现异常后终止原始控制器执行,并转入当前方法执行</td></tr></tbody></table><p><strong>说明：</strong>此类方法可以根据处理的异常不同，制作多个方法分别处理对应的异常</p><h3 id="项目异常处理方案"><a href="#项目异常处理方案" class="headerlink" title="项目异常处理方案"></a>项目异常处理方案</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>异常处理器我们已经能够使用了，那么在咱们的项目中该如何来处理异常呢?</p><p>因为异常的种类有很多，如果每一个异常都对应一个@ExceptionHandler，那得写多少个方法来处理各自的异常，所以我们在处理异常之前，需要对异常进行一个分类:</p><ul><li><p>业务异常（BusinessException）</p><ul><li><p>规范的用户行为产生的异常</p><ul><li><p>用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串</p><p><img src="/.com//1630659599983.png" alt="1630659599983"></p></li></ul></li><li><p>不规范的用户行为操作产生的异常</p><ul><li><p>如用户故意传递错误数据</p><p><img src="/.com//1630659622958.png" alt="1630659622958"></p></li></ul></li></ul></li><li><p>系统异常（SystemException）</p><ul><li>项目运行过程中可预计但无法避免的异常<ul><li>比如数据库或服务器宕机</li></ul></li></ul></li><li><p>其他异常（Exception）</p><ul><li><p>编程人员未预期到的异常，如:用到的文件不存在</p><p><img src="/.com//1630659690341.png" alt="1630659690341"></p></li></ul></li></ul><p>将异常分类以后，针对不同类型的异常，要提供具体的解决方案:</p><h4 id="异常解决方案"><a href="#异常解决方案" class="headerlink" title="异常解决方案"></a>异常解决方案</h4><ul><li>业务异常（BusinessException）<ul><li>发送对应消息传递给用户，提醒规范操作<ul><li>大家常见的就是提示用户名已存在或密码格式不正确等</li></ul></li></ul></li><li>系统异常（SystemException）<ul><li>发送固定消息传递给用户，安抚用户<ul><li>系统繁忙，请稍后再试</li><li>系统正在维护升级，请稍后再试</li><li>系统出问题，请联系系统管理员等</li></ul></li><li>发送特定消息给运维人员，提醒维护<ul><li>可以发送短信、邮箱或者是公司内部通信软件</li></ul></li><li>记录日志<ul><li>发消息和记录日志对用户来说是不可见的，属于后台程序</li></ul></li></ul></li><li>其他异常（Exception）<ul><li>发送固定消息传递给用户，安抚用户</li><li>发送特定消息给编程人员，提醒维护（纳入预期范围内）<ul><li>一般是程序没有考虑全，比如未做非空校验等</li></ul></li><li>记录日志</li></ul></li></ul><h4 id="异常解决方案的具体实现"><a href="#异常解决方案的具体实现" class="headerlink" title="异常解决方案的具体实现"></a>异常解决方案的具体实现</h4><blockquote><p>思路:</p><p>1.先通过自定义异常，完成BusinessException和SystemException的定义</p><p>2.将其他异常包装成自定义异常类型</p><p>3.在异常处理器类中对不同的异常进行处理</p></blockquote><p><strong>步骤1:自定义异常类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//自定义异常处理器，用于封装异常信息，对异常进行分类</span><br><span class="line">public class SystemException extends RuntimeException&#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//自定义异常处理器，用于封装异常信息，对异常进行分类</span><br><span class="line">public class BusinessException extends RuntimeException&#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>让自定义异常类继承<code>RuntimeException</code>的好处是，后期在抛出这两个异常的时候，就不用在try…catch…或throws了</li><li>自定义异常类中添加<code>code</code>属性的原因是为了更好的区分异常是来自哪个业务的</li></ul><p><strong>步骤2:将其他异常包成自定义异常</strong></p><p>假如在BookServiceImpl的getById方法抛异常了，该如何来包装呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Book getById(Integer id) &#123;</span><br><span class="line">    //模拟业务异常，包装成自定义异常</span><br><span class="line">    if(id == 1)&#123;</span><br><span class="line">        throw new BusinessException(Code.BUSINESS_ERR,&quot;请不要使用你的技术挑战我的耐性!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //模拟系统异常，将可能出现的异常进行包装，转换成自定义异常</span><br><span class="line">    try&#123;</span><br><span class="line">        int i = 1/0;</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        throw new SystemException(Code.SYSTEM_TIMEOUT_ERR,&quot;服务器访问超时，请重试!&quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">    return bookDao.getById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的包装方式有：</p><ul><li>方式一:<code>try&#123;&#125;catch()&#123;&#125;</code>在catch中重新throw我们自定义异常即可。</li><li>方式二:直接throw自定义异常即可</li></ul><p>上面为了使<code>code</code>看着更专业些，我们在Code类中再新增需要的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//状态码</span><br><span class="line">public class Code &#123;</span><br><span class="line">    public static final Integer SAVE_OK = 20011;</span><br><span class="line">    public static final Integer DELETE_OK = 20021;</span><br><span class="line">    public static final Integer UPDATE_OK = 20031;</span><br><span class="line">    public static final Integer GET_OK = 20041;</span><br><span class="line"></span><br><span class="line">    public static final Integer SAVE_ERR = 20010;</span><br><span class="line">    public static final Integer DELETE_ERR = 20020;</span><br><span class="line">    public static final Integer UPDATE_ERR = 20030;</span><br><span class="line">    public static final Integer GET_ERR = 20040;</span><br><span class="line">    public static final Integer SYSTEM_ERR = 50001;</span><br><span class="line">    public static final Integer SYSTEM_TIMEOUT_ERR = 50002;</span><br><span class="line">    public static final Integer SYSTEM_UNKNOW_ERR = 59999;</span><br><span class="line"></span><br><span class="line">    public static final Integer BUSINESS_ERR = 60002;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>步骤3:处理器类中处理自定义异常</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//@RestControllerAdvice用于标识当前类为REST风格对应的异常处理器</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    //@ExceptionHandler用于设置当前处理器类对应的异常类型</span><br><span class="line">    @ExceptionHandler(SystemException.class)</span><br><span class="line">    public Result doSystemException(SystemException ex)&#123;</span><br><span class="line">        //记录日志</span><br><span class="line">        //发送消息给运维</span><br><span class="line">        //发送邮件给开发人员,ex对象发送给开发人员</span><br><span class="line">        return new Result(ex.getCode(),null,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(BusinessException.class)</span><br><span class="line">    public Result doBusinessException(BusinessException ex)&#123;</span><br><span class="line">        return new Result(ex.getCode(),null,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doOtherException(Exception ex)&#123;</span><br><span class="line">        //记录日志</span><br><span class="line">        //发送消息给运维</span><br><span class="line">        //发送邮件给开发人员,ex对象发送给开发人员</span><br><span class="line">        return new Result(Code.SYSTEM_UNKNOW_ERR,null,&quot;系统繁忙，请稍后再试！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4:运行程序</strong></p><p>根据ID查询，</p><p>如果传入的参数为1，会报<code>BusinessException</code></p><p><img src="/.com//1630661162758.png" alt="1630661162758"></p><p>如果传入的是其他参数，会报<code>SystemException</code></p><p><img src="/.com//1630661192383.png" alt="1630661192383"></p><p>对于异常我们就已经处理完成了，不管后台哪一层抛出异常，都会以我们与前端约定好的方式进行返回，前端只需要把信息获取到，根据返回的正确与否来展示不同的内容即可。</p><p><strong>小结</strong></p><p>以后项目中的异常处理方式为:</p><p><img src="/.com//1630658821746.png" alt="1630658821746"></p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="拦截器概念"><a href="#拦截器概念" class="headerlink" title="拦截器概念"></a>拦截器概念</h3><p>讲解拦截器的概念之前，我们先看一张图:</p><p><img src="/.com//1630676280170.png" alt="1630676280170"></p><p>(1)浏览器发送一个请求会先到Tomcat的web服务器</p><p>(2)Tomcat服务器接收到请求以后，会去判断请求的是静态资源还是动态资源</p><p>(3)如果是静态资源，会直接到Tomcat的项目部署目录下去直接访问</p><p>(4)如果是动态资源，就需要交给项目的后台代码进行处理</p><p>(5)在找到具体的方法之前，我们可以去配置过滤器(可以配置多个)，按照顺序进行执行</p><p>(6)然后进入到到中央处理器(SpringMVC中的内容)，SpringMVC会根据配置的规则进行拦截</p><p>(7)如果满足规则，则进行处理，找到其对应的controller类中的方法进行执行,完成后返回结果</p><p>(8)如果不满足规则，则不进行处理</p><p>(9)这个时候，如果我们需要在每个Controller方法执行的前后添加业务，具体该如何来实现?</p><p>这个就是拦截器要做的事。</p><ul><li>拦截器（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行</li><li>作用:<ul><li>在指定的方法调用前后执行预先设定的代码</li><li>阻止原始方法的执行</li><li>总结：拦截器就是用来做增强</li></ul></li></ul><p>看完以后，大家会发现</p><ul><li>拦截器和过滤器在作用和执行顺序上也很相似</li></ul><p>所以这个时候，就有一个问题需要思考:拦截器和过滤器之间的区别是什么?</p><ul><li>归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术</li><li>拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强</li></ul><p><img src="/.com//1630676903190.png" alt="1630676903190"></p><h3 id="拦截器入门案例"><a href="#拦截器入门案例" class="headerlink" title="拦截器入门案例"></a>拦截器入门案例</h3><h4 id="环境准备-5"><a href="#环境准备-5" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>创建一个Web的Maven项目</p></li><li><p>pom.xml添加SSM整合所需jar包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springmvc_12_interceptor&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;port&gt;80&lt;/port&gt;</span><br><span class="line">          &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;8&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;8&lt;/target&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建对应的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //乱码处理</span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new CharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        return new Filter[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;com.itheima.controller&quot;&#125;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建模型类Book</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private double price;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;书名=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, 价格=&quot; + price +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Controller</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public String save(@RequestBody Book book)&#123;</span><br><span class="line">        System.out.println(&quot;book save...&quot; + book);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String delete(@PathVariable Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;book delete...&quot; + id);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book delete&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public String update(@RequestBody Book book)&#123;</span><br><span class="line">        System.out.println(&quot;book update...&quot;+book);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book update&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;book getById...&quot;+id);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book getById&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public String getAll()&#123;</span><br><span class="line">        System.out.println(&quot;book getAll...&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book getAll&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/.com//1630677370998.png" alt="1630677370998"></p><h4 id="拦截器开发"><a href="#拦截器开发" class="headerlink" title="拦截器开发"></a>拦截器开发</h4><p><strong>步骤1:创建拦截器类</strong></p><p>让类实现HandlerInterceptor接口，重写接口中的三个方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">//定义拦截器类，实现HandlerInterceptor接口</span><br><span class="line">//注意当前类必须受Spring容器控制</span><br><span class="line">public class ProjectInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    //原始方法调用前执行的内容</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;preHandle...&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    //原始方法调用后执行的内容</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;postHandle...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    //原始方法调用完成后执行的内容</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterCompletion...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意:**拦截器类要被SpringMVC容器扫描到。</p><p><strong>步骤2:配置拦截器类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringMvcSupport extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置拦截器</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:SpringMVC添加SpringMvcSupport包扫描</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;com.itheima.controller&quot;,&quot;com.itheima.config&quot;&#125;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4:运行程序测试</strong></p><p>使用PostMan发送<code>http://localhost/books</code></p><p><img src="/.com//1630678114224.png" alt="1630678114224"></p><p>如果发送<code>http://localhost/books/100</code>会发现拦截器没有被执行，原因是拦截器的<code>addPathPatterns</code>方法配置的拦截路径是<code>/books</code>,我们现在发送的是<code>/books/100</code>，所以没有匹配上，因此没有拦截，拦截器就不会执行。</p><p><strong>步骤5:修改拦截器拦截规则</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringMvcSupport extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置拦截器</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;,&quot;/books/*&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，如果再次访问<code>http://localhost/books/100</code>，拦截器就会被执行。</p><p>最后说一件事，就是拦截器中的<code>preHandler</code>方法，如果返回true,则代表放行，会执行原始Controller类中要请求的方法，如果返回false，则代表拦截，后面的就不会再执行了。</p><p><strong>步骤6:简化SpringMvcSupport的编写</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;com.itheima.controller&quot;&#125;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">//实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性</span><br><span class="line">public class SpringMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置多拦截器</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;,&quot;/books/*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后咱们就不用再写<code>SpringMvcSupport</code>类了。</p><p>最后我们来看下拦截器的执行流程:</p><p><img src="/.com//1630679464294.png" alt="1630679464294"></p><p>当有拦截器后，请求会先进入preHandle方法，</p><p>​如果方法返回true，则放行继续执行后面的handle[controller的方法]和后面的方法</p><p>​如果返回false，则直接跳过后面方法的执行。</p><h3 id="拦截器参数"><a href="#拦截器参数" class="headerlink" title="拦截器参数"></a>拦截器参数</h3><h4 id="前置处理方法"><a href="#前置处理方法" class="headerlink" title="前置处理方法"></a>前置处理方法</h4><p>原始方法之前运行preHandle</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request,</span><br><span class="line">                         HttpServletResponse response,</span><br><span class="line">                         Object handler) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;preHandle&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>request:请求对象</li><li>response:响应对象</li><li>handler:被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装</li></ul><p>使用request对象可以获取请求数据中的内容，如获取请求头的<code>Content-Type</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    String contentType = request.getHeader(&quot;Content-Type&quot;);</span><br><span class="line">    System.out.println(&quot;preHandle...&quot;+contentType);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用handler参数，可以获取方法的相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    HandlerMethod hm = (HandlerMethod)handler;</span><br><span class="line">    String methodName = hm.getMethod().getName();//可以获取方法的名称</span><br><span class="line">    System.out.println(&quot;preHandle...&quot;+methodName);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后置处理方法"><a href="#后置处理方法" class="headerlink" title="后置处理方法"></a>后置处理方法</h4><p>原始方法运行后运行，如果原始方法被拦截，则不执行  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void postHandle(HttpServletRequest request,</span><br><span class="line">                       HttpServletResponse response,</span><br><span class="line">                       Object handler,</span><br><span class="line">                       ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;postHandle&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三个参数和上面的是一致的。</p><p>modelAndView:如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整</p><p>因为咱们现在都是返回json数据，所以该参数的使用率不高。</p><h4 id="完成处理方法"><a href="#完成处理方法" class="headerlink" title="完成处理方法"></a>完成处理方法</h4><p>拦截器最后执行的方法，无论原始方法是否执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void afterCompletion(HttpServletRequest request,</span><br><span class="line">                            HttpServletResponse response,</span><br><span class="line">                            Object handler,</span><br><span class="line">                            Exception ex) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;afterCompletion&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三个参数与上面的是一致的。</p><p>ex:如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理  </p><p>因为我们现在已经有全局异常处理器类，所以该参数的使用率也不高。</p><p>这三个方法中，最常用的是preHandle,在这个方法中可以通过返回值来决定是否要进行放行，我们可以把业务逻辑放在该方法中，如果满足业务则返回true放行，不满足则返回false拦截。</p><h3 id="拦截器链配置"><a href="#拦截器链配置" class="headerlink" title="拦截器链配置"></a>拦截器链配置</h3><p>目前，我们在项目中只添加了一个拦截器，如果有多个，该如何配置?配置多个后，执行顺序是什么?</p><h4 id="配置多个拦截器"><a href="#配置多个拦截器" class="headerlink" title="配置多个拦截器"></a>配置多个拦截器</h4><p><strong>步骤1:创建拦截器类</strong></p><p>实现接口，并重写接口中的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ProjectInterceptor2 implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;preHandle...222&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;postHandle...222&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterCompletion...222&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2:配置拦截器类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;com.itheima.controller&quot;&#125;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">//实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性</span><br><span class="line">public class SpringMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor2 projectInterceptor2;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置多拦截器</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;,&quot;/books/*&quot;);</span><br><span class="line">        registry.addInterceptor(projectInterceptor2).addPathPatterns(&quot;/books&quot;,&quot;/books/*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤3:运行程序，观察顺序</strong></p><p><img src="/.com//1630680435269.png" alt="1630680435269"></p><p>拦截器执行的顺序是和配置顺序有关。就和前面所提到的运维人员进入机房的案例，先进后出。</p><ul><li>当配置多个拦截器时，形成拦截器链</li><li>拦截器链的运行顺序参照拦截器添加顺序为准</li><li>当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行</li><li>当拦截器运行中断，仅运行配置在前面的拦截器的afterCompletion操作</li></ul><p><img src="/.com//1630680579735.png" alt="1630680579735"></p><p>preHandle：与配置顺序相同，必定运行</p><p>postHandle:与配置顺序相反，可能不运行</p><p>afterCompletion:与配置顺序相反，可能不运行。</p><p>这个顺序不太好记，最终只需要把握住一个原则即可:&#x3D;&#x3D;以最终的运行结果为准&#x3D;&#x3D;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2024/04/25/Redis/"/>
      <url>/2024/04/25/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p><img src="/.com//image-20240514151945727.png" alt="image-20240514151945727"></p><h1 id="初识NoSQL"><a href="#初识NoSQL" class="headerlink" title="初识NoSQL"></a>初识NoSQL</h1><p>NoSQL：非关系型数据库</p><p><img src="/.com//image-20240514152215036.png" alt="image-20240514152215036"></p><h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis， 远程词典服务器，是一个基于内存的键值型NoSQL数据库</p><p><strong>特征：</strong></p><ul><li>键值型，valuie支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存，IO多路复用，良好的编码）</li><li>支持数据持久化</li><li>指出主从集群，分片集群</li><li>支持多语言客户端</li></ul><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><h3 id="Redis安装说明"><a href="#Redis安装说明" class="headerlink" title="Redis安装说明"></a>Redis安装说明</h3><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p><p>此处选择的Linux版本为CentOS 7.</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h3 id="1-单机安装Redis"><a href="#1-单机安装Redis" class="headerlink" title="1.单机安装Redis"></a>1.单机安装Redis</h3><h4 id="1-1-安装Redis依赖"><a href="#1-1-安装Redis依赖" class="headerlink" title="1.1.安装Redis依赖"></a>1.1.安装Redis依赖</h4><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><h4 id="1-2-上传安装包并解压"><a href="#1-2-上传安装包并解压" class="headerlink" title="1.2.上传安装包并解压"></a>1.2.上传安装包并解压</h4><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p><p><img src="/.com//image-20211211071712536.png" alt="image-20211211071712536"></p><p>例如，我放到了&#x2F;usr&#x2F;local&#x2F;src 目录：</p><p><img src="/.com//image-20211211080151539.png" alt="image-20211211080151539"></p><p>解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure><p>解压后：</p><p><img src="/.com//image-20211211080339076.png" alt="image-20211211080339076"></p><p>进入redis目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure><p>运行编译命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p><img src="/.com//image-20211211080603710.png" alt="image-20211211080603710"></p><p>该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h4 id="1-3-启动"><a href="#1-3-启动" class="headerlink" title="1.3.启动"></a>1.3.启动</h4><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h4 id="1-3-1-默认启动"><a href="#1-3-1-默认启动" class="headerlink" title="1.3.1.默认启动"></a>1.3.1.默认启动</h4><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/.com//image-20211211081716167.png" alt="image-20211211081716167"></p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h4 id="1-3-2-指定配置启动"><a href="#1-3-2-指定配置启动" class="headerlink" title="1.3.2.指定配置启动"></a>1.3.2.指定配置启动</h4><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p><img src="/.com//image-20211211082225509.png" alt="image-20211211082225509"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure><h4 id="1-3-3-开机自启"><a href="#1-3-3-开机自启" class="headerlink" title="1.3.3.开机自启"></a>1.3.3.开机自启</h4><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><h3 id="2-Redis客户端"><a href="#2-Redis客户端" class="headerlink" title="2.Redis客户端"></a>2.Redis客户端</h3><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h4 id="2-1-Redis命令行客户端"><a href="#2-1-Redis命令行客户端" class="headerlink" title="2.1.Redis命令行客户端"></a>2.1.Redis命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><p><img src="/.com//image-20211211110439353.png" alt="image-20211211110439353"></p><h4 id="2-2-图形化桌面客户端"><a href="#2-2-图形化桌面客户端" class="headerlink" title="2.2.图形化桌面客户端"></a>2.2.图形化桌面客户端</h4><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p><p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><p><img src="/.com//image-20211211111351885.png" alt="image-20211211111351885"></p><h4 id="2-2-1-安装"><a href="#2-2-1-安装" class="headerlink" title="2.2.1.安装"></a>2.2.1.安装</h4><p>在课前资料中可以找到Redis的图形化桌面客户端：</p><p><img src="/.com//image-20211214154938770.png" alt="image-20211214154938770"></p><p>解压缩后，运行安装程序即可安装：</p><p><img src="/.com//image-20211214155123841.png" alt="image-20211214155123841"></p><p>此处略。</p><p>安装完成后，在安装目录下找到rdm.exe文件：</p><p><img src="/.com//image-20211211110935819.png" alt="image-20211211110935819"></p><p>双击即可运行：</p><p><img src="/.com//image-20211214155406692.png" alt="image-20211214155406692"></p><h4 id="2-2-2-建立连接"><a href="#2-2-2-建立连接" class="headerlink" title="2.2.2.建立连接"></a>2.2.2.建立连接</h4><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p><p><img src="/.com//image-20211214155424842.png" alt="image-20211214155424842"></p><p>在弹出的窗口中填写Redis服务信息：</p><p><img src="/.com//image-20211211111614483.png" alt="image-20211211111614483"></p><p>点击确定后，在左侧菜单会出现这个链接：</p><p><img src="/.com//image-20211214155804523.png" alt="image-20211214155804523"></p><p>点击即可建立连接了：</p><p><img src="/.com//image-20211214155849495.png" alt="image-20211214155849495"></p><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择 0号库</span></span><br><span class="line"><span class="keyword">select</span> 0</span><br></pre></td></tr></table></figure><h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis是一个key-value的数据库， key一般是String类型，不过value的类型多种多样</p><p><img src="/.com//image-20240514163454476.png" alt="image-20240514163454476"></p><h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>通用指令都是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li><p>KEYS：查看符合模板的所有字符串， <strong>不建议在生产环境设备上使用</strong></p><ul><li><pre><code>KEYS 键名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- DEL：删除一个指定的key</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    DEL 键名</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>EXISTS：判断key是否存在</p><ul><li><pre><code>EXISTS 键名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    EXPIRE 键名</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><p><img src="/.com//image-20240514164543168.png" alt="image-20240514164543168"></p><h2 id="String命令"><a href="#String命令" class="headerlink" title="String命令"></a>String命令</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增.自减操作</li><li>float：浮点类型，可以做自增.自减操作</li></ul><p><img src="/.com//1652890121291.png" alt="1652890121291"></p><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><p><strong>贴心小提示</strong>：以上命令除了INCRBYFLOAT 都是常用命令</p><ul><li>SET 和GET：如果key不存在则是新增，如果存在则是修改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Rose  <span class="comment">//原来不存在</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name </span><br><span class="line"><span class="string">&quot;Rose&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack <span class="comment">//原来存在，就是修改</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br></pre></td></tr></table></figure><ul><li>MSET和MGET：批量添加、批量获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MSET k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MGET name age k1 k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Jack&quot;</span> <span class="comment">//之前存在的name</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;10&quot;</span>   <span class="comment">//之前存在的age</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure><ul><li>INCR和INCRBY和DECY</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incr age <span class="comment">//增加1</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age <span class="comment">//获得age</span></span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span> <span class="comment">//一次增加2</span></span><br><span class="line">(integer) <span class="number">13</span> <span class="comment">//返回目前的age的值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">15</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">1</span> <span class="comment">//也可以增加负数，相当于减</span></span><br><span class="line">(integer) <span class="number">14</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">2</span> <span class="comment">//一次减少2个</span></span><br><span class="line">(integer) <span class="number">12</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DECR age <span class="comment">//相当于 incr 负数，减少正常用法</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>SETNX：只能用于键不存在的情况下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; help setnx</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only <span class="keyword">if</span> the key does not exist</span><br><span class="line">  since: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack  <span class="comment">//设置名称</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name lisi <span class="comment">//如果key不存在，则添加成功</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name <span class="comment">//由于name已经存在，所以lisi的操作失败</span></span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name2 lisi <span class="comment">//name2 不存在，所以操作成功</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name2 </span><br><span class="line"><span class="string">&quot;lisi&quot;</span></span><br></pre></td></tr></table></figure><ul><li>SETEX：设置指定key的值，并将key的过期时间设为seconds秒</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex name 10 jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h2 id="Key的层级结构"><a href="#Key的层级结构" class="headerlink" title="Key的层级结构"></a>Key的层级结构</h2><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储  用户.商品信息  到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用 ‘ : ‘ 隔开，格式如下：</p><p><img src="/.com//1652941631682.png" alt="1652941631682"></p><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据</p><p><img src="/.com//1652941883537.png" alt="1652941883537"></p><h2 id="Hash命令"><a href="#Hash命令" class="headerlink" title="Hash命令"></a>Hash命令</h2><p>Hash类型，也叫散列，其value是一个<strong>无序字典</strong>，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="/.com//1652941995945.png" alt="1652941995945"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="/.com//1652942027719.png" alt="1652942027719"></p><p><strong>Hash类型的常见命令</strong></p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><p><strong>贴心小提示</strong>：哈希结构也是我们以后实际开发中常用的命令哟</p><ul><li>HSET和HGET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> name Lucy<span class="comment">//大key是 heima:user:3 小key是name，小value是Lucy</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">21</span><span class="comment">// 如果操作不存在的数据，则是新增</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">17</span> <span class="comment">//如果操作存在的数据，则是修改</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> name </span><br><span class="line"><span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> age</span><br><span class="line"><span class="string">&quot;17&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HMSET和HMGET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name HanMeiMei</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name LiLei age <span class="number">20</span> sex man</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMGET heima:user:<span class="number">4</span> name age sex</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HGETALL：获取一个hash类型的key中的所有的field和value</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HKEYS和HVALS：获取heima:user:4 的所有键名和值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HKEYS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HINCRBY：让一个hash类型key的字段值自增并指定步长</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">22</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;22&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age -<span class="number">2</span></span><br><span class="line">(integer) <span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user4 sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user:<span class="number">3</span> sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;woman&quot;</span></span><br></pre></td></tr></table></figure><h2 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个<strong>双向链表结构</strong>。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p><strong>List的常见命令有：</strong></p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p><img src="/.com//image-20240514165235019.png" alt="image-20240514165235019"></p><ul><li>LPUSH和RPUSH</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH users <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPUSH users <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br></pre></td></tr></table></figure><ul><li>LPOP和RPOP</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPOP users</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPOP users</span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure><ul><li>LRANGE</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE users <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Set命令"><a href="#Set命令" class="headerlink" title="Set命令"></a>Set命令</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul><p><strong>Set类型的常见命令</strong></p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF key1 key2 … ：求key1与key2的差集</li><li>SUNION key1 key2 ..：求key1和key2的并集</li></ul><p><strong>具体命令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd s1 a b <span class="title function_">c</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers s1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srem s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">b</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">s1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><ul><li>将下列数据用Redis的Set集合来存储：</li><li>张三的好友有：李四.王五.赵六</li><li>李四的好友有：王五.麻子.二狗</li><li>利用Set的命令实现下列功能：</li><li>计算张三的好友有几人</li><li>计算张三和李四有哪些共同好友</li><li>查询哪些人是张三的好友却不是李四的好友</li><li>查询张三和李四的好友总共有哪些人</li><li>判断李四是否是张三的好友</li><li>判断张三是否是李四的好友</li><li>将李四从张三的好友列表中移除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD zs lisi wangwu <span class="title function_">zhaoliu</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD ls wangwu mazi <span class="title function_">ergou</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">zs</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SINTER zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SDIFF zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SUNION zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;mazi&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;ergou&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER ls <span class="title function_">zhangsan</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SREM zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SMEMBERS zs</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure><h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li><p>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</p><ul><li><pre><code>ZADD stus 85 Jack 70 Lucy 82 Rose<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ZREM key member：删除sorted set中的一个指定元素</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    ZREM stus Jack</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>ZSCORE key member : 获取sorted set中的指定元素的score值</p><ul><li><pre><code>ZSCORE stus Jack<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ZRANK key member：获取sorted set 中的指定元素的排名</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    ZRANK stus Rose  -- 查询rose的排名</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>ZCARD key：获取sorted set中的元素个数</p><ul><li><pre><code>ZCARD stus<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    ZCOUNT stus 0 80 --查询0-80分的个数</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</p></li><li><p>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</p><ul><li><pre><code>ZRANGE stus 0 2 -- 前三名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    ZRANGEBYSCORE stus 0 80 -- 查询0-80分的学生</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</p></li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul><h1 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h1><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p><img src="https://i.imgur.com/9f68ivq.png"></p><p>其中Java客户端也包含很多：</p><p><img src="/.com//image-20220609102817435.png" alt="image-20220609102817435"></p><p>标记为❤的就是推荐使用的java客户端，包括：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h3 id="Jedis快速入门"><a href="#Jedis快速入门" class="headerlink" title="Jedis快速入门"></a>Jedis快速入门</h3><p><strong>入门案例详细步骤</strong></p><p>案例分析：</p><p>1）引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">    jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">    <span class="comment">// 2.设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 插入hash数据</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p><p>有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。</p><h4 id="创建Jedis的连接池"><a href="#创建Jedis的连接池" class="headerlink" title="创建Jedis的连接池"></a>创建Jedis的连接池</h4><p>- </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFacotry</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//配置连接池</span></span><br><span class="line">         <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">         poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">         poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">         <span class="comment">//创建连接池对象</span></span><br><span class="line">         jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                 <span class="string">&quot;192.168.150.101&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ul><li><p>1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</p></li><li><p>2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化</p></li><li><p>3）最后提供返回连接池中连接的方法.</p></li></ul><h4 id="改造原始代码"><a href="#改造原始代码" class="headerlink" title="改造原始代码"></a>改造原始代码</h4><p><strong>代码说明:</strong></p><p>1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。</p><p>，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。</p><p>2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@BeforeEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//建立连接</span></span><br><span class="line">     <span class="comment">/*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/</span></span><br><span class="line">     jedis = JedisConnectionFacotry.getJedis();</span><br><span class="line">      <span class="comment">//选择库</span></span><br><span class="line">     jedis.select(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">         jedis.close();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="/.com//1652976773295.png" alt="1652976773295"></p><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单：</p><h4 id="导入pom坐标"><a href="#导入pom坐标" class="headerlink" title="导入pom坐标"></a>导入pom坐标</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span>  <span class="comment">#最大连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>   <span class="comment">#最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>   <span class="comment">#最小空闲连接</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>贴心小提示：SpringDataJpa使用起来非常简单，记住如下几个步骤即可</strong></p><p>SpringDataRedis的使用步骤：</p><ul><li>引入spring-boot-starter-data-redis依赖</li><li>在application.yml配置Redis信息</li><li>注入RedisTemplate</li></ul><h3 id="数据序列化器"><a href="#数据序列化器" class="headerlink" title="数据序列化器"></a>数据序列化器</h3><p>RedisTemplate可以接收任意Object作为值写入Redis：</p><p><img src="/.com//image-20240514212119691.png" alt="image-20240514212119691"></p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p><p><img src="/.com//image-20240514212112182.png" alt="image-20240514212112182"></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="/.com//image-20240514212141647.png" alt="image-20240514212141647"></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><p>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：</p><p><img src="/.com//1653054602930.png" alt="1653054602930"></p><p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p><p>为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间</p><p><img src="/.com//1653054744832.png" alt="1653054744832"></p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><p><img src="/.com//zXH6Qn6.png"></p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;verify:phone:13600527634&quot;</span>, <span class="string">&quot;124143&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再来看一看存储的数据，小伙伴们就会发现那个class数据已经不在了，节约了我们的空间~</p><p><img src="/.com//1653054945211.png" alt="1653054945211"></p><p>最后小总结：</p><p>RedisTemplate的两种序列化实践方案：</p><ul><li><p>方案一：</p><ul><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ul></li><li><p>方案二：</p><ul><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ul></li></ul><h3 id="Hash结构操作"><a href="#Hash结构操作" class="headerlink" title="Hash结构操作"></a>Hash结构操作</h3><p>在基础篇的最后，咱们对Hash结构操作一下，收一个小尾巴，这个代码咱们就不再解释啦</p><p>马上就开始新的篇章~~~进入到我们的Redis实战篇</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h2><p>缓存就是数据交换的缓冲区（称作Cache）是存储数据的临时地方，一般读写性能较高</p><p><img src="/.com//image-20240516140017400.png" alt="image-20240516140017400"></p><p>利弊：</p><p><img src="/.com//image-20240516140031731.png" alt="image-20240516140031731"></p><h2 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h2><p>缓存模型</p><p><img src="/.com//image-20240516140500532.png" alt="image-20240516140500532"></p><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="/.com//image-20240516150522932.png" alt="image-20240516150522932"></p><p><img src="/.com//image-20240516151935972.png" alt="image-20240516151935972"></p><h3 id="数据库缓存不一致解决方案："><a href="#数据库缓存不一致解决方案：" class="headerlink" title="数据库缓存不一致解决方案："></a>数据库缓存不一致解决方案：</h3><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><p><img src="/.com//image-20240516152027032.png" alt="image-20240516152027032"></p><h3 id="数据库和缓存不一致采用什么方案"><a href="#数据库和缓存不一致采用什么方案" class="headerlink" title="数据库和缓存不一致采用什么方案"></a>数据库和缓存不一致采用什么方案</h3><p>综合考虑使用<strong>方案一</strong>，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul></li></ul><p><img src="/.com//image-20240516152131442.png" alt="image-20240516152131442"></p><p>缓存更新策略的最佳实践方案：</p><p><img src="/.com//image-20240516152216674.png" alt="image-20240516152216674"></p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><p><img src="/.com//image-20240516155020027.png" alt="image-20240516155020027"></p><h3 id="编码解决商品查询的缓存穿透问题："><a href="#编码解决商品查询的缓存穿透问题：" class="headerlink" title="编码解决商品查询的缓存穿透问题："></a>编码解决商品查询的缓存穿透问题：</h3><p>核心思路如下：</p><p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p><p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p><p><img src="/.com//image-20240516161332739.png" alt="image-20240516161332739"></p><p><strong>小总结：</strong></p><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><p><img src="/.com//image-20240516162255734.png" alt="image-20240516162255734"></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="缓存击穿问题及解决思路"><a href="#缓存击穿问题及解决思路" class="headerlink" title="缓存击穿问题及解决思路"></a>缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><img src="/.com//image-20240516164011677.png" alt="image-20240516164011677"></p><p><strong>解决方案一</strong>、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><img src="/.com//image-20240516164123713.png" alt="image-20240516164123713"></p><p><strong>解决方案二</strong>、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，<strong>缺点在于在构建完缓存之前，返回的都是脏数据。</strong></p><p><img src="/.com//image-20240516164148770.png" alt="image-20240516164148770"></p><p>进行对比</p><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><p><img src="/.com//image-20240516164223735.png" alt="image-20240516164223735"></p><h3 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a>利用互斥锁解决缓存击穿问题</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p><p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p><p><img src="/.com//image-20240516181431361.png" alt="image-20240516181431361"></p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>  &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">// 1、从redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">       <span class="comment">// 2、判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="comment">// 存在,直接返回</span></span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的值是否是空值</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//返回一个错误信息</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4.实现缓存重构</span></span><br><span class="line">       <span class="comment">//4.1 获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span> + id;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">           <span class="comment">// 4.2 判断否获取成功</span></span><br><span class="line">           <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">               <span class="comment">//4.3 失败，则休眠重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//4.4 成功，根据id查询数据库</span></span><br><span class="line">            shop = getById(id);</span><br><span class="line">           <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">           <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//将空值写入redis</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="comment">//返回错误信息</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//6.写入redis</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//7.释放互斥锁</span></span><br><span class="line">           unlock(lockKey);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="利用逻辑过期解决缓存击穿问题"><a href="#利用逻辑过期解决缓存击穿问题" class="headerlink" title="利用逻辑过期解决缓存击穿问题"></a>利用逻辑过期解决缓存击穿问题</h3><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p><p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p><p><img src="/.com//image-20240516181543291.png" alt="image-20240516181543291"></p><p>如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你</p><p><strong>步骤一、</strong></p><p>新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class RedisData &#123;</span><br><span class="line">    private LocalDateTime expireTime;</span><br><span class="line">    private Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤二、</strong></p><p>在<strong>ShopServiceImpl</strong> 新增此方法，利用单元测试进行缓存预热</p><p><img src="/.com//image-20240516181536044.png" alt="image-20240516181536044"></p><p><strong>在测试类中</strong></p><p><img src="/.com//image-20240516181530333.png" alt="image-20240516181530333"></p><p>步骤三：正式代码</p><p><strong>ShopServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">( Long id )</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装Redis工具类"><a href="#封装Redis工具类" class="headerlink" title="封装Redis工具类"></a>封装Redis工具类</h2><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><ul><li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓</li></ul><p>存击穿问题</p><ul><li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li></ul><p>将逻辑进行封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ShopServiceImpl 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 解决缓存穿透</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient</span><br><span class="line">                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 互斥锁解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逻辑过期解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a>全局ID生成器</h1><p>全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性</p><p><img src="/.com//image-20240517143111172.png" alt="image-20240517143111172"></p><p>为了增加ID的安全性，我们不可以重复的使用Redis自增的数值，而是提供一些其他信息：</p><p><img src="/.com//image-20240517143207502.png" alt="image-20240517143207502"></p><p>ID的组成部分：</p><p><img src="/.com//image-20240517143236453.png" alt="image-20240517143236453"></p><p>代码实现：</p><p>RedisIdWorks</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorks</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisIdWorks redisIdWorks;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">ex</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">               <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisIdWorks.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">               System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">           &#125;</span><br><span class="line">           latch.countDown();</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">           ex.submit(task);</span><br><span class="line">       &#125;</span><br><span class="line">       latch.await();</span><br><span class="line">       <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;time = &quot;</span> + (end - begin));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>全局唯一ID生成策略：</p><ul><li>UUID</li><li>Redis自增</li><li>snowflake算法</li><li>数据库自增</li></ul><p>Redis自增策略</p><ul><li>每天一个key，方便统计订单量</li><li>ID构造是 时间戳 + 计数器</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2024/04/25/Linux/"/>
      <url>/2024/04/25/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><p><img src="/.com//image-20240514213712464.png" alt="image-20240514213712464"></p><ul><li><code>/</code>，根目录是最顶级的目录了</li><li>Linux只有一个顶级目录：<code>/</code></li><li>路径描述的层次关系同样适用<code>/</code>来表示</li><li>&#x2F;home&#x2F;itheima&#x2F;a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt</li></ul><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>功能：列出文件夹信息</p><p>语法：<code>ls [-l -h -a] [参数]</code></p><ul><li>参数：被查看的文件夹，不提供参数，表示查看当前工作目录</li><li>-l，以列表形式查看</li><li>-h，配合-l，以更加人性化的方式显示文件大小</li><li>-a，显示隐藏文件</li></ul><h3 id="隐藏文件、文件夹"><a href="#隐藏文件、文件夹" class="headerlink" title="隐藏文件、文件夹"></a>隐藏文件、文件夹</h3><p>在Linux中以<code>.</code>开头的，均是隐藏的。</p><p>默认不显示出来，需要<code>-a</code>选项才可查看到。</p><h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>功能：展示当前工作目录</p><p>语法：<code>pwd</code></p><p>作用是：输出当前所在的工作目录</p><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p>功能：切换工作目录</p><p>语法：<code>cd [目标目录]</code></p><p>参数：目标目录，要切换去的地方，不提供默认切换到<code>当前登录用户HOME目录</code></p><h2 id="HOME目录"><a href="#HOME目录" class="headerlink" title="HOME目录"></a>HOME目录</h2><p>每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。</p><ul><li><p>普通用户的HOME目录，默认在：<code>/home/用户名</code></p></li><li><p>root用户的HOME目录，在：<code>/root</code></p></li></ul><p>FinalShell登陆终端后，默认的工作目录就是用户的HOME目录</p><h2 id="相对路径、绝对路径"><a href="#相对路径、绝对路径" class="headerlink" title="相对路径、绝对路径"></a>相对路径、绝对路径</h2><ul><li><p>相对路径，&#x3D;&#x3D;非&#x3D;&#x3D;<code>/</code>开头的称之为相对路径</p><p>相对路径表示以<code>当前目录</code>作为起点，去描述路径，如<code>test/a.txt</code>，表示当前工作目录内的test文件夹内的a.txt文件</p></li><li><p>绝对路径，&#x3D;&#x3D;以&#x3D;&#x3D;<code>/</code>开头的称之为绝对路径</p><p>绝对路径从<code>根</code>开始描述路径</p></li></ul><h2 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h2><ul><li><code>.</code>，表示当前，比如.&#x2F;a.txt，表示当前文件夹内的<code>a.txt</code>文件</li><li><code>..</code>，表示上级目录，比如<code>../</code>表示上级目录，<code>../../</code>表示上级的上级目录</li><li><code>~</code>，表示用户的HOME目录，比如<code>cd ~</code>，即可切回用户HOME目录</li></ul><h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p>功能：创建文件夹</p><p>语法：<code>mkdir [-p] 参数</code></p><ul><li>参数：被创建文件夹的路径</li><li>选项：-p，可选，表示创建前置路径<ul><li>自动创建不存在的父目录，适用于创建连续多层级的目录</li></ul></li></ul><h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><p>功能：创建文件</p><p>语法：<code>touch 参数</code></p><ul><li>参数：参数必填，表示要创建的文件路径</li></ul><h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>功能：查看文件内容</p><p>语法：<code>cat 参数</code></p><ul><li>参数：被查看的文件路径</li></ul><h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>功能：查看文件，可以支持翻页查看</p><p>语法：<code>more 参数</code></p><ul><li>参数：被查看的文件路径</li><li>在查看过程中：<ul><li><code>空格</code>键翻页</li><li><code>q</code>退出查看</li></ul></li></ul><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>功能：复制文件、文件夹</p><p>语法：<code>cp [-r] 参数1 参数2</code></p><ul><li>参数1，被复制的</li><li>参数2，要复制去的地方</li><li>选项：-r，可选，复制文件夹使用</li></ul><p>示例：</p><ul><li>cp a.txt b.txt，复制当前目录下a.txt为b.txt</li><li>cp a.txt test&#x2F;，复制当前目录a.txt到test文件夹内</li><li>cp -r test test2，复制文件夹test到当前文件夹内为test2存在</li></ul><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>功能：移动文件、文件夹</p><p>语法：<code>mv 参数1 参数2</code></p><ul><li>参数1：被移动的</li><li>参数2：要移动去的地方，参数2如果不存在，则会进行改名</li></ul><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p>功能：删除文件、文件夹</p><p>语法：<code>rm [-r -f] 参数...参数</code></p><ul><li><p>参数：支持多个，每一个表示被删除的，空格进行分隔</p></li><li><p>选项：-r，删除文件夹使用</p></li><li><p>选项：-f，强制删除，不会给出确认提示，一般root用户会用到</p></li><li><p>参数也支持通配符*，用以做模糊匹配</p><ul><li>text* 匹配以text开头的文件或文件夹</li><li>*text  匹配text结尾的文件或文件夹</li><li>*text *  匹配包含text的文件或文件夹</li></ul></li></ul><blockquote><p>rm命令很危险，一定要注意，特别是切换到root用户的时候。</p></blockquote><h2 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h2><p>功能：查看命令的程序本体文件路径</p><p>语法：<code>which 参数</code></p><ul><li>参数：被查看的命令</li></ul><h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><p>功能：搜索文件</p><p>语法1按文件名搜索：<code>find 路径 -name 参数</code></p><ul><li><p>路径，搜索的起始路径</p></li><li><p>参数，搜索的关键字，支持通配符*， 比如：<code>*</code>test表示搜索任意以test结尾的文件</p></li><li><p>按文件大小查找：<code>find 起始路径 -size +|-n [KMG]</code></p></li><li><pre><code>查找小于10KB的文件：find / -size -10k查找小于100MB的文件：find / -size -100mb查找大于1GB的文件：find / -size +1GB<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## grep命令</span><br><span class="line"></span><br><span class="line">功能：过滤关键字</span><br><span class="line"></span><br><span class="line">语法：`grep [-n] 关键字 文件路径`</span><br><span class="line"></span><br><span class="line">- 选项-n，可选，表示在结果中显示匹配的行的行号。</span><br><span class="line">- 参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来</span><br><span class="line">- 参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 参数文件路径，可以作为管道符的输入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## wc命令</span><br><span class="line"></span><br><span class="line">功能：统计</span><br><span class="line"></span><br><span class="line">语法：`wc [-c -m -l -w] 文件路径`</span><br><span class="line"></span><br><span class="line">- 选项，-c，统计bytes数量</span><br><span class="line">- 选项，-m，统计字符数量</span><br><span class="line">- 选项，-l，统计行数</span><br><span class="line">- 选项，-w，统计单词数量</span><br><span class="line">- 参数，文件路径，被统计的文件，可作为内容输入端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 参数文件路径，可作为管道符的输入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 管道符|</span><br><span class="line"></span><br><span class="line">写法：`|`</span><br><span class="line"></span><br><span class="line">功能：将符号左边的结果，作为符号右边的输入</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">`cat a.txt | grep itheima`，将cat a.txt的结果，作为grep命令的输入，用来过滤`itheima`关键字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以支持嵌套：</span><br><span class="line"></span><br><span class="line">`cat a.txt | grep itheima | grep itcast`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## echo命令</span><br><span class="line"></span><br><span class="line">功能：输出内容</span><br><span class="line"></span><br><span class="line">语法：`echo 参数`</span><br><span class="line"></span><br><span class="line">- 参数：被输出的内容</span><br><span class="line"></span><br><span class="line">- 无需选择，只有一个参数，表示要输出的内容，复杂内容可以用“ &quot;包围</span><br><span class="line"></span><br><span class="line">  演示：</span><br><span class="line"></span><br><span class="line">  - 在终端上显示：Hello Linux</span><br><span class="line"></span><br></pre></td></tr></table></figure>  echo Hello Linux  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 带有空格或\等特殊符号，建议使用双引号包围</span><br><span class="line"></span><br><span class="line">  - 因为不包围的话，空格很容易被识别为参数2，尽管echo不受影响</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## `反引号</span><br><span class="line"></span><br><span class="line">功能：被两个反引号包围的内容，会作为命令执行</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">- echo \`pwd\`，会输出当前工作目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## tail命令</span><br><span class="line"></span><br><span class="line">功能：查看文件尾部内容</span><br><span class="line"></span><br><span class="line">语法：`tail [-f] 参数`</span><br><span class="line"></span><br><span class="line">- 参数：被查看的文件</span><br><span class="line">- 选项：-f，持续跟踪文件修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## head命令</span><br><span class="line"></span><br><span class="line">功能：查看文件头部内容</span><br><span class="line"></span><br><span class="line">语法：`head [-n] 参数`</span><br><span class="line"></span><br><span class="line">- 参数：被查看的文件</span><br><span class="line">- 选项：-n，查看的行数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 重定向符</span><br><span class="line"></span><br><span class="line">功能：将符号左边的结果，输出到右边指定的文件中去</span><br><span class="line"></span><br><span class="line">- `&gt;`，表示覆盖输出  将左侧命令的结果，覆盖写入到符号右侧指定的文件中</span><br><span class="line">- `&gt;&gt;`，表示追加输出   将左侧命令的结果，追加写入到符号右侧指定的文件中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## vi编辑器</span><br><span class="line"></span><br><span class="line">### 命令模式快捷键</span><br><span class="line"></span><br><span class="line">| 模式         | 命令  | 描述                              |</span><br><span class="line">| ------------ | ----- | --------------------------------- |</span><br><span class="line">| **命令模式** | `i`   | 在当前光标位置进入 `输入模式`     |</span><br><span class="line">| **命令模式** | `a`   | 在当前光标位置之后进入 `输入模式` |</span><br><span class="line">| **命令模式** | `I`   | 在当前行的开头进入 `输入模式`     |</span><br><span class="line">| **命令模式** | `A`   | 在当前行的结尾进入 `输入模式`     |</span><br><span class="line">| **命令模式** | `o`   | 在当前光标下一行进入 `输入模式`   |</span><br><span class="line">| **命令模式** | `O`   | 在当前光标上一行进入 `输入模式`   |</span><br><span class="line">| **输入模式** | `esc` | 任何情况下`esc` 都能回到命令模式  |</span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line">| 模式         | 命令             | 描述                   |</span><br><span class="line">| ------------ | ---------------- | ---------------------- |</span><br><span class="line">| **命令模式** | `键盘上、键盘k`  | 向上移动光标           |</span><br><span class="line">| **命令模式** | `键盘下、键盘j`  | 向下移动光标           |</span><br><span class="line">| **命令模式** | `键盘左、键盘h`  | 向左移动光标           |</span><br><span class="line">| **命令模式** | `键盘右、键盘l`  | 向右移动光标           |</span><br><span class="line">| **命令模式** | `0`              | 移动光标到当前行的开头 |</span><br><span class="line">| **命令模式** | `$`              | 移动光标到当前行的结尾 |</span><br><span class="line">| **命令模式** | `pageup(Pgup)`   | 向上翻页               |</span><br><span class="line">| **命令模式** | `pagedown(PgDn)` | 向下翻页               |</span><br><span class="line">| **命令模式** | `/`              | 进入搜索模式           |</span><br><span class="line">| **命令模式** | `n`              | 向下继续搜索           |</span><br><span class="line">| **命令模式** | `N`              | 向上继续搜索           |</span><br><span class="line"></span><br><span class="line">| **模式**     | 命令       | 描述                             |</span><br><span class="line">| ------------ | ---------- | -------------------------------- |</span><br><span class="line">| **命令模式** | `dd`       | 删除光标所在行的内容             |</span><br><span class="line">| **命令模式** | `ndd`      | n是数字，表示删除当前光标向下n行 |</span><br><span class="line">| **命令模式** | `yy`       | 复制当前行                       |</span><br><span class="line">| **命令模式** | `nyy`      | n是数字，复制当前行和下面的n行   |</span><br><span class="line">| **命令模式** | `p`        | 粘贴复制的内容                   |</span><br><span class="line">| **命令模式** | `u`        | 撤销修改                         |</span><br><span class="line">| **命令模式** | `ctrl + r` | 反向撤销修改                     |</span><br><span class="line">| **命令模式** | `gg`       | 跳到首行                         |</span><br><span class="line">| **命令模式** | `G`        | 跳到行尾                         |</span><br><span class="line">| **命令模式** | `dG`       | 从当前行开始，向下全部删除       |</span><br><span class="line">| **命令模式** | `dgg`      | 从当前行开始，向上全部删除       |</span><br><span class="line">| **命令模式** | `d$`       | 从当前光标开始，删除到本行的结尾 |</span><br><span class="line">| **命令模式** | `d0`       | 从当前光标开始，删除到本行的开头 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 底线命令快捷键</span><br><span class="line"></span><br><span class="line">![image-20240514212954898](./Linux/image-20240514212954898.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 命令的选项</span><br><span class="line"></span><br><span class="line">我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。</span><br><span class="line"></span><br><span class="line">比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。</span><br><span class="line"></span><br><span class="line">课程中， 并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。</span><br><span class="line"></span><br><span class="line">课程中，会对常见的选项进行讲解， 足够满足绝大多数的学习、工作场景。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 查看命令的帮助</span><br><span class="line"></span><br><span class="line">可以通过：`命令 --help`查看命令的帮助手册</span><br><span class="line"></span><br><span class="line">![image-20240514213545358](./Linux/image-20240514213545358.png)</span><br><span class="line"></span><br><span class="line">### 查看命令的详细手册</span><br><span class="line"></span><br><span class="line">可以通过：`man 命令`查看某命令的详细手册</span><br><span class="line"></span><br><span class="line">![image-20240514213539751](./Linux/image-20240514213539751.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Linux常用操作</span><br><span class="line"></span><br><span class="line">## 软件安装</span><br><span class="line"></span><br><span class="line">- CentOS系统使用：</span><br><span class="line">  - yum [install remove search] [-y] 软件名称</span><br><span class="line">    - install 安装</span><br><span class="line">    - remove 卸载</span><br><span class="line">    - search 搜索</span><br><span class="line">    - -y，自动确认</span><br><span class="line">- Ubuntu系统使用</span><br><span class="line">  - apt [install remove search] [-y] 软件名称</span><br><span class="line">    - install 安装</span><br><span class="line">    - remove 卸载</span><br><span class="line">    - search 搜索</span><br><span class="line">    - -y，自动确认</span><br><span class="line"></span><br><span class="line">&gt; yum 和 apt 均需要root权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## systemctl</span><br><span class="line"></span><br><span class="line">功能：控制系统服务的启动关闭等</span><br><span class="line"></span><br><span class="line">语法：`systemctl start | stop | restart | disable | enable | status 服务名`</span><br><span class="line"></span><br><span class="line">- start，启动</span><br><span class="line">- stop，停止</span><br><span class="line">- status，查看状态</span><br><span class="line">- disable，关闭开机自启</span><br><span class="line">- enable，开启开机自启</span><br><span class="line">- restart，重启</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 软链接</span><br><span class="line"></span><br><span class="line">功能：创建文件、文件夹软链接（快捷方式）</span><br><span class="line"></span><br><span class="line">语法：`ln -s 参数1 参数2`</span><br><span class="line"></span><br><span class="line">- 参数1：被链接的</span><br><span class="line">- 参数2：要链接去的地方（快捷方式的名称和存放位置）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 日期</span><br><span class="line"></span><br><span class="line">语法：`date [-d] [+格式化字符串]`</span><br><span class="line"></span><br><span class="line">- -d 按照给定的字符串显示日期，一般用于日期计算</span><br><span class="line"></span><br><span class="line">- 格式化字符串：通过特定的字符串标记，来控制显示的日期格式</span><br><span class="line">  - %Y   年%y   年份后两位数字 (00..99)</span><br><span class="line">  - %m   月份 (01..12)</span><br><span class="line">  - %d   日 (01..31)</span><br><span class="line">  - %H   小时 (00..23)</span><br><span class="line">  - %M   分钟 (00..59)</span><br><span class="line">  - %S   秒 (00..60)</span><br><span class="line">  - %s   自 1970-01-01 00:00:00 UTC 到现在的秒数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">- 按照2022-01-01的格式显示日期</span><br><span class="line"></span><br><span class="line">  ![image-20240514213528329](./Linux/image-20240514213528329.png)</span><br><span class="line"></span><br><span class="line">- 按照2022-01-01 10:00:00的格式显示日期</span><br><span class="line"></span><br><span class="line">  ![image-20240514213523029](./Linux/image-20240514213523029.png)</span><br><span class="line"></span><br><span class="line">- -d选项日期计算</span><br><span class="line"></span><br><span class="line">  ![image-20240514213518516](./Linux/image-20240514213518516.png)</span><br><span class="line"></span><br><span class="line">  - 支持的时间标记为：</span><br><span class="line"></span><br><span class="line">    ![image-20240514213514134](./Linux/image-20240514213514134.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 时区</span><br><span class="line"></span><br><span class="line">修改时区为中国时区</span><br><span class="line"></span><br><span class="line">![image-20221027220554654](https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220554.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## ntp</span><br><span class="line"></span><br><span class="line">功能：同步时间</span><br><span class="line"></span><br><span class="line">安装：`yum install -y ntp`</span><br><span class="line"></span><br><span class="line">启动管理：`systemctl start | stop | restart | status | disable | enable ntpd`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">手动校准时间：`ntpdate -u ntp.aliyun.com`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## ip地址</span><br><span class="line"></span><br><span class="line">格式：a.b.c.d</span><br><span class="line"></span><br><span class="line">- abcd为0~255的数字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">特殊IP：</span><br><span class="line"></span><br><span class="line">- 127.0.0.1，表示本机</span><br><span class="line">- 0.0.0.0</span><br><span class="line">  - 可以表示本机</span><br><span class="line">  - 也可以表示任意IP（看使用场景）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看ip：`ifconfig`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 主机名</span><br><span class="line"></span><br><span class="line">功能：Linux系统的名称</span><br><span class="line"></span><br><span class="line">查看：`hostname`</span><br><span class="line"></span><br><span class="line">设置：`hostnamectl set-hostname 主机名`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 配置VMware固定IP</span><br><span class="line"></span><br><span class="line">1. 修改VMware网络，参阅PPT，图太多</span><br><span class="line"></span><br><span class="line">2. 设置Linux内部固定IP</span><br><span class="line"></span><br><span class="line">   修改文件：`/etc/sysconfig/network-scripts/ifcfg-ens33`</span><br><span class="line"></span><br><span class="line">   示例文件内容：</span><br><span class="line"></span><br><span class="line">   ```shell</span><br><span class="line">   TYPE=&quot;Ethernet&quot;</span><br><span class="line">   PROXY_METHOD=&quot;none&quot;</span><br><span class="line">   BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">   BOOTPROTO=&quot;static&quot;# 改为static，固定IP</span><br><span class="line">   DEFROUTE=&quot;yes&quot;</span><br><span class="line">   IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">   IPV6INIT=&quot;yes&quot;</span><br><span class="line">   IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">   IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">   IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">   IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">   NAME=&quot;ens33&quot;</span><br><span class="line">   UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;</span><br><span class="line">   DEVICE=&quot;ens33&quot;</span><br><span class="line">   ONBOOT=&quot;yes&quot;</span><br><span class="line">   IPADDR=&quot;192.168.88.131&quot;# IP地址，自己设置，要匹配网络范围</span><br><span class="line">   NETMASK=&quot;255.255.255.0&quot;# 子网掩码，固定写法255.255.255.0</span><br><span class="line">   GATEWAY=&quot;192.168.88.2&quot;# 网关，要和VMware中配置的一致</span><br><span class="line">   DNS1=&quot;192.168.88.2&quot;# DNS1服务器，和网关一致即可</span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>功能：查看进程信息</p><p>语法：<code>ps -ef</code>，查看全部进程信息，可以搭配grep做过滤：<code>ps -ef | grep xxx</code></p><h2 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h2><p><img src="/.com//image-20240514213501448.png" alt="image-20240514213501448"></p><h2 id="nmap命令"><a href="#nmap命令" class="headerlink" title="nmap命令"></a>nmap命令</h2><p><img src="/.com//image-20240514213455076.png" alt="image-20240514213455076"></p><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><p>功能：查看端口占用</p><p>用法：<code>netstat -anp | grep xxx</code></p><h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><p>测试网络是否联通</p><p>语法：<code>ping [-c num] 参数</code></p><p><img src="/.com//image-20240514213446601.png" alt="image-20240514213446601"></p><h2 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h2><p><img src="/.com//image-20240514213436429.png" alt="image-20240514213436429"></p><h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><p><img src="/.com//image-20240514213428349.png" alt="image-20240514213428349"></p><p><img src="/.com//image-20240514213422455.png" alt="image-20240514213422455"></p><h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><p>功能：查看主机运行状态</p><p>语法：<code>top</code>，查看基础信息</p><p>可用选项：</p><p><img src="/.com//image-20240514213411146.png" alt="image-20240514213411146"></p><p>交互式模式中，可用快捷键：</p><p><img src="/.com//image-20240514213405285.png" alt="image-20240514213405285"></p><h2 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h2><p>查看磁盘占用</p><p><img src="/.com//image-20240514213350037.png" alt="image-20240514213350037"></p><h2 id="iostat命令"><a href="#iostat命令" class="headerlink" title="iostat命令"></a>iostat命令</h2><p>查看CPU、磁盘的相关信息</p><p><img src="/.com//image-20240514213341010.png" alt="image-20240514213341010"></p><p><img src="/.com//image-20240514213334228.png" alt="image-20240514213334228"></p><h2 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h2><p>查看网络统计</p><p><img src="/.com//image-20240514213316310.png" alt="image-20240514213316310"></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>临时设置：export 变量名&#x3D;变量值</li><li>永久设置：<ul><li>针对用户，设置用户HOME目录内：<code>.bashrc</code>文件</li><li>针对全局，设置<code>/etc/profile</code></li></ul></li></ul><h3 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h3><p>记录了执行程序的搜索路径</p><p>可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果</p><h2 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h2><p>可以取出指定的环境变量的值</p><p>语法：<code>$变量名</code></p><p>示例：</p><p><code>echo $PATH</code>，输出PATH环境变量的值</p><p><code>echo $&#123;PATH&#125;ABC</code>，输出PATH环境变量的值以及ABC</p><p>如果变量名和其它内容混淆在一起，可以使用${}</p><h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><code>tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N</code></p><ul><li>-z表示使用gzip，可以不写</li></ul><p><code>zip [-r] 参数1 参数2 参数N</code></p><p><img src="/.com//image-20240514213306989.png" alt="image-20240514213306989"></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><code>tar -zxvf 被解压的文件 -C 要解压去的地方</code></p><ul><li>-z表示使用gzip，可以省略</li><li>-C，可以省略，指定要解压去的地方，不写解压到当前目录</li></ul><p><code>unzip [-d] 参数</code></p><p><img src="/.com//image-20240514213259749.png" alt="image-20240514213259749"></p><h2 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h2><p>切换用户</p><p>语法：<code>su [-] [用户]</code></p><p><img src="/.com//image-20240514213251660.png" alt="image-20240514213251660"></p><h2 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h2><p><img src="/.com//image-20240514213246030.png" alt="image-20240514213246030"></p><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itheima ALL=(ALL)       NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>在visudo内配置如上内容，可以让itheima用户，无需密码直接使用<code>sudo</code></p><h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>修改文件、文件夹权限</p><p>语法：<code>chmod [-R] 权限 参数</code></p><ul><li><p>权限，要设置的权限，比如755，表示：<code>rwxr-xr-x</code></p><p><img src="/.com//image-20240514213237881.png" alt="image-20240514213237881"></p></li><li><p>参数，被修改的文件、文件夹</p></li><li><p>选项-R，设置文件夹和其内部全部内容一样生效</p></li></ul><h2 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h2><p>修改文件、文件夹所属用户、组</p><p>语法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code></p><p><img src="/.com//image-20240514213227133.png" alt="image-20240514213227133"></p><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p><img src="/.com//image-20240514213217206.png" alt="image-20240514213217206"></p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p><img src="/.com//image-20240514213144475.png" alt="image-20240514213144475"></p><h2 id="genenv命令"><a href="#genenv命令" class="headerlink" title="genenv命令"></a>genenv命令</h2><ul><li><p><code>getenv group</code>，查看系统全部的用户组</p><p><img src="/.com//image-20240514213133464.png" alt="image-20240514213133464"></p></li><li><p><code>getenv passwd</code>，查看系统全部的用户</p><p><img src="/.com//image-20240514213126691.png" alt="image-20240514213126691"></p></li></ul><h2 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h2><p>查看系统全部的环境变量</p><p>语法：<code>env</code></p><h1 id="Shell脚本编程"><a href="#Shell脚本编程" class="headerlink" title="Shell脚本编程"></a>Shell脚本编程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Shell是什么？</p><ul><li>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动，挂起，停止甚至是编写一些程序。看一个示意图</li></ul><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><ul><li>脚本要求格式<ul><li>脚本以 <code>#!bin/bash</code> 开头</li><li>脚本执行需要权限</li></ul></li><li>编写第一个Shell脚本<ul><li>需求说明，新建一个Shell脚本，输出Hello world</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建shell脚本，注意以sh结尾</span></span><br><span class="line">mkdir hello.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">两种执行方式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. (使用脚本的绝对路径和相对路径)默认root是没有执行权限的，我们要给shell脚本添加x运行权限</span></span><br><span class="line">chmod u+x hello.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行</span></span><br><span class="line">./hello.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. (sh+脚本)使用sh命令直接运行，不需要添加x权限</span></span><br><span class="line">sh hello.sh</span><br></pre></td></tr></table></figure><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>Shell变量介绍<ul><li>Linux Shell中的变量分为，系统变量和用户自定义变量</li><li>系统变量：$HOME、$PWD、$SHELL、$USER等，比如：echo $HOME 等等</li><li>显示当前shell中所有变量：set</li></ul></li><li>shell变量的定义<ul><li>定义变量：变量名&#x3D;值</li><li>撤销变量：unset 变量</li><li>声明静态变量：readonly变量，注意：不能unset</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例</span></span><br><span class="line">1. 定义变量A</span><br><span class="line">A=10</span><br><span class="line">echo A=$A  =&gt; A=100</span><br><span class="line">2. 撤销变量A</span><br><span class="line">unset A</span><br><span class="line">echo A=$A   =&gt; A=</span><br><span class="line">3. 声明静态变量B=2，不能unset</span><br><span class="line">readonly B=2</span><br><span class="line">echo B=$B  =&gt; B=2</span><br><span class="line">4. 可把比那辆提升为全局环境变量，可供其他shell程序使用[该案例后面将]</span><br></pre></td></tr></table></figure><p>注意：</p><p><img src="/.com//image-20240515090101325.png" alt="image-20240515090101325"></p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><ul><li>基本语法<ul><li><code>export 变量名=变量值</code>：将shell变量输出为环境变量&#x2F;全局变量</li><li><code>source 配置文件</code>：让修改后的配置信息立即生效</li><li><code>echo $变量名</code>：查询环境变量的值</li></ul></li></ul><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 在/etc/profile文件中定义TOMCAT_HOME环境变量</span><br><span class="line"><span class="meta prompt_">1&gt; </span><span class="language-bash">vim /etc/profile  进入vim编辑器</span></span><br><span class="line"><span class="meta prompt_">2&gt; </span><span class="language-bash"><span class="built_in">export</span> TOMCAT_HOME=/opt/tomcat  定义环境变量</span></span><br><span class="line"><span class="meta prompt_">3&gt; </span><span class="language-bash"><span class="built_in">source</span> /etc/profile  刷新</span></span><br><span class="line">2. 查看环境变量TOMCAT_HOME的值</span><br><span class="line">echo $TOMCAT_HOME  输出</span><br><span class="line">3. 在另外一个shell程序中使用TOMCAT_HOME</span><br><span class="line">进入另一个shell脚本</span><br><span class="line">echo &quot;tomcat_home=$TOMCAT_HOME&quot;</span><br></pre></td></tr></table></figure><p>shell脚本多行注释： <code>:&lt;&lt;! 内容 !</code></p><h2 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h2><ul><li><p>介绍</p><ul><li>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量，比如: <code>./myshell.sh 100 200</code>，这个就是一个执行shell的命令行，可以在myshell 脚本中获取到参数信息</li></ul></li><li><p>基本语法</p><ul><li><code>$n</code> ：n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}</li><li><code>$*</code> ：这个变量代表命令行中所有的参数，$* 把所有的参数堪称一个整体</li><li><code>$@</code> ：这个变量代表命令行中所有的参数，不过$@ 把每个参数区分对待</li><li><code>$#</code> ：这个变量代表命令行中所有参数的个数</li></ul></li></ul><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编写一个shell脚本position.sh 在脚本中获取到命令行的各个参数信息</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;0=$0 1=$1 2=$2&quot;</span><br><span class="line">echo &quot;所有的参数=$*&quot;</span><br><span class="line">echo &quot;$@&quot;</span><br><span class="line">echo &quot;所有的参数个数=$#&quot;</span><br></pre></td></tr></table></figure><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><ul><li><p>基本介绍</p><ul><li>就是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用</li></ul></li><li><p>基本语法</p><ul><li><code>$$</code> ：当前进程的进程号(PID)</li><li><code>$!</code> ：后台运行的最后一个进程的进程号(PID)</li><li><code>$?</code> ：最后一次执行的命令的返回状态，如果这个变量的职位0，证明上一个命令正确执行，如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了</li></ul></li></ul><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在一个shell脚本中简单使用一下预定义变量preVar.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;当前正在运行的进程号id=$$&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以后台的方式运行一个脚本，并获取他的进程号</span></span><br><span class="line">./myshell.sh &amp;</span><br><span class="line">echo &quot;后台运行的最后一个进程号=$!&quot;</span><br><span class="line">echo &quot;最后一次执行的结果=$?&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li><p>基本介绍</p><ul><li>学习如何在shell中进行各种运算操作</li></ul></li><li><p>基本语法</p><ul><li>“$((运算式))” 或 “$[运算式]” 或者 expr m + n</li><li>注意expr 运算符间要有空格，如果希望将expr 的结果赋给某个变量，使用&#96;&#96;</li><li>expr m - n</li><li>expr <code>\*</code>, <code>/</code>, <code>%</code>  乘、除、取余</li></ul></li></ul><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算(2+3)*4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一种方式</span></span><br><span class="line">RES1=$(((2+3)*4))</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二种方式</span></span><br><span class="line">RES2=$[(2+3)*4]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第三种方式</span></span><br><span class="line">TEMP=`expr 2 + 3`</span><br><span class="line">RES=`expr $TEMP \* 4`</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请求出命令行的两个参数[整数] 和 20</span></span><br><span class="line">SUM=$[$1+$2]</span><br><span class="line">./oper.sh 20 50</span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p><img src="/.com//image-20240515095940187.png" alt="image-20240515095940187"></p><p><img src="/.com//image-20240515100008957.png" alt="image-20240515100008957"></p><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例1. <span class="string">&quot;ok&quot;</span> 是否等于 <span class="string">&quot;ok&quot;</span></span></span><br><span class="line">if [ &quot;ok&quot; = &quot;ok&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;equal&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例2. 23是否大于等于22</span></span><br><span class="line">if [ 23 -ge 22 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;大于&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例3. /root/shcode/aaa.txt 目录中的文件是否存在</span></span><br><span class="line">if [ -f /root/shcode/aaa.txt ]</span><br><span class="line">then</span><br><span class="line">echo &quot;存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if分支"><a href="#if分支" class="headerlink" title="if分支"></a>if分支</h3><p><img src="/.com//image-20240515103100113.png" alt="image-20240515103100113"></p><p>注意：[条件判断式] 中括号和条件判断式之间必须有空格</p><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请编写一个shell程序，如果输入的参数，大于等于60 则输出<span class="string">&quot;及格了&quot;</span> 如果小于60，则输出 <span class="string">&quot;不及格&quot;</span></span></span><br><span class="line">if [ $1 -ge 60 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;及格了&quot;</span><br><span class="line">elif [ $1 -lt 60 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;不及格&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><p><img src="/.com//image-20240515103930040.png" alt="image-20240515103930040"></p><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当命令行参数是1时，输出<span class="string">&quot;周一&quot;</span>，是2时，就输出<span class="string">&quot;周二&quot;</span>，其他情况输出 <span class="string">&quot;other&quot;</span></span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">echo &quot;周一&quot;</span><br><span class="line">;;</span><br><span class="line">case $2 in</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">echo &quot;周二&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;other&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><img src="/.com//image-20240515104846827.png" alt="image-20240515104846827"></p><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印命令行输入的参数[这里可以看出$* 和 <span class="variable">$@</span> 的区别]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$* 会把参数当成一个整体 所以只会输出一句话</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$@</span> 会把参数区分，所以有几个参数 就输出几句话</span></span><br><span class="line">for i in &quot;$*/$@&quot;</span><br><span class="line">do</span><br><span class="line">echo &quot;i的值为$i&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从1加到100的值输出显示</span></span><br><span class="line">SUM=0</span><br><span class="line">for (( i=1; i&lt;=$1; i++ ))</span><br><span class="line">do</span><br><span class="line">SUM=$[$SUM+$i]</span><br><span class="line">done</span><br><span class="line">echo &quot;SUM=$SUM&quot;</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><img src="/.com//image-20240515105936017.png" alt="image-20240515105936017"></p><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从命令中输入一个数n,求1+...+n的值是多少</span></span><br><span class="line">SUM=0</span><br><span class="line">i=0</span><br><span class="line">while [ $i -gt $1 ]</span><br><span class="line">do</span><br><span class="line">SUM=$[$SUM+$i]</span><br><span class="line">i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo &quot;SUM的值=$SUM&quot;</span><br></pre></td></tr></table></figure><h2 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h2><p><img src="/.com//image-20240515110647470.png" alt="image-20240515110647470"></p><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例1：读取控制台输入一个num值</span></span><br><span class="line">read -p &quot;请输入一个数num1=&quot; NUM1</span><br><span class="line">echo &quot;你输入的num1=$NUM1&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例2：读取控制台输入一个num值，在10s内输入</span></span><br><span class="line">read -t 10 -p &quot;请输入一个数NUM1=&quot; NUM1</span><br><span class="line">echo &quot;你输入的num1=&quot;$NUM1</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h3><ul><li>函数介绍<ul><li>shell编程和其他语言一样，有系统函数，也可以自定义函数，系统函数中，我们这里就介绍两个</li></ul></li></ul><p><img src="/.com//image-20240515111138084.png" alt="image-20240515111138084"></p><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例1：请返回/home/aaa/test.txt的 <span class="string">&quot;test.txt&quot;</span> 的部分</span></span><br><span class="line">basename /home/aaa/test.txt =&gt; test.txt</span><br><span class="line">basename /home/aaa/test.txt .txt =&gt; test</span><br></pre></td></tr></table></figure><h3 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h3><p><img src="/.com//image-20240515111520036.png" alt="image-20240515111520036"></p><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例1：请返回/home/aaa/test.txt 的 /home/aaa</span></span><br><span class="line">dirname /home/aaa/test.txt</span><br></pre></td></tr></table></figure><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p><img src="/.com//image-20240515111933117.png" alt="image-20240515111933117"></p><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">案例1：计算输入两个参数的和(动态的获取)，getSum</span></span><br><span class="line">function getSum()</span><br><span class="line">&#123;</span><br><span class="line">SUM=$[$1+$2]</span><br><span class="line">echo &quot;和是=$SUM&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;请输入一个数字n1=&quot; n1</span><br><span class="line">read -p &quot;请输入一个数字n2=&quot; n2</span><br><span class="line"></span><br><span class="line">getSum $n1 $n2</span><br></pre></td></tr></table></figure><h3 id="Shell脚本案例"><a href="#Shell脚本案例" class="headerlink" title="Shell脚本案例"></a>Shell脚本案例</h3><p><img src="/.com//image-20240515132902308.png" alt="image-20240515132902308"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">BACKUP=/data/backup/db</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前时间</span></span><br><span class="line">DATETIME=$(date +%Y-%m-%d_%H_%M_%S)</span><br><span class="line">echo $DATETIME</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据库的地址</span></span><br><span class="line">HOST=localhost</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据库的用户名</span></span><br><span class="line">DB_USER=root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据库密码</span></span><br><span class="line">DB_PW=Zikl142857</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据库名</span></span><br><span class="line">DATABASE=raehp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建备份目录</span></span><br><span class="line">[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份数据库</span></span><br><span class="line">mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PW&#125; --host=$&#123;HOST&#125; -q -R --databases $&#123;DATABASE&#125; | gzip &gt; $&#123;BACKUP&#125;/$&#123;DATETIME&#125;/$DATETIME.sql.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件处理成tar.gz</span></span><br><span class="line">cd $&#123;BACKUP&#125;</span><br><span class="line">tar -zcvf $DATETIME.tar.gz $&#123;DATETIME&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除对应的备份文件</span></span><br><span class="line">rm -rf $&#123;BACKUP&#125;/$&#123;DATETIME&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否有10天前的备份数据库文件</span></span><br><span class="line">find $&#123;BACKUP&#125; -atime +10 -name &quot;*.tar.gz&quot; -exec rm &#123;&#125; \;</span><br><span class="line">echo &quot;备份数据库$&#123;DATABASE&#125;成功&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>私服配置说明</title>
      <link href="/2024/04/25/%E7%A7%81%E6%9C%8D%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/04/25/%E7%A7%81%E6%9C%8D%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><p>这一节，我们主要学习的内容是:</p><ul><li>私服简介</li><li>私服仓库分类</li><li>资源上传与下载</li></ul><p>首先来说一说什么是私服?</p><h3 id="私服简介"><a href="#私服简介" class="headerlink" title="私服简介"></a>私服简介</h3><p>团队开发现状分析</p><p><img src="/.com//1630987192620.png" alt="1630987192620"></p><p>(1)张三负责ssm_crm的开发，自己写了一个ssm_pojo模块，要想使用直接将ssm_pojo安装到本地仓库即可</p><p>(2)李四负责ssm_order的开发，需要用到张三所写的ssm_pojo模块，这个时候如何将张三写的ssm_pojo模块交给李四呢?</p><p>(3)如果直接拷贝，那么团队之间的jar包管理会非常混乱而且容器出错，这个时候我们就想能不能将写好的项目上传到中央仓库，谁想用就直接联网下载即可</p><p>(4)Maven的中央仓库不允许私人上传自己的jar包,那么我们就得换种思路，自己搭建一个类似于中央仓库的东西，把自己的内容上传上去，其他人就可以从上面下载jar包使用</p><p>(5)这个类似于中央仓库的东西就是我们接下来要学习的&#x3D;&#x3D;私服&#x3D;&#x3D;</p><p>所以到这就有两个概念，一个是私服，一个是中央仓库</p><p>私服:公司内部搭建的用于存储Maven资源的服务器</p><p>远程仓库:Maven开发团队维护的用于存储Maven资源的服务器</p><p>所以说:</p><ul><li>私服是一台独立的服务器，用于解决团队内部的资源共享与资源同步问题</li></ul><p>搭建Maven私服的方式有很多，我们来介绍其中一种使用量比较大的实现方式:</p><ul><li>Nexus<ul><li>Sonatype公司的一款maven私服产品</li><li>下载地址：<a href="https://help.sonatype.com/repomanager3/download">https://help.sonatype.com/repomanager3/download</a></li></ul></li></ul><h3 id="私服安装"><a href="#私服安装" class="headerlink" title="私服安装"></a>私服安装</h3><h4 id="步骤1-下载解压"><a href="#步骤1-下载解压" class="headerlink" title="步骤1:下载解压"></a>步骤1:下载解压</h4><p>将<code>资料\latest-win64.zip</code>解压到一个空目录下。</p><p><img src="/.com//1630988572349.png" alt="1630988572349"></p><h4 id="步骤2-启动Nexus"><a href="#步骤2-启动Nexus" class="headerlink" title="步骤2:启动Nexus"></a>步骤2:启动Nexus</h4><p><img src="/.com//1630988673245.png" alt="1630988673245"></p><p>使用cmd进入到解压目录下的<code>nexus-3.30.1-01\bin</code>,执行如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nexus.exe /run nexus</span><br></pre></td></tr></table></figure><p>看到如下内容，说明启动成功。</p><p><img src="/.com//1630988939301.png" alt="1630988939301"></p><h4 id="步骤3-浏览器访问"><a href="#步骤3-浏览器访问" class="headerlink" title="步骤3:浏览器访问"></a>步骤3:浏览器访问</h4><p>访问地址为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8081</span><br></pre></td></tr></table></figure><p><img src="/.com//1630988857125.png" alt="1630988857125"></p><h4 id="步骤4-首次登录重置密码"><a href="#步骤4-首次登录重置密码" class="headerlink" title="步骤4:首次登录重置密码"></a>步骤4:首次登录重置密码</h4><p><img src="/.com//1630988983159.png" alt="1630988983159"></p><p>输入用户名和密码进行登录，登录成功后，出现如下页面</p><p><img src="/.com//1630989052183.png" alt="1630989052183"></p><p>点击下一步，需要重新输入新密码，为了和后面的保持一致，密码修改为<code>admin</code></p><p><img src="/.com//1630989094756.png" alt="1630989094756"></p><p>设置是否运行匿名访问</p><p><img src="/.com//1630989122737.png" alt="1630989122737"></p><p>点击完成</p><p><img src="/.com//1630989136097.png" alt="1630989136097"></p><p>至此私服就已经安装成功。如果要想修改一些基础配置信息，可以使用:</p><ul><li>修改基础配置信息<ul><li>安装路径下etc目录中nexus-default.properties文件保存有nexus基础配置信息，例如默认访问端口。</li></ul></li><li>修改服务器运行配置信息<ul><li>安装路径下bin目录中nexus.vmoptions文件保存有nexus服务器启动对应的配置信息，例如默认占用内存空间。</li></ul></li></ul><h3 id="私服仓库分类"><a href="#私服仓库分类" class="headerlink" title="私服仓库分类"></a>私服仓库分类</h3><p>私服资源操作流程分析:</p><p><img src="/.com//1630989320979.png" alt="1630989320979"></p><p>(1)在没有私服的情况下，我们自己创建的服务都是安装在Maven的本地仓库中</p><p>(2)私服中也有仓库，我们要把自己的资源上传到私服，最终也是放在私服的仓库中</p><p>(3)其他人要想使用你所上传的资源，就需要从私服的仓库中获取</p><p>(4)当我们要使用的资源不是自己写的，是远程中央仓库有的第三方jar包，这个时候就需要从远程中央仓库下载，每个开发者都去远程中央仓库下速度比较慢(中央仓库服务器在国外)</p><p>(5)私服就再准备一个仓库，用来专门存储从远程中央仓库下载的第三方jar包，第一次访问没有就会去远程中央仓库下载，下次再访问就直接走私服下载</p><p>(6)前面在介绍版本管理的时候提到过有<code>SNAPSHOT</code>和<code>RELEASE</code>，如果把这两类的都放到同一个仓库，比较混乱，所以私服就把这两个种jar包放入不同的仓库</p><p>(7)上面我们已经介绍了有三种仓库，一种是存放<code>SNAPSHOT</code>的，一种是存放<code>RELEASE</code>还有一种是存放从远程仓库下载的第三方jar包，那么我们在获取资源的时候要从哪个仓库种获取呢?</p><p>(8)为了方便获取，我们将所有的仓库编成一个组，我们只需要访问仓库组去获取资源。</p><p>所有私服仓库总共分为三大类:</p><p>宿主仓库hosted </p><ul><li>保存无法从中央仓库获取的资源<ul><li>自主研发</li><li>第三方非开源项目,比如Oracle,因为是付费产品，所以中央仓库没有</li></ul></li></ul><p>代理仓库proxy </p><ul><li>代理远程仓库，通过nexus访问其他公共仓库，例如中央仓库</li></ul><p>仓库组group </p><ul><li>将若干个仓库组成一个群组，简化配置</li><li>仓库组不能保存资源，属于设计型仓库</li></ul><p><img src="/.com//1630990244010.png" alt="1630990244010"></p><h3 id="本地仓库访问私服配置"><a href="#本地仓库访问私服配置" class="headerlink" title="本地仓库访问私服配置"></a>本地仓库访问私服配置</h3><ul><li>我们通过IDEA将开发的模块上传到私服，中间是要经过本地Maven的</li><li>本地Maven需要知道私服的访问地址以及私服访问的用户名和密码</li><li>私服中的仓库很多，Maven最终要把资源上传到哪个仓库?</li><li>Maven下载的时候，又需要携带用户名和密码到私服上找对应的仓库组进行下载，然后再给IDEA</li></ul><p><img src="/.com//1630990538229.png" alt="1630990538229"></p><p>上面所说的这些内容，我们需要在本地Maven的配置文件<code>settings.xml</code>中进行配置。</p><h4 id="步骤1-私服上配置仓库"><a href="#步骤1-私服上配置仓库" class="headerlink" title="步骤1:私服上配置仓库"></a>步骤1:私服上配置仓库</h4><p><img src="/.com//1630991211000.png" alt="1630991211000"></p><p><strong>说明:</strong></p><p>第5，6步骤是创建itheima-snapshot仓库</p><p>第7，8步骤是创建itheima-release仓库</p><h4 id="步骤2-配置本地Maven对私服的访问权限"><a href="#步骤2-配置本地Maven对私服的访问权限" class="headerlink" title="步骤2:配置本地Maven对私服的访问权限"></a>步骤2:配置本地Maven对私服的访问权限</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>itheima-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>itheima-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="步骤3-配置私服的访问路径"><a href="#步骤3-配置私服的访问路径" class="headerlink" title="步骤3:配置私服的访问路径"></a>步骤3:配置私服的访问路径</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置仓库组的ID--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--*代表所有内容都从私服获取--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--私服仓库组maven-public的访问路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了避免阿里云Maven私服地址的影响，建议先将之前配置的阿里云Maven私服镜像地址注释掉，等练习完后，再将其恢复。</p><p><img src="/.com//1630991535107.png" alt="1630991535107"></p><p>至此本地仓库就能与私服进行交互了。</p><h3 id="私服资源上传与下载"><a href="#私服资源上传与下载" class="headerlink" title="私服资源上传与下载"></a>私服资源上传与下载</h3><p>本地仓库与私服已经建立了连接，接下来我们就需要往私服上上传资源和下载资源，具体的实现步骤为:</p><h4 id="步骤1-配置工程上传私服的具体位置"><a href="#步骤1-配置工程上传私服的具体位置" class="headerlink" title="步骤1:配置工程上传私服的具体位置"></a>步骤1:配置工程上传私服的具体位置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--配置当前工程保存在私服中的具体位置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--和maven/settings.xml中server中的id一致，表示使用该id对应的用户名和密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>itheima-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--release版本上传仓库的具体地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/itheima-release/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--和maven/settings.xml中server中的id一致，表示使用该id对应的用户名和密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>itheima-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--snapshot版本上传仓库的具体地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/itheima-snapshot/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="步骤2-发布资源到私服"><a href="#步骤2-发布资源到私服" class="headerlink" title="步骤2:发布资源到私服"></a>步骤2:发布资源到私服</h4><p><img src="/.com//1630992305191.png" alt="1630992305191"></p><p>或者执行Maven命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>要发布的项目都需要配置<code>distributionManagement</code>标签，要么在自己的pom.xml中配置，要么在其父项目中配置，然后子项目中继承父项目即可。</p><p>发布成功，在私服中就能看到:</p><p><img src="/.com//1630992513299.png" alt="1630992513299"></p><p>现在发布是在itheima-snapshot仓库中，如果想发布到itheima-release仓库中就需要将项目pom.xml中的version修改成RELEASE即可。</p><p>如果想删除已经上传的资源，可以在界面上进行删除操作:</p><p><img src="/.com//1630992952378.png" alt="1630992952378"></p><p>如果私服中没有对应的jar，会去中央仓库下载，速度很慢。可以配置让私服去阿里云中下载依赖。</p><p><img src="/.com//1630993028454.png" alt="1630993028454"></p><p>至此私服的搭建就已经完成，相对来说有点麻烦，但是步骤都比较固定，后期大家如果需要的话，就可以参考上面的步骤一步步完成搭建即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>白盒测试</title>
      <link href="/2024/04/25/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/04/25/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a><strong>白盒测试</strong></h1><p>代码逻辑的测试</p><p><strong>定义：</strong> 白盒测试是一种测试方法，测试人员考虑程序的内部结构、<strong>代码逻辑</strong>和<strong>算法</strong>来验证软件的正确性</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点：</strong></h2><p>优点：代码覆盖率高</p><p>缺点：1.覆盖所有代码路径难度大 2.业务功能可能覆盖不全 3.测试开销大</p><h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a><strong>使用场景：</strong></h2><ul><li><strong>单元测试(主要)：</strong> 白盒测试常用于测试单个模块、函数或方法，确保其在各种输入条件下都能正确执行。</li><li><strong>集成测试：</strong> 在系统集成的过程中，白盒测试可以用于验证各个模块之间的接口和数据流是否正确。</li><li><strong>性能测试：</strong> 白盒测试也可用于评估系统的性能，例如检查代码中的效率和资源利用情况。</li></ul><h2 id="白盒设计方法（先静态后动态）"><a href="#白盒设计方法（先静态后动态）" class="headerlink" title="白盒设计方法（先静态后动态）"></a><strong>白盒设计方法（先静态后动态）</strong></h2><p>设计用例一般使用基本路径测试，重点模块使用多种覆盖率标准</p><p><strong>静态</strong>&#x3D;&#x3D;&gt;【1.桌面检查 2.代码审查 3.代码走查 】（手动）【4.代码扫描工具】（自动化）</p><p><strong>动态</strong>&#x3D;&#x3D;&gt;1.逻辑覆盖法&#x3D;&#x3D;&gt;1.语句覆盖 2.判定覆盖 3.条件覆盖 4.判定条件覆盖 5.条件组合覆盖 6.路径覆盖</p><p>&#x9;  2.基本路径测试法</p><h2 id="动态测试方法"><a href="#动态测试方法" class="headerlink" title="动态测试方法"></a>动态测试方法</h2><h3 id="1-逻辑覆盖法"><a href="#1-逻辑覆盖法" class="headerlink" title="1.逻辑覆盖法"></a><strong>1.逻辑覆盖法</strong></h3><p>是对程序逻辑结构的遍历实现程序的覆盖</p><h4 id="语句覆盖"><a href="#语句覆盖" class="headerlink" title="语句覆盖"></a><strong>语句覆盖</strong></h4><p>介绍：设计测试用例，使得程序中每条语句都至少执行一次 （基本要求:尽可能的满足100%覆盖率）</p><p>局限性：标准最弱、不能准确的判断运算中的逻辑错误</p><h4 id="判定覆盖"><a href="#判定覆盖" class="headerlink" title="判定覆盖"></a><strong>判定覆盖</strong></h4><p>介绍：只要满足了判定覆盖标准就一定满足语句覆盖标，</p><p>局限性：判定覆盖会忽略条件中取或(or)的情况</p><h4 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h4><p>介绍：设计测试用例，使得判定中的每个条件至少有一次取真值，有一次取假值</p><p>局限性：条件覆盖不能保证判定覆盖</p><h4 id="判定条件覆盖"><a href="#判定条件覆盖" class="headerlink" title="判定条件覆盖"></a>判定条件覆盖</h4><p>设计测试用例，使得被测试程序中的每个判断本身的判定结果(真假)至少被满足一次，同时，每个逻辑条件的可能值(真假)也至少满足一次，即同时满足100%判定覆盖和100%条件覆盖的标准&#x3D;&#x3D;【满足判定-条件覆盖标准一定能够满足条件覆盖、判定覆盖和语句覆盖】&#x3D;&#x3D;</p><p>局限性：判定覆盖会忽略条件中取或(or)的情况</p><h4 id="条件组合覆盖"><a href="#条件组合覆盖" class="headerlink" title="条件组合覆盖"></a><strong>条件组合覆盖</strong></h4><p>介绍：设计测试用例，使得被测试程序中的每个判定中条件结果的所有可能组合至少执行一次</p><p>局限性：条件组合覆盖不能保证所有路径被执行</p><h4 id="路径覆盖"><a href="#路径覆盖" class="headerlink" title="路径覆盖"></a><strong>路径覆盖</strong></h4><p>设计测试用例，覆盖程序中所有可能的路径</p><p>局限性：但是满足路径覆盖，并不一定能满足条件覆盖，也就不能满足条件组合盖</p><h3 id="2-基本路径测试："><a href="#2-基本路径测试：" class="headerlink" title="2.基本路径测试："></a><strong>2.基本路径测试：</strong></h3><h4 id="在程序控制流图的基础上，通过分析程序的环路复杂性，导出基本可执行路径集合，从而设计测试用例"><a href="#在程序控制流图的基础上，通过分析程序的环路复杂性，导出基本可执行路径集合，从而设计测试用例" class="headerlink" title="在程序控制流图的基础上，通过分析程序的环路复杂性，导出基本可执行路径集合，从而设计测试用例"></a><strong>在程序控制流图的基础上，通过分析程序的环路复杂性，导出基本可执行路径集合，从而设计测试用例</strong></h4><p><strong>计算程序的环路复杂度：</strong></p><p>方法有三种：</p><ul><li><p>流图中区域的数量对应于环型的复杂性</p></li><li><p>给定流图G的圈复杂度V(G)、定义为V(G)&#x3D;E-N+2, E是流图中边的数量，N是流图中节点的数量</p></li><li><p>给定流图G的圈复杂度V(G)、定义为V(G) &#x3D; P + 1 , P是流图G中判定节点的数量</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2024/04/25/git/"/>
      <url>/2024/04/25/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><p>什么是Git？</p><ul><li>Git是一个分布式版本控制工具，主要用于管理开发过程中的源代码文件（Java类、xml文件、html页面等）在软件开发过程中被广泛使用  </li><li>Git仓库分为两种：<ul><li>本地仓库：开发人员自己电脑上的Git仓库</li><li>远程仓库：远程服务器上的Git仓库</li></ul></li></ul><p><img src="/.com//image-20240403113135925-1712116181119-1.png" alt="image-20240403113135925"></p><ul><li>commit：提交，将本地文件和版本信息 保存到本地仓库</li><li>push：推送，将本地仓库文件和版本信息上传到远程仓库</li><li>pull：拉取，将远程仓库文件和版本信息下载到本地仓库</li></ul><h1 id="Git下载与操作"><a href="#Git下载与操作" class="headerlink" title="Git下载与操作"></a>Git下载与操作</h1><p><img src="/.com//image-20240403113332699-1712116181119-2.png" alt="image-20240403113332699"></p><h1 id="工作区、暂存区、版本库-概念"><a href="#工作区、暂存区、版本库-概念" class="headerlink" title="工作区、暂存区、版本库 概念"></a>工作区、暂存区、版本库 概念</h1><ul><li>版本库：.git隐藏文件夹就是版本库，版本库中 存储了很多配置信息，日志信息和文件版本信息</li><li>工作区：包含.git 文件夹的目录就是 工作区 ，也成为工作目录，主要用于存放开发的代码</li><li>暂存区：.git 文件夹中有很多文件，其中一个index文件就是暂存区，也叫做stage 暂存区是一个临时保存修改文件的地方</li></ul><p><img src="/.com//image-20240403121021210.png" alt="image-20240403121021210"></p><h1 id="工作区中文件的状态"><a href="#工作区中文件的状态" class="headerlink" title="工作区中文件的状态"></a>工作区中文件的状态</h1><p><strong>Git工作区中的文件存在两种状态：</strong></p><ul><li>untracked 未跟踪 （未被纳入版本控制）</li><li>tracked 已跟踪 （被纳入版本控制）<ul><li>Unmodified 未修改状态</li><li>Modified 已修改状态</li><li>Staged 已暂存状态</li></ul></li></ul><h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><h2 id="本地仓库常用命令："><a href="#本地仓库常用命令：" class="headerlink" title="本地仓库常用命令："></a>本地仓库常用命令：</h2><ul><li><code>git status</code>    查看文件状态</li><li><code>git add</code>              将文件的修改加入暂存区</li><li><code>git reset </code>          将暂存区的文件取消暂存 或者 切换到指定版本<ul><li><code>git reset 文件名</code> 将文件取消暂存<ul><li><img src="/.com//image-20240403122357867.png" alt="image-20240403122357867"></li></ul></li><li><code>git reset --hard 版本号</code> 切换到指定版本<ul><li><img src="/.com//image-20240403123039124.png" alt="image-20240403123039124"></li></ul></li></ul></li><li><code>git commit</code>        将暂存区的文件修改提交到版本库</li><li><code>git log</code>               查看日志<ul><li><img src="/.com//image-20240403123138085.png" alt="image-20240403123138085"></li></ul></li></ul><h2 id="远程仓库常见命令"><a href="#远程仓库常见命令" class="headerlink" title="远程仓库常见命令:"></a>远程仓库常见命令:</h2><ul><li><code>git remote</code>   <strong>查看远程仓库</strong><ul><li><img src="/.com//image-20240403123729559.png" alt="image-20240403123729559"></li></ul></li><li><code>git remote add &lt;shortname 可引用的简写&gt; &lt;url&gt;</code>   <strong>添加远程仓库</strong><ul><li><img src="/.com//image-20240403123744362.png" alt="image-20240403123744362"></li></ul></li><li><code>git clone [url]</code>  <strong>克隆远程仓库</strong><ul><li><img src="/.com//image-20240403123859314.png" alt="image-20240403123859314"></li></ul></li><li><code>git push [remote-name(简写的名字)] [brach-name(推送到的位置 分支)] </code>    <strong>推送至远程仓库</strong><ul><li><img src="/.com//image-20240403124122805.png" alt="image-20240403124122805"></li></ul></li><li><code>git pull [short-name] [branch-name 分支的名字  表示从哪个分支来拉取]</code>  从远程仓库拉取数据 合并到本地仓库<ul><li><img src="/.com//image-20240403133815133.png" alt="image-20240403133815133"></li></ul></li></ul><p><strong>注意：</strong> 如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉去文件的时候会报错（fatal：refusing to merge unrelated histories ）</p><p>解决此问题可以在 <code>git pull</code> 命令后加入参数：<code>--allow-unrelated-histories</code></p><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><p>分支是Git 使用过程中 非常重要的概念，使用分支意味着 你可以把你的工作 从开发主线上分离开来 以免避免开发主线。同一个仓库 可以有多个分支，各个分支相互独立，互不干扰 通过 <code>git init</code> 命令创建本地仓库时默认会创建一个master分支。</p><ul><li><p><code>git branch</code>  查看分支</p><ul><li><pre><code>git checkout<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `git branch [name]`  创建分支</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    git checkout b1</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><code>git checkout[name]</code>  切换分支</p><ul><li><pre><code>git checkout b1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `git push [shortName] [name]`  推送至远程仓库分支</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    git push origin master</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><code>git merge [name]</code>  合并分支</p><ul><li><pre><code># 把b1分支下的b1.txt合并到主分支git merge b1# 把b2分支下的b2.txt合并到主分支git merge b2</code></pre></li></ul></li></ul><h2 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h2><p>Git中的标签，指的是某个分支某个特定时间点的状态，通过标签，可以很方便的切换到标记时的状态，比较有代表性的是人们会使用这个功能来标记发布结点（v1.0  v1.2）</p><ul><li><code>git tag</code>   列出已有标签<ul><li><img src="/.com//image-20240403141948827.png" alt="image-20240403141948827"></li></ul></li><li><code>git tag [name]</code>   创建标签<ul><li><img src="/.com//image-20240403141942391.png" alt="image-20240403141942391"></li></ul></li><li><code>git push [shortname] [name]</code>    将标签推送至远程仓库<ul><li><img src="/.com//image-20240403141959742.png" alt="image-20240403141959742"></li></ul></li><li><code>git checkout -b [branch] [name]</code>    检出标签       检出标签时需要创建一个新分支来指向某个标签<ul><li><img src="/.com//image-20240425132313132.png" alt="image-20240425132313132"></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb笔记</title>
      <link href="/2024/04/25/JavaWeb/"/>
      <url>/2024/04/25/JavaWeb/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Maven是一款管理和构建java项目的工具</strong></p><h4 id="Maven的作用？"><a href="#Maven的作用？" class="headerlink" title="Maven的作用？"></a>Maven的作用？</h4><ul><li><p>方便依赖管理</p><p>方便快捷的管理项目依赖的资源(jar包)，避免版本冲突问题</p></li><li><p>统一项目结构</p><p>提供标准，统一的项目结构</p></li><li><p>项目构建</p><p>标准跨平台（Linux、Windows、MacOS）的自动化项目结构方式</p></li></ul><h4 id="Maven坐标"><a href="#Maven坐标" class="headerlink" title="Maven坐标"></a>Maven坐标</h4><p>什么是坐标？</p><ul><li>Maven中的坐标是&#x3D;&#x3D;资源的唯一标识&#x3D;&#x3D; , 通过该坐标可以唯一定位资源位置</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul><p>Maven坐标主要组成</p><ul><li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li><li>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</li><li>version：定义当前项目版本号</li></ul><p><img src="/.com//image-20240121152233994-1715613343037-1.png" alt="image-20240121152233994"></p><p><strong>注意：</strong></p><ul><li>上面所说的资源可以是插件、依赖、当前项目。</li><li>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</li></ul><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h3><p>依赖：指当前项目运行所需要的jar包。一个项目中可以引入多个依赖</p><p>例如：在当前工程中，我们需要用到logback来记录日志，此时就可以在maven工程的pom.xml文件中，引入logback的依赖。具体步骤如下：</p><ol><li><p>在pom.xml中编写<dependencies>标签</dependencies></p></li><li><p>在<dependencies>标签中使用<dependency>引入坐标</dependency></dependencies></p></li><li><p>定义坐标的 groupId、artifactId、version</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第1个依赖 : logback --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第2个依赖 : junit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ol><li>如果引入的依赖，在本地仓库中不存在，将会连接远程仓库 &#x2F; 中央仓库，然后下载依赖（这个过程会比较耗时，耐心等待）</li><li>如果不知道依赖的坐标信息，可以到mvn的中央仓库（<a href="https://mvnrepository.com/%EF%BC%89%E4%B8%AD%E6%90%9C%E7%B4%A2">https://mvnrepository.com/）中搜索</a></li></ol></blockquote><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><h4 id="依赖具有传递性"><a href="#依赖具有传递性" class="headerlink" title="依赖具有传递性"></a>依赖具有传递性</h4><p>依赖传递可以分为：</p><ol><li><p>直接依赖：在当前项目中通过依赖配置建立的依赖关系</p></li><li><p>间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</p></li></ol><p><img src="/.com//image-20240121153936896-1715613343037-2.png" alt="image-20240121153936896"></p><p>比如以上图中：</p><ul><li>projectA依赖了projectB。对于projectA 来说，projectB 就是直接依赖。</li><li>而projectB依赖了projectC及其他jar包。 那么此时，在projectA中也会将projectC的依赖传递下来。对于projectA 来说，projectC就是间接依赖。</li></ul><h4 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h4><p>问题：之前我们讲了依赖具有传递性。那么A依赖B，B依赖C，如果A不想将C依赖进来，是否可以做到？ </p><p>答案：在maven项目中，我们可以通过排除依赖来实现。</p><p>什么是排除依赖？</p><ul><li>排除依赖：指主动断开依赖的资源。（被排除的资源无需指定版本）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-projectB<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!--排除依赖, 主动断开依赖的资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>在项目中导入依赖的jar包后，默认情况下，可以在任何地方使用。</p><p>如果希望限制依赖的使用范围，可以通过<scope>标签设置其作用范围。</scope></p><p>作用范围：</p><ol><li><p>主程序范围有效（main文件夹范围内）</p></li><li><p>测试程序范围有效（test文件夹范围内）</p></li><li><p>是否参与打包运行（package指令范围内）</p></li></ol><table><thead><tr><th><strong>scope</strong>值</th><th><strong>主程序</strong></th><th><strong>测试程序</strong></th><th><strong>打包（运行）</strong></th><th><strong>范例</strong></th></tr></thead><tbody><tr><td>compile（默认）</td><td>Y</td><td>Y</td><td>Y</td><td>log4j</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr></tbody></table><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Maven的生命周期就是为了对所有的构建过程进行抽象和统一。 描述了一次项目构建，经历哪些阶段。</p><p>Maven对项目构建的生命周期划分为3套（相互独立）：</p><p><img src="/.com//image-20220616124015567.png"></p><ul><li><p>clean：清理工作。</p></li><li><p>default：核心工作。如：编译、测试、打包、安装、部署等。</p></li><li><p>site：生成报告、发布站点等。</p></li></ul><p>三套生命周期又包含哪些具体的阶段呢, 我们来看下面这幅图:</p><p><img src="/.com//image-20220616124348972.png" alt="image-20220616124348972"> </p><p>我们看到这三套生命周期，里面有很多很多的阶段，这么多生命周期阶段，其实我们常用的并不多，主要关注以下几个：</p><p>• clean：移除上一次构建生成的文件</p><p>• compile：编译项目源代码</p><p>• test：使用合适的单元测试框架运行测试(junit)</p><p>• package：将编译后的文件打包，如：jar、war等</p><p>• install：安装项目到本地仓库</p><p>Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际工作。<strong>在Maven的设计中，实际任务（如源代码编译）都交由插件来完成。</strong></p><p>生命周期的顺序是：clean –&gt; validate –&gt; compile –&gt; test –&gt; package –&gt; verify –&gt; install –&gt; site –&gt; deploy </p><p>我们需要关注的就是：clean –&gt;  compile –&gt; test –&gt; package  –&gt; install </p><blockquote><p>说明：在同一套生命周期中，我们在执行后面的生命周期时，前面的生命周期都会执行。</p></blockquote><blockquote><p> 思考：当运行package生命周期时，clean、compile生命周期会不会运行？</p><p> ​clean不会运行，compile会运行。  因为compile与package属于同一套生命周期，而clean与package不属于同一套生命周期。</p></blockquote><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>在日常开发中，当我们要执行指定的生命周期时，有两种执行方式：</p><ol><li>在idea工具右侧的maven工具栏中，选择对应的生命周期，双击执行</li><li>在DOS命令行中，通过maven命令执行</li></ol><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><ul><li>概念：Hyper Text Transfer Protocol ,超文本传输协议  规定了浏览器和服务器之间数据传输的规则</li><li>特点：<ol><li>基于TCP，面向连接，安全</li><li>基于请求-响应模型的：一次请求对应一次相应</li><li>HTTP协议是无状态的协议：对于事务处理没有记忆能力，每次请求-相应都是独立的。<ul><li>缺点：多次请求之间不能共享数据</li><li>优点：速度快</li></ul></li></ol></li></ul><h2 id="HTTP-请求数据格式"><a href="#HTTP-请求数据格式" class="headerlink" title="HTTP-请求数据格式"></a>HTTP-请求数据格式</h2><p><img src="/.com//image-20240125150954854.png"></p><p>请求方式-GET：请求参数在请求行中，没有请求体，如：&#x2F;brand&#x2F;findAll?name&#x3D;OPPO&amp;status&#x3D;1。GET请求大小是有限制的</p><p>请求方式-POST：请求参数在请求体中，POST请求大小是没有限制的</p><h2 id="请求响应介绍-HTTP响应格式"><a href="#请求响应介绍-HTTP响应格式" class="headerlink" title="请求响应介绍-HTTP响应格式"></a>请求响应介绍-HTTP响应格式</h2><p><img src="/.com//image-20240125152927891.png" alt="image-20240125152927891"></p><p><img src="/.com//image-20240125152946173-1715613343038-7.png" alt="image-20240125152946173"></p><h2 id="状态码大类"><a href="#状态码大类" class="headerlink" title="状态码大类"></a>状态码大类</h2><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong>——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</td></tr><tr><td>2xx</td><td><strong>成功</strong>——表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong>——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong>——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong>——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><h2 id="常见的响应状态码"><a href="#常见的响应状态码" class="headerlink" title="常见的响应状态码"></a>常见的响应状态码</h2><table><thead><tr><th>状态码</th><th>英文描述</th><th>解释</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;200&#x3D;&#x3D;</td><td><strong><code>OK</code></strong></td><td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td></tr><tr><td>302</td><td><strong><code>Found</code></strong></td><td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td></tr><tr><td>304</td><td><strong><code>Not Modified</code></strong></td><td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td></tr><tr><td>400</td><td><strong><code>Bad Request</code></strong></td><td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td></tr><tr><td>403</td><td><strong><code>Forbidden</code></strong></td><td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td></tr><tr><td>&#x3D;&#x3D;404&#x3D;&#x3D;</td><td><strong><code>Not Found</code></strong></td><td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td></tr><tr><td>405</td><td><strong><code>Method Not Allowed</code></strong></td><td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td></tr><tr><td>428</td><td><strong><code>Precondition Required</code></strong></td><td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td></tr><tr><td>429</td><td><strong><code>Too Many Requests</code></strong></td><td>指示用户在给定时间内发送了<strong>太多请求</strong>（“限速”），配合 Retry-After(多长时间后可以请求)响应头一起使用</td></tr><tr><td>431</td><td><strong><code> Request Header Fields Too Large</code></strong></td><td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td></tr><tr><td>&#x3D;&#x3D;500&#x3D;&#x3D;</td><td><strong><code>Internal Server Error</code></strong></td><td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td></tr><tr><td>503</td><td><strong><code>Service Unavailable</code></strong></td><td><strong>服务器尚未准备好处理请求</strong>，服务器刚刚启动，还未初始化好</td></tr></tbody></table><p>状态码大全：<a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a> </p><h1 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h1><ul><li>对HTTP协议操作进行封装，简化web程序开发</li><li>部署web项目，对外提供网上信息浏览服务</li></ul><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><ul><li>一个轻量级的web服务器，支持servlet、jsp等少了javaEE规范。</li><li>也被称为web容器，servlet容器</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>安装</li><li>卸载</li><li>启动：bin&#x2F;startup.bat</li><li>停止：bin&#x2F;shutdown.bat</li><li>部署：把文件夹移动到webapps文件夹下</li></ul><h1 id="Springboot内嵌Tomcat"><a href="#Springboot内嵌Tomcat" class="headerlink" title="Springboot内嵌Tomcat"></a>Springboot内嵌Tomcat</h1><h3 id="1-起步依赖"><a href="#1-起步依赖" class="headerlink" title="1.起步依赖"></a>1.起步依赖</h3><ul><li>spring-boot-starter-web</li><li>spring-boot-starter-test</li></ul><h3 id="2-内嵌Tomcat服务器"><a href="#2-内嵌Tomcat服务器" class="headerlink" title="2.内嵌Tomcat服务器"></a>2.内嵌Tomcat服务器</h3><ul><li>基于Springboot开发的web应用程序，内置了tomcat服务器，当启动类运行时，会自动启动内嵌的tomcat服务器**</li></ul><h1 id="请求响应"><a href="#请求响应" class="headerlink" title="请求响应"></a>请求响应</h1><h2 id="请求响应-1"><a href="#请求响应-1" class="headerlink" title="请求响应"></a>请求响应</h2><p><img src="/.com//Snipaste_2024-02-02_14-50-38.jpg"></p><ul><li>请求（HttpServletRequest）：获取请求数据</li><li>相应（HttpServletResponse）：设置响应数据</li><li>BS架构：Browser&#x2F;Server，浏览器&#x2F;服务端架构模式，服务端只需要浏览器，应用程序的逻辑和数据都存储在服务器（维护方便  体验一般）</li><li>CS架构：Client&#x2F;Server，客户端&#x2F;服务端架构模式。（开发、维护麻烦  体验不错）</li></ul><h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件</p><p>作用：常用于进行接口测试</p><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><h4 id="简单参数"><a href="#简单参数" class="headerlink" title="简单参数"></a>简单参数</h4><h5 id="1-原始方式获取请求参数"><a href="#1-原始方式获取请求参数" class="headerlink" title="1.原始方式获取请求参数"></a><strong>1.原始方式获取请求参数</strong></h5><p>在原始的web程序，获取请求参数，需要通过HttpServletRequest对象手动获取。</p><ul><li>Controller方法形参中声明HttpServletRequest对象</li><li>调用对象的getParameter(参数名)</li><li><img src="/.com//Snipaste_2024-02-03_15-50-08-1715613343038-9.jpg"></li></ul><h5 id="2-SpringBoot中接收简单参数"><a href="#2-SpringBoot中接收简单参数" class="headerlink" title="2.SpringBoot中接收简单参数"></a><strong>2.SpringBoot中接收简单参数</strong></h5><ul><li>请求参数名与方法形参变量名相同</li><li>会自动进行类型转换</li><li><img src="/.com//Snipaste_2024-02-03_15-53-03-1715613343038-10.jpg"></li></ul><h5 id="3-RequestParam注解"><a href="#3-RequestParam注解" class="headerlink" title="3.@RequestParam注解"></a>3.@RequestParam注解</h5><ul><li>方法形参名称与请求参数名称不匹配，通过该注解完成映射</li><li>该注解的required属性默认是true，代表请求参数必须传递，如果设置为false则代表可以不传递  会显示为null</li><li><img src="/.com//Snipaste_2024-02-03_15-58-26-1715613343038-11.jpg"></li></ul><h4 id="实体参数"><a href="#实体参数" class="headerlink" title="实体参数"></a>实体参数</h4><p><strong>实体对象参数：请求参数名与形参对象属性名相同，定义PoJo接收即可</strong></p><h5 id="1-简单实体参数"><a href="#1-简单实体参数" class="headerlink" title="1.简单实体参数"></a>1.简单实体参数</h5><ul><li>创建一个User的javabeen类 里面封装name、age</li></ul><p><img src="/.com//Snipaste_2024-02-03_16-17-41-1715613343038-12.jpg"></p><h5 id="2-复杂实体参数"><a href="#2-复杂实体参数" class="headerlink" title="2.复杂实体参数"></a>2.复杂实体参数</h5><ul><li>创建一个User的javabeen类 里面封装name、age、adress</li><li>adress为Adress类 里面封装province、city</li></ul><p><img src="/.com//Snipaste_2024-02-03_16-26-20-1715613343038-13.jpg"></p><p><img src="/.com//Snipaste_2024-02-03_16-26-34-1715613343038-14.jpg"></p><p><img src="/.com//Snipaste_2024-02-03_16-26-49-1715613343038-15.jpg"></p><p>postman参数为：</p><p><img src="/.com//Snipaste_2024-02-03_16-27-03-1715613343038-16.jpg"></p><h4 id="数组集合参数"><a href="#数组集合参数" class="headerlink" title="数组集合参数"></a>数组集合参数</h4><h5 id="1-数组参数"><a href="#1-数组参数" class="headerlink" title="1.数组参数"></a>1.数组参数</h5><p><strong>数组参数：请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数</strong></p><ul><li><p><img src="/.com//Snipaste_2024-02-04_15-22-59-1715613343038-17.jpg"></p></li><li><p><img src="/.com//Snipaste_2024-02-04_15-23-23-1715613343038-18.jpg"></p></li></ul><p>确保参数名与方法中的形参名一致</p><h5 id="2-集合参数"><a href="#2-集合参数" class="headerlink" title="2.集合参数"></a>2.集合参数</h5><p><strong>集合参数：请求参数名与形参集合名称相同且请求参数为多个，<code>@RequestParam</code>绑定参数关系</strong></p><ul><li><img src="/.com//Snipaste_2024-02-04_15-26-43-1715613343038-19.jpg"></li><li><img src="/.com//Snipaste_2024-02-04_15-26-57-1715613343038-20.jpg"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组参数：请求参数名与形参数组名称相同，可以直接使用数组封装</span><br><span class="line">集合参数：请求参数名与形参中结合变量名相同，通过@RequestParam绑定参数关系</span><br></pre></td></tr></table></figure><h4 id="日期参数"><a href="#日期参数" class="headerlink" title="日期参数"></a>日期参数</h4><p><strong>日期参数：使用<code>@DataTimeFormat</code>注解 完成日期参数格式转换</strong></p><ul><li><p><img src="/.com//Snipaste_2024-02-04_15-38-53-1715613343038-21.jpg"></p></li><li><p><img src="/.com//Snipaste_2024-02-04_15-38-46-1715613343038-22.jpg"></p></li></ul><h4 id="Json格式参数"><a href="#Json格式参数" class="headerlink" title="Json格式参数"></a>Json格式参数</h4><p><strong>json格式参数：json数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数，需要使用<code>@RequestBody</code>表示绑定</strong></p><ul><li><img src="/.com//Snipaste_2024-02-04_15-49-46-1715613343038-23.jpg"></li><li><img src="/.com//Snipaste_2024-02-04_15-50-06-1715613343038-24.jpg"></li></ul><h4 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h4><p><strong>路径参数：通过请求URL直接传递参数，使用{…}来标识该路径参数，需要使用<code>@PathVariable</code>获取参数路径</strong></p><ul><li><p><img src="/.com//Snipaste_2024-02-04_16-05-59-1715613343038-25.jpg"></p></li><li><p><img src="/.com//Snipaste_2024-02-04_16-06-19-1715613343038-26.jpg"></p></li></ul><p>多路径：</p><ul><li><img src="/.com//Snipaste_2024-02-04_16-07-04-1715613343038-27.jpg"></li><li><img src="/.com//Snipaste_2024-02-04_16-07-19-1715613343038-28.jpg"></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/.com//Snipaste_2024-02-04_16-08-28-1715613343038-29.jpg"></p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a><strong>@ResponseBody</strong></h4><p>类型：方法注解、类注解</p><p>位置：Controller类上&#x2F;方法上</p><p>作用：将方法返回值直接响应，若返回值类型是 实体对象&#x2F;集合 ，转JSON格式响应</p><p>说明：@RestController&#x3D;@Controller + @ResponseBody</p><h4 id="统一响应结果"><a href="#统一响应结果" class="headerlink" title="统一响应结果"></a><strong>统一响应结果</strong></h4><p>Result(code、msg、data)</p><p>如：</p><ul><li><p><img src="/.com//Snipaste_2024-02-04_16-41-24-1715613343038-30.jpg"></p><p><a href="http://localhost:8080/hello">http://localhost:8080/hello</a></p></li><li><p><img src="/.com//Snipaste_2024-02-04_16-41-29-1715613343038-31.jpg"></p><p><a href="http://localhost:8080/getAddr">http://localhost:8080/getAddr</a></p></li><li><p><img src="/.com//Snipaste_2024-02-04_16-41-40-1715613343038-32.jpg"></p></li></ul><p><a href="http://localhost:8080/listAddr">http://localhost:8080/listAddr</a></p><h4 id="案例：获取员工数据，并统一响应结果，在页面渲染"><a href="#案例：获取员工数据，并统一响应结果，在页面渲染" class="headerlink" title="案例：获取员工数据，并统一响应结果，在页面渲染"></a>案例：获取员工数据，并统一响应结果，在页面渲染</h4><p><img src="/.com//Snipaste_2024-02-04_17-16-30.jpg"></p><p><img src="/.com//Snipaste_2024-02-04_17-15-56.jpg"></p><h2 id="分层解耦"><a href="#分层解耦" class="headerlink" title="分层解耦"></a>分层解耦</h2><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在我们进行程序设计以及程序开发时，尽可能让每一个接口、类、方法的职责更单一些（单一职责原则）。</p><blockquote><p>单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。</p><p>这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。</p></blockquote><p>我们之前开发的程序呢，并不满足单一职责原则。下面我们来分析下之前的程序：</p><p><img src="/.com//image-20221204191650390.png" alt="image-20221204191650390"> </p><p>那其实我们上述案例的处理逻辑呢，从组成上看可以分为三个部分：</p><ul><li>数据访问：负责业务数据的维护操作，包括增、删、改、查等操作。</li><li>逻辑处理：负责业务逻辑处理的代码。</li><li>请求处理、响应数据：负责，接收页面的请求，给页面响应数据。</li></ul><p>按照上述的三个组成部分，在我们项目开发中呢，可以将代码分为三层：</p><p><img src="/.com//image-20221204193837678-1715613343038-36.png" alt="image-20221204193837678"></p><ul><li>Controller：控制层。接收前端发送的请求，对请求进行处理，并响应数据。</li><li>Service：业务逻辑层。处理具体的业务逻辑。</li><li>Dao：数据访问层(Data Access Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。</li></ul><p>基于三层架构的程序执行流程：</p><p><img src="/.com//image-20221204194207812-1715613343038-37.png" alt="image-20221204194207812"></p><ul><li>前端发起的请求，由Controller层接收（Controller响应数据给前端）</li><li>Controller层调用Service层来进行逻辑处理（Service层处理完后，把处理结果返回给Controller层）</li><li>Serivce层调用Dao层（逻辑处理过程中需要用到的一些数据要从Dao层获取）</li><li>Dao层操作文件中的数据（Dao拿到的数据会返回给Service层）</li></ul><blockquote><p>思考：按照三层架构的思想，如何要对业务逻辑(Service层)进行变更，会影响到Controller层和Dao层吗？ </p><p>答案：不会影响。 （程序的扩展性、维护性变得更好了）</p></blockquote><h4 id="代码拆分"><a href="#代码拆分" class="headerlink" title="代码拆分"></a>代码拆分</h4><p>我们使用三层架构思想，来改造下之前的程序：</p><ul><li>控制层包名：xxxx.controller</li><li>业务逻辑层包名：xxxx.service</li><li>数据访问层包名：xxxx.dao</li></ul><p><img src="/.com//image-20221204195812200-1715613343038-38.png" alt="image-20221204195812200"></p><p><strong>控制层：</strong>接收前端发送的请求，对请求进行处理，并响应数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpController</span> &#123;</span><br><span class="line">    <span class="comment">//业务层对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">EmpService</span> <span class="variable">empService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpServiceA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listEmp&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 调用service层, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empService.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(empList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>业务逻辑层：</strong>处理具体的业务逻辑</p><ul><li>业务接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务逻辑接口（制定业务标准）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line">    <span class="comment">//获取员工列表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务逻辑实现类（按照业务标准实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpServiceA</span> <span class="keyword">implements</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line">    <span class="comment">//dao层对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">EmpDao</span> <span class="variable">empDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpDaoA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 调用dao, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empDao.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 对数据进行转换处理 - gender, job</span></span><br><span class="line">        empList.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="comment">//处理 gender 1: 男, 2: 女</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> emp.getGender();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理job - 1: 讲师, 2: 班主任 , 3: 就业指导</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">job</span> <span class="operator">=</span> emp.getJob();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;讲师&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;班主任&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;3&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;就业指导&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据访问层：</strong>负责数据的访问操作，包含数据的增、删、改、查</p><ul><li>数据访问接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据访问层接口（制定标准）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="comment">//获取员工列表数据</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据访问实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据访问实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpDaoA</span> <span class="keyword">implements</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 加载并解析emp.xml</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emp.xml&quot;</span>).getFile();</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221204201342490.png" alt="image-20221204201342490"></p><p>三层架构的好处：</p><ol><li>复用性强</li><li>便于维护</li><li>利用扩展</li></ol><h3 id="分层解耦-1"><a href="#分层解耦-1" class="headerlink" title="分层解耦"></a>分层解耦</h3><p>刚才我们学习过程序分层思想了，接下来呢，我们来学习下程序的解耦思想。</p><p>解耦：解除耦合。</p><h4 id="耦合问题"><a href="#耦合问题" class="headerlink" title="耦合问题"></a>耦合问题</h4><p>首先需要了解软件开发涉及到的两个概念：内聚和耦合。</p><ul><li><p>内聚：软件中各个功能模块内部的功能联系。</p></li><li><p>耦合：衡量软件中各个层&#x2F;模块之间的依赖、关联的程度。</p></li></ul><p><strong>软件设计原则：高内聚低耦合。</strong></p><blockquote><p>高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 “高内聚”。</p><p>低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。</p></blockquote><p>程序中高内聚的体现：</p><ul><li>EmpServiceA类中只编写了和员工相关的逻辑处理代码</li></ul><p><img src="/.com//image-20221204202531571-1715613343038-40.png" alt="image-20221204202531571"> </p><p>程序中耦合代码的体现：</p><ul><li>把业务类变为EmpServiceB时，需要修改controller层中的代码</li></ul><p><img src="/.com//image-20221204203904900.png" alt="image-20221204203904900"></p><p>高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强。</p><p><img src="/.com//image-20220828215549593-1715613343038-42.png"></p><h4 id="解耦思路"><a href="#解耦思路" class="headerlink" title="解耦思路"></a>解耦思路</h4><p>之前我们在编写代码时，需要什么对象，就直接new一个就可以了。 这种做法呢，层与层之间代码就耦合了，当service层的实现变了之后， 我们还需要修改controller层的代码。</p><p><img src="/.com//image-20221204204916033.png" alt="image-20221204204916033"></p><p> 那应该怎么解耦呢？</p><ul><li>首先不能在EmpController中使用new对象。代码如下：</li></ul><p><img src="/.com//image-20221204205328069-1715613343038-44.png" alt="image-20221204205328069"></p><ul><li>此时，就存在另一个问题了，不能new，就意味着没有业务层对象（程序运行就报错），怎么办呢？<ul><li>我们的解决思路是：<ul><li>提供一个容器，容器中存储一些对象(例：EmpService对象)</li><li>controller程序从容器中获取EmpService类型的对象</li></ul></li></ul></li></ul><p>我们想要实现上述解耦操作，就涉及到Spring中的两个核心概念：</p><ul><li><p><strong>控制反转：</strong> Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。</p><blockquote><p>对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器</p></blockquote></li><li><p><strong>依赖注入：</strong> Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。</p><blockquote><p>程序运行时需要某个资源，此时容器就为其提供这个资源。</p><p>例：EmpController程序运行时需要EmpService对象，Spring容器就为其提供并注入EmpService对象</p></blockquote></li></ul><p>IOC容器中创建、管理的对象，称之为：bean对象</p><h3 id="IOC-DI"><a href="#IOC-DI" class="headerlink" title="IOC&amp;DI"></a>IOC&amp;DI</h3><p>上面我们引出了Spring中IOC和DI的基本概念，下面我们就来具体学习下IOC和DI的代码实现。</p><h4 id="IOC-DI入门"><a href="#IOC-DI入门" class="headerlink" title="IOC&amp;DI入门"></a>IOC&amp;DI入门</h4><p>任务：完成Controller层、Service层、Dao层的代码解耦</p><ul><li>思路：<ol><li>删除Controller层、Service层中new对象的代码</li><li>Service层及Dao层的实现类，交给IOC容器管理</li><li>为Controller及Service注入运行时依赖的对象<ul><li>Controller程序中注入依赖的Service层对象</li><li>Service程序中注入依赖的Dao层对象</li></ul></li></ol></li></ul><p>第1步：删除Controller层、Service层中new对象的代码</p><p><img src="/.com//image-20221204212807207-1715613343038-45.png" alt="image-20221204212807207"></p><p>第2步：Service层及Dao层的实现类，交给IOC容器管理</p><ul><li>使用Spring提供的注解：@Component ，就可以实现类交给IOC容器管理</li></ul><p><img src="/.com//image-20221204213328034-1715613343038-46.png" alt="image-20221204213328034"></p><p>第3步：为Controller及Service注入运行时依赖的对象</p><ul><li>使用Spring提供的注解：@Autowired ，就可以实现程序运行时IOC容器自动注入需要的依赖对象</li></ul><p><img src="/.com//image-20221204213859112-1715613343038-47.png" alt="image-20221204213859112"></p><p>完整的三层代码：</p><ul><li><strong>Controller层：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> EmpService empService ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listEmp&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 调用service, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empService.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(empList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Service层：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//将当前对象交给IOC容器管理,成为IOC容器的bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpServiceA</span> <span class="keyword">implements</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> EmpDao empDao ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 调用dao, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empDao.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 对数据进行转换处理 - gender, job</span></span><br><span class="line">        empList.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="comment">//处理 gender 1: 男, 2: 女</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> emp.getGender();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理job - 1: 讲师, 2: 班主任 , 3: 就业指导</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">job</span> <span class="operator">=</span> emp.getJob();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;讲师&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;班主任&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;3&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;就业指导&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Dao层：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//将当前对象交给IOC容器管理,成为IOC容器的bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpDaoA</span> <span class="keyword">implements</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 加载并解析emp.xml</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emp.xml&quot;</span>).getFile();</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试：</p><ul><li>启动SpringBoot引导类，打开浏览器，输入：<a href="http://localhost:8080/emp.html">http://localhost:8080/emp.html</a></li></ul><p><img src="/.com//image-20221204185455556-1715613343038-48.png" alt="image-20221204185455556"></p><h4 id="IOC详解"><a href="#IOC详解" class="headerlink" title="IOC详解"></a>IOC详解</h4><p>通过IOC和DI的入门程序呢，我们已经基本了解了IOC和DI的基础操作。接下来呢，我们学习下IOC控制反转和DI依赖注入的细节。</p><h5 id="bean的声明"><a href="#bean的声明" class="headerlink" title="bean的声明"></a>bean的声明</h5><p>前面我们提到IOC控制反转，就是将对象的控制权交给Spring的IOC容器，由IOC容器创建及管理对象。IOC容器创建的对象称为bean对象。</p><p>在之前的入门案例中，要把某个对象交给IOC容器管理，需要在类上添加一个注解：@Component </p><p>而Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属于哪一层，又提供了@Component的衍生注解：</p><ul><li>@Controller    （标注在控制层类上）</li><li>@Service          （标注在业务层类上）</li><li>@Repository    （标注在数据访问层类上）</li></ul><p>修改入门案例代码：</p><ul><li><strong>Controller层：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>  <span class="comment">//@RestController = @Controller + @ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> EmpService empService ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listEmp&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 调用service, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empService.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(empList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Service层：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpServiceA</span> <span class="keyword">implements</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> EmpDao empDao ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 调用dao, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empDao.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 对数据进行转换处理 - gender, job</span></span><br><span class="line">        empList.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="comment">//处理 gender 1: 男, 2: 女</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> emp.getGender();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理job - 1: 讲师, 2: 班主任 , 3: 就业指导</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">job</span> <span class="operator">=</span> emp.getJob();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;讲师&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;班主任&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;3&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;就业指导&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Dao层：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpDaoA</span> <span class="keyword">implements</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 加载并解析emp.xml</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emp.xml&quot;</span>).getFile();</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一：</p><table><thead><tr><th align="left">注解</th><th>说明</th><th>位置</th></tr></thead><tbody><tr><td align="left">@Controller</td><td>@Component的衍生注解</td><td>标注在控制器类上</td></tr><tr><td align="left">@Service</td><td>@Component的衍生注解</td><td>标注在业务类上</td></tr><tr><td align="left">@Repository</td><td>@Component的衍生注解</td><td>标注在数据访问类上（由于与mybatis整合，用的少）</td></tr><tr><td align="left">@Component</td><td>声明bean的基础注解</td><td>不属于以上三类时，用此注解</td></tr></tbody></table><blockquote><p>查看源码：<img src="/.com//image-20221204221320230-1715613343038-49.png" alt="image-20221204221320230"></p></blockquote><p>在IOC容器中，每一个Bean都有一个属于自己的名字，可以通过注解的value属性指定bean的名字。如果没有指定，默认为类名首字母小写。</p><p><img src="/.com//image-20221204222650873-1715613343038-50.png" alt="image-20221204222650873"></p><blockquote><p>注意事项: </p><ul><li>声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写。</li><li>使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。</li></ul></blockquote><h5 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h5><p>问题：使用前面学习的四个注解声明的bean，一定会生效吗？</p><p>答案：不一定。（原因：bean想要生效，还需要被组件扫描）</p><p> 下面我们通过修改项目工程的目录结构，来测试bean对象是否生效：</p><p><img src="/.com//image-20221204223602694-1715613343038-51.png" alt="image-20221204223602694"></p><p>运行程序后，报错：</p><p><img src="/.com//image-20221204223815554-1715613343038-52.png" alt="image-20221204223815554"></p><p>为什么没有找到bean对象呢？</p><ul><li>使用四大注解声明的bean，要想生效，还需要被组件扫描注解@ComponentScan扫描</li></ul><blockquote><p>@ComponentScan注解虽然没有显式配置，但是实际上已经包含在了引导类声明注解 @SpringBootApplication 中，&#x3D;&#x3D;<strong>默认扫描的范围是SpringBoot启动类所在包及其子包</strong>&#x3D;&#x3D;。</p><p><img src="/.com//image-20221204224643683-1715613343038-53.png" alt="image-20221204224643683"> </p></blockquote><ul><li>解决方案：手动添加@ComponentScan注解，指定要扫描的包   （&#x3D;&#x3D;仅做了解，不推荐&#x3D;&#x3D;）</li></ul><p><img src="/.com//image-20221204225437297-1715613343038-54.png" alt="image-20221204225437297"></p><p>推荐做法（如下图）：</p><ul><li>将我们定义的controller，service，dao这些包呢，都放在引导类所在包com.itheima的子包下，这样我们定义的bean就会被自动的扫描到</li></ul><p><img src="/.com//image-20221204225815624-1715613343038-55.png" alt="image-20221204225815624"></p><h4 id="DI详解"><a href="#DI详解" class="headerlink" title="DI详解"></a>DI详解</h4><p>上一小节我们讲解了控制反转IOC的细节，接下来呢，我们学习依赖注解DI的细节。</p><p>依赖注入，是指IOC容器要为应用程序去提供运行时所依赖的资源，而资源指的就是对象。</p><p>在入门程序案例中，我们使用了@Autowired这个注解，完成了依赖注入的操作，而这个Autowired翻译过来叫：自动装配。</p><p>@Autowired注解，默认是按照<strong>类型</strong>进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）</p><blockquote><p>入门程序举例：在EmpController运行的时候，就要到IOC容器当中去查找EmpService这个类型的对象，而我们的IOC容器中刚好有一个EmpService这个类型的对象，所以就找到了这个类型的对象完成注入操作。</p></blockquote><p>那如果在IOC容器中，存在多个相同类型的bean对象，会出现什么情况呢？</p><p><img src="/.com//image-20221204232154445-1715613343038-56.png" alt="image-20221204232154445"></p><ul><li>程序运行会报错</li></ul><p><img src="/.com//image-20221204231616724-1715613343038-57.png" alt="image-20221204231616724"></p><p>如何解决上述问题呢？Spring提供了以下几种解决方案：</p><ul><li><p>@Primary</p></li><li><p>@Qualifier</p></li><li><p>@Resource</p></li></ul><p>使用@Primary注解：当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。</p><p><img src="/.com//image-20221204232501679-1715613343038-58.png" alt="image-20221204232501679"> </p><p>使用@Qualifier注解：指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。</p><ul><li>@Qualifier注解不能单独使用，必须配合@Autowired使用</li></ul><p><img src="/.com//image-20221204233333606-1715613343039-59.png" alt="image-20221204233333606"></p><p>使用@Resource注解：是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。</p><p><img src="/.com//image-20221204233637735-1715613343039-60.png" alt="image-20221204233637735"></p><blockquote><p>面试题 ： @Autowird 与 @Resource的区别</p><ul><li>@Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解</li><li>@Autowired 默认是按照类型注入，而@Resource是按照名称注入</li></ul></blockquote><h1 id="数据库开发-MySQL"><a href="#数据库开发-MySQL" class="headerlink" title="数据库开发-MySQL"></a>数据库开发-MySQL</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们讲解SpringBootWeb基础知识(请求响应案例)的时候，我们讲到在web开发中，为了应用程序职责单一，方便维护，我们一般将web应用程序分为三层，即：Controller、Service、Dao 。</p><p>之前我们的案例中，是这样子的请求流程：浏览器发起请求，先请求Controller；Controller接收到请求之后，调用Service进行业务逻辑处理；Service再调用Dao，Dao再解析user.xml中所存储的数据。</p><p><img src="/.com//image-20221205001241294-1715613343039-61.png" alt="image-20221205001241294"></p><p>xml文件中可以存储数据，但是在企业项目开发中不会使用xml文件存储数据，因为不便管理维护，操作难度大。 在真实的企业开发中呢，都会采用数据库来存储和管理数据，那此时，web开发调用流程图如下所示：</p><p><img src="/.com//image-20221205001346266-1715613343039-62.png" alt="image-20221205001346266"></p><p>首先来了解一下什么是数据库。</p><ul><li>数据库：英文为 DataBase，简称DB，它是存储和管理数据的仓库。</li></ul><p>像我们日常访问的电商网站京东，企业内部的管理系统OA、ERP、CRM这类的系统，以及大家每天都会刷的头条、抖音类的app，那这些大家所看到的数据，其实都是存储在数据库中的。最终这些数据，只是在浏览器或app中展示出来而已，最终数据的存储和管理都是数据库负责的。</p><p><img src="/.com//image-20221205001501275.png" alt="image-20221205001501275"></p><p>数据是存储在数据库中的，那我们要如何来操作数据库以及数据库中所存放的数据呢？</p><p>那这里呢，会涉及到一个软件：数据库管理系统（<strong>D</strong>ata<strong>B</strong>ase <strong>M</strong>anagement <strong>S</strong>ystem，简称DBMS）</p><ul><li>DBMS是操作和管理数据库的大型软件。将来我们只需要操作这个软件，就可以通过这个软件来操纵和管理数据库了。</li></ul><p>此时又出现一个问题：DBMS这个软件怎么知道要操作的是哪个数据库、哪个数据呢？是对数据做修改还是查询呢？</p><ul><li>需要给DBMS软件发送一条指令，告诉这个软件我们要执行的是什么样的操作，要对哪个数据进行操作。而这个指令就是SQL语句</li></ul><p>SQL（<strong>S</strong>tructured <strong>Q</strong>uery <strong>L</strong>anguage，简称SQL）：结构化查询语言，它是操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准。我们学习数据库开发，最为重要的就是学习SQL语句 。</p><blockquote><p>关系型数据库：我们后面会详细讲解，现在大家只需要知道我们学习的数据库属于关系型数据库即可。</p></blockquote><p><img src="/.com//image-20221205095039939-1715613343039-64.png" alt="image-20221205095039939"></p><p>结论：程序员给数据库管理系统(DBMS)发送SQL语句，再由数据库管理系统操作数据库当中的数据。</p><p>了解了数据库的一些简单概念之后，接下来我们再来介绍下目前主流的数据库，这里截取了排名前十的数据库：</p><p><img src="/.com//image-20221205120408757-1715613343039-65.png" alt="image-20221205120408757"> </p><ul><li>Oracle：大型的收费数据库，Oracle公司产品，价格昂贵。（通常是不差钱的公司会选择使用这个数据库）</li><li>MySQL：开源免费的中小型数据库，后来Sun公司收购了MySQL，而Oracle又收购了Sun公司。目前Oracle推出两个版本的Mysql：社区版(开源免费)、商业版(收费)。</li><li>SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。</li><li>PostgreSQL：开源免费的中小型数据库。</li><li>DB2：IBM公司的大型收费数据库产品。</li><li>SQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。</li><li>MariaDB：开源免费的中小型数据库。是MySQL数据库的另外一个分支、另外一个衍生产品，与MySQL数据库有很好的兼容性。</li></ul><p>那这么多数据库，我们全部都需要学习吗，其实并不用，我们只需要学习其中的一个就可以了，我们此次课程中学习的数据库是现在互联网公司开发使用最为流行的MySQL数据库。</p><p>此时大家可能会有一个疑问，我们现在学习的是Mysql数据库，我们以后去公司做开发，如果用到的是Oracle数据库或SQL Server数据库该怎么办？其实大家完全不用担心这个问题，因为这些数据库都是属于关系型数据库，要操作关系型数据库都是通过 SQL语句来实现的，而SQL语句又是操作关系型数据库的统一标准。</p><blockquote><p>结论：只要我们学会了SQL语句，就可以通过SQL语句来操作Mysql，也可以通过SQL语句来操作Oracle或SQL Server</p></blockquote><p>课程内容安排：</p><p><img src="/.com//image-20221205122731402-1715613343039-66.png" alt="image-20221205122731402"></p><p>以上课程内容拆解为3部分知识点：</p><p><img src="/.com//image-20221205122937131-1715613343039-67.png" alt="image-20221205122937131"></p><p>接下来我们就先进入到第一天的Mysql概述学习。</p><h2 id="1-MySQL概述"><a href="#1-MySQL概述" class="headerlink" title="1. MySQL概述"></a>1. MySQL概述</h2><h3 id="1-1-数据模型"><a href="#1-1-数据模型" class="headerlink" title="1.1 数据模型"></a>1.1 数据模型</h3><p>介绍完了Mysql数据库的安装配置之后，接下来我们再来聊一聊Mysql当中的数据模型。学完了这一小节之后，我们就能够知道在Mysql数据库当中到底是如何来存储和管理数据的。</p><p>在介绍 Mysql的数据模型之前，需要先了解一个概念：关系型数据库。</p><p><strong>关系型数据库（RDBMS）</strong></p><p>概念：建立在关系模型基础上，由多张相互连接的<strong>二维表</strong>组成的数据库。</p><p>而所谓二维表，指的是由行和列组成的表，如下图：</p><p><img src="/.com//image-20221205145028667-1715613343039-68.png" alt="image-20221205145028667"> </p><p>二维表的优点：</p><ul><li><p>使用表存储数据，格式统一，便于维护</p></li><li><p>使用SQL语言操作，标准统一，使用方便，可用于复杂查询</p></li></ul><blockquote><p>我们之前提到的MySQL、Oracle、DB2、SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。</p><p>结论：基于二维表存储数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库（比如大家后面要学习的Redis，就属于非关系型数据库）。</p></blockquote><p><strong>2). 数据模型</strong></p><p>介绍完了关系型数据库之后，接下来我们再来看一看在Mysql数据库当中到底是如何来存储数据的，也就是Mysql 的数据模型。</p><p>MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构图下:</p><p><img src="/.com//image-20220829111741419-1715613343039-69.png" alt="image-20220829111741419"> </p><ul><li>通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库</li><li>使用MySQL客户端，向数据库管理系统发送一条SQL语句，由数据库管理系统根据SQL语句指令去操作数据库中的表结构及数据</li><li>一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录。</li></ul><blockquote><p>在Mysql数据库服务器当中存储数据，你需要：</p><ol><li>先去创建数据库（可以创建多个数据库，之间是相互独立的）</li><li>在数据库下再去创建数据表（一个数据库下可以创建多张表）</li><li>再将数据存放在数据表中（一张表可以存储多行数据）</li></ol></blockquote><h3 id="1-2-SQL简介"><a href="#1-2-SQL简介" class="headerlink" title="1.2 SQL简介"></a>1.2 SQL简介</h3><p>SQL：结构化查询语言。一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。</p><p>在学习具体的SQL语句之前，先来了解一下SQL语言的语法。</p><h4 id="1-2-1-SQL通用语法"><a href="#1-2-1-SQL通用语法" class="headerlink" title="1.2.1 SQL通用语法"></a>1.2.1 SQL通用语法</h4><p>1、SQL语句可以单行或多行书写，以分号结尾。</p><p><img src="/.com//image-20221205151656214-1715613343039-70.png" alt="image-20221205151656214"></p><p>2、SQL语句可以使用空格&#x2F;缩进来增强语句的可读性。</p><p><img src="/.com//image-20221205151953441-1715613343039-71.png" alt="image-20221205151953441"></p><p>3、MySQL数据库的SQL语句不区分大小写。</p><p><img src="/.com//image-20221205152112070-1715613343039-72.png" alt="image-20221205152112070"></p><p>4、注释：</p><ul><li>单行注释：– 注释内容   或   # 注释内容(MySQL特有)</li><li>多行注释： &#x2F;* 注释内容 *&#x2F;</li></ul><blockquote><p>以上就是SQL语句的通用语法，这些通用语法大家目前先有一个直观的认识，我们后面在讲解每一类SQL语句的时候，还会再来强调通用语法。</p></blockquote><h4 id="1-2-2-分类"><a href="#1-2-2-分类" class="headerlink" title="1.2.2 分类"></a>1.2.2 分类</h4><p>SQL语句根据其功能被分为四大类：DDL、DML、DQL、DCL </p><table><thead><tr><th><strong>分类</strong></th><th><strong>全称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition  Language</td><td>数据定义语言，用来定义数据库对象(数据库，表，字段)</td></tr><tr><td>DML</td><td>Data Manipulation  Language</td><td>数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control  Language</td><td>数据控制语言，用来创建数据库用户、控制数据库的访问权限</td></tr></tbody></table><p><img src="/.com//image-20221205152804250-1715613343039-73.png" alt="image-20221205152804250">  </p><h2 id="2-数据库设计-DDL"><a href="#2-数据库设计-DDL" class="headerlink" title="2. 数据库设计-DDL"></a>2. 数据库设计-DDL</h2><p>下面我们就正式的进入到SQL语句的学习，在学习之前先给大家介绍一下我们要开发一个项目，整个开发流程是什么样的，以及在流程当中哪些环节会涉及到数据库。</p><h3 id="2-1-项目开发流程"><a href="#2-1-项目开发流程" class="headerlink" title="2.1 项目开发流程"></a>2.1 项目开发流程</h3><p><img src="/.com//image-20220829112953742.png" alt="image-20220829112953742"></p><p>需求文档：</p><ul><li>在我们开发一个项目或者项目当中的某个模块之前，会先会拿到产品经理给我们提供的页面原型及需求文档。</li></ul><p><img src="/.com//image-20221205154101142.png" alt="image-20221205154101142"></p><p>设计：</p><ul><li>拿到产品原型和需求文档之后，我们首先要做的不是编码，而是要先进行项目的设计，其中就包括概要设计、详细设计、接口设计、数据库设计等等。</li><li>数据库设计根据产品原型以及需求文档，要分析各个模块涉及到的表结构以及表结构之间的关系，以及表结构的详细信息。最终我们需要将数据库以及数据库当中的表结构设计创建出来。</li></ul><p>开发&#x2F;测试：</p><ul><li>参照页面原型和需求进行编码，实现业务功能。在这个过程当中，我们就需要来操作设计出来的数据库表结构，来完成业务的增删改查操作等。</li></ul><p>部署上线：</p><ul><li>在项目的功能开发测试完成之后，项目就可以上线运行了，后期如果项目遇到性能瓶颈，还需要对项目进行优化。优化很重要的一个部分就是数据库的优化，包括数据库当中索引的建立、SQL 的优化、分库分表等操作。</li></ul><p>在上述的流程当中，针对于数据库来说，主要包括三个阶段：</p><ol><li>数据库设计阶段<ul><li>参照页面原型以及需求文档设计数据库表结构</li></ul></li><li>数据库操作阶段<ul><li>根据业务功能的实现，编写SQL语句对数据表中的数据进行增删改查操作</li></ul></li><li>数据库优化阶段<ul><li>通过数据库的优化来提高数据库的访问性能。优化手段：索引、SQL优化、分库分表等</li></ul></li></ol><p>接下来我们就先来学习第一部分数据库的设计，而数据库的设计就是来定义数据库，定义表结构以及表中的字段。</p><h3 id="2-2-数据库操作"><a href="#2-2-数据库操作" class="headerlink" title="2.2 数据库操作"></a>2.2 数据库操作</h3><p>我们在进行数据库设计，需要使用到刚才所介绍SQL分类中的DDL语句。</p><p>DDL英文全称是Data Definition Language(数据定义语言)，用来定义数据库对象(数据库、表)。</p><p>DDL中数据库的常见操作：查询、创建、使用、删除。</p><h4 id="2-2-1-查询数据库"><a href="#2-2-1-查询数据库" class="headerlink" title="2.2.1 查询数据库"></a>2.2.1 查询数据库</h4><p><strong>查询所有数据库：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p>命令行中执行效果如下：</p><p><img src="/.com//image-20220829124104154-1715613343039-76.png" alt="image-20220829124104154"> </p><p><strong>查询当前数据库：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure><p>命令行中执行效果如果：</p><p><img src="/.com//image-20221205174615074-1715613343039-77.png" alt="image-20221205174615074"></p><blockquote><p>我们要操作某一个数据库，必须要切换到对应的数据库中。 </p><p>通过指令：select  database() ，就可以查询到当前所处的数据库 </p></blockquote><h4 id="2-2-2-创建数据库"><a href="#2-2-2-创建数据库" class="headerlink" title="2.2.2 创建数据库"></a>2.2.2 创建数据库</h4><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database [ if not exists ] 数据库名;</span><br></pre></td></tr></table></figure><p>案例： 创建一个itcast数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database itcast;</span><br></pre></td></tr></table></figure><p>命令行执行效果如下：</p><p><img src="/.com//image-20220829124219427-1715613343039-78.png" alt="image-20220829124219427"> </p><p>&#x3D;&#x3D;注意：在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。&#x3D;&#x3D;</p><p><img src="/.com//image-20220829124250514-1715613343039-79.png" alt="image-20220829124250514"></p><ul><li>可以使用if not exists来避免这个问题</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据库不存在,则创建该数据库；如果存在则不创建</span></span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> extists itcast; </span><br></pre></td></tr></table></figure><p> 命令行执行效果如下： <img src="/.com//image-20220829124326741-1715613343039-80.png" alt="image-20220829124326741"> </p><h4 id="2-2-3-使用数据库"><a href="#2-2-3-使用数据库" class="headerlink" title="2.2.3 使用数据库"></a>2.2.3 使用数据库</h4><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名 ;</span><br></pre></td></tr></table></figure><blockquote><p>我们要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则不能操作。</p></blockquote><p>案例：切换到itcast数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use itcast;</span><br></pre></td></tr></table></figure><p>命令执行效果如下：</p><p><img src="/.com//image-20220829124929708-1715613343039-81.png" alt="image-20220829124929708"> </p><h4 id="2-2-4-删除数据库"><a href="#2-2-4-删除数据库" class="headerlink" title="2.2.4 删除数据库"></a>2.2.4 删除数据库</h4><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database [ if exists ] 数据库名 ;</span><br></pre></td></tr></table></figure><blockquote><p>如果删除一个不存在的数据库，将会报错。</p><p>可以加上参数 if exists ，如果数据库存在，再执行删除，否则不执行删除。</p></blockquote><p>案例：删除itcast数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database if exists itcast; -- itcast数据库存在时删除</span><br></pre></td></tr></table></figure><p>命令执行效果如下：</p><p><img src="/.com//image-20220829125006142-1715613343039-82.png" alt="image-20220829125006142"> </p><blockquote><p>说明：上述语法中的database，也可以替换成 schema</p><ul><li>如：create schema db01;</li><li>如：show schemas;</li></ul><p><img src="/.com//image-20221205180608004-1715613343039-83.png" alt="image-20221205180608004"></p></blockquote><h3 id="2-3-图形化工具"><a href="#2-3-图形化工具" class="headerlink" title="2.3 图形化工具"></a>2.3 图形化工具</h3><h4 id="2-3-1-介绍"><a href="#2-3-1-介绍" class="headerlink" title="2.3.1 介绍"></a>2.3.1 介绍</h4><p>前面我们讲解了DDL中关于数据库操作的SQL语句，在我们编写这些SQL时，都是在命令行当中完成的。大家在练习的时候应该也感受到了，在命令行当中来敲这些SQL语句很不方便，主要的原因有以下 3 点：</p><ol><li>没有任何代码提示。（全靠记忆，容易敲错字母造成执行报错）</li><li>操作繁琐，影响开发效率。（所有的功能操作都是通过SQL语句来完成的）</li><li>编写过的SQL代码无法保存。</li></ol><p>在项目开发当中，通常为了提高开发效率，都会借助于现成的图形化管理工具来操作数据库。</p><p>目前MySQL主流的图形化界面工具有以下几种：</p><p><img src="/.com//image-20221205184802646-1715613343039-84.png" alt="image-20221205184802646"></p><p>DataGrip是JetBrains旗下的一款数据库管理工具，是管理和开发MySQL、Oracle、PostgreSQL的理想解决方案。</p><p>官网： <a href="https://www.jetbrains.com/zh-cn/datagrip/">https://www.jetbrains.com/zh-cn/datagrip/</a></p><h4 id="2-3-2-安装"><a href="#2-3-2-安装" class="headerlink" title="2.3.2 安装"></a>2.3.2 安装</h4><p>安装： 参考资料中提供的《DataGrip安装手册》</p><blockquote><p>说明：DataGrip这款工具可以不用安装，因为Jetbrains公司已经将DataGrip这款工具的功能已经集成到了 IDEA当中，所以我们就可以使用IDEA来作为一款图形化界面工具来操作Mysql数据库。</p></blockquote><h4 id="2-3-3-使用"><a href="#2-3-3-使用" class="headerlink" title="2.3.3 使用"></a>2.3.3 使用</h4><h5 id="2-2-3-1-连接数据库"><a href="#2-2-3-1-连接数据库" class="headerlink" title="2.2.3.1 连接数据库"></a>2.2.3.1 连接数据库</h5><p>1、打开IDEA自带的Database</p><p><img src="/.com//image-20221205190929756-1715613343039-85.png" alt="image-20221205190929756"></p><p>2、配置MySQL</p><p><img src="/.com//image-20221205191143072-1715613343039-86.png" alt="image-20221205191143072"></p><p>3、输入相关信息</p><p><img src="/.com//image-20221205192606038-1715613343039-87.png" alt="image-20221205192606038"> </p><p>4、下载MySQL连接驱动</p><p><img src="/.com//image-20221205192847190-1715613343039-88.png" alt="image-20221205192847190"></p><p>5、测试数据库连接</p><p><img src="/.com//image-20221205193304124-1715613343039-89.png" alt="image-20221205193304124"></p><p>6、保存配置</p><p><img src="/.com//image-20221205193409856-1715613343039-90.png" alt="image-20221205193409856"></p><p>默认情况下，连接上了MySQL数据库之后， 数据库并没有全部展示出来。 需要选择要展示哪些数据库。具体操作如下：</p><p><img src="/.com//8.gif"></p><h5 id="2-2-3-2-操作数据库"><a href="#2-2-3-2-操作数据库" class="headerlink" title="2.2.3.2 操作数据库"></a>2.2.3.2 操作数据库</h5><p><strong>创建数据库：</strong></p><p><img src="/.com//image-20221205195346655-1715613343039-92.png" alt="image-20221205195346655"></p><p><img src="/.com//image-20221205195510716-1715613343039-93.png" alt="image-20221205195510716"></p><blockquote><p>有了图形化界面工具后，就可以方便的使用图形化工具：创建数据库，创建表、修改表等DDL操作。</p><p>其实工具底层也是通过DDL语句操作的数据库，只不过这些SQL语句是图形化界面工具帮我们自动完成的。</p></blockquote><p><strong>查看所有数据库：</strong></p><p><img src="/.com//image-20221205195128343-1715613343039-95.png" alt="image-20221205195128343"></p><p><img src="/.com//image-20221205195833439-1715613343039-94.png" alt="image-20221205195833439"></p><h3 id="2-3-表操作"><a href="#2-3-表操作" class="headerlink" title="2.3 表操作"></a>2.3 表操作</h3><p>学习完了DDL语句当中关于数据库的操作之后，接下来我们继续学习DDL语句当中关于表结构的操作。</p><p>关于表结构的操作也是包含四个部分：创建表、查询表、修改表、删除表。</p><h4 id="2-3-1-创建"><a href="#2-3-1-创建" class="headerlink" title="2.3.1 创建"></a>2.3.1 创建</h4><h5 id="2-3-1-1-语法"><a href="#2-3-1-1-语法" class="headerlink" title="2.3.1.1 语法"></a>2.3.1.1 语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table  表名(</span><br><span class="line">字段1  字段1类型 [约束]  [comment  字段1注释 ],</span><br><span class="line">字段2  字段2类型 [约束]  [comment  字段2注释 ],</span><br><span class="line">......</span><br><span class="line">字段n  字段n类型 [约束]  [comment  字段n注释 ] </span><br><span class="line">) [ comment  表注释 ] ;</span><br></pre></td></tr></table></figure><blockquote><p>注意： [ ] 中的内容为可选参数； 最后一个字段后面没有逗号</p></blockquote><p>案例：创建tb_user表</p><ul><li>对应的结构如下：</li></ul><p><img src="/.com//image-20220829143005524-1715613343039-96.png" alt="image-20220829143005524">  </p><ul><li>建表语句：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table tb_user (</span><br><span class="line">    id int comment &#x27;ID,唯一标识&#x27;,   # id是一行数据的唯一标识（不能重复）</span><br><span class="line">    username varchar(20) comment &#x27;用户名&#x27;,</span><br><span class="line">    name varchar(10) comment &#x27;姓名&#x27;,</span><br><span class="line">    age int comment &#x27;年龄&#x27;,</span><br><span class="line">    gender char(1) comment &#x27;性别&#x27;</span><br><span class="line">) comment &#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>数据表创建完成，接下来我们还需要测试一下是否可以往这张表结构当中来存储数据。</p></blockquote><p>双击打开tb_user表结构，大家会发现里面没有数据：</p><p><img src="/.com//image-20221205211008929-1715613343039-97.png" alt="image-20221205211008929"></p><p>添加数据：</p><p><img src="/.com//9-1715613343039-98.gif"> </p><p>此时我们再插入一条数据：</p><p><img src="/.com//image-20221205214447060-1715613343039-99.png" alt="image-20221205214447060"> </p><p>我们之前提到过：id字段是一行数据的唯一标识，不能有重复值。但是现在数据表中有两个相同的id值，这是为什么呢？</p><ul><li>其实我们现在创建表结构的时候， id这个字段我们只加了一个备注信息说明它是一个唯一标识，但是在数据库层面呢，并没有去限制字段存储的数据。所以id这个字段没有起到唯一标识的作用。</li></ul><blockquote><p>想要限制字段所存储的数据，就需要用到数据库中的约束。</p></blockquote><h5 id="2-3-1-2-约束"><a href="#2-3-1-2-约束" class="headerlink" title="2.3.1.2 约束"></a>2.3.1.2 约束</h5><p>概念：所谓约束就是作用在表中字段上的规则，用于限制存储在表中的数据。</p><p>作用：就是来保证数据库当中数据的正确性、有效性和完整性。（后面的学习会验证这些）</p><p>在MySQL数据库当中，提供了以下5种约束：</p><table><thead><tr><th><strong>约束</strong></th><th><strong>描述</strong></th><th><strong>关键字</strong></th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段值不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证字段的所有数据都是唯一、不重复的</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段值，则采用默认值</td><td>default</td></tr><tr><td>外键约束</td><td>让两张表的数据建立连接，保证数据的一致性和完整性</td><td>foreign key</td></tr></tbody></table><blockquote><p>注意：约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束。</p></blockquote><p>案例：创建tb_user表</p><ul><li>对应的结构如下：</li></ul><p><img src="/.com//image-20220829143005524-1715613343039-96.png" alt="image-20220829143005524"> </p><blockquote><p>在上述的表结构中:</p><ul><li><p>id 是一行数据的唯一标识</p></li><li><p>username 用户名字段是非空且唯一的</p></li><li><p>name 姓名字段是不允许存储空值的</p></li><li><p>gender 性别字段是有默认值，默认为男</p></li></ul></blockquote><ul><li>建表语句：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table tb_user (</span><br><span class="line">    id int primary key comment &#x27;ID,唯一标识&#x27;, </span><br><span class="line">    username varchar(20) not null unique comment &#x27;用户名&#x27;,</span><br><span class="line">    name varchar(10) not null comment &#x27;姓名&#x27;,</span><br><span class="line">    age int comment &#x27;年龄&#x27;,</span><br><span class="line">    gender char(1) default &#x27;男&#x27; comment &#x27;性别&#x27;</span><br><span class="line">) comment &#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>数据表创建完成，接下来测试一下表中字段上的约束是否生效</p></blockquote><p><img src="/.com//image-20221205215309011-1715613343039-100.png" alt="image-20221205215309011"></p><p><img src="/.com//image-20221205215632599-1715613343039-101.png" alt="image-20221205215632599"></p><p>大家有没有发现一个问题：id字段下存储的值，如果由我们自己来维护会比较麻烦(必须保证值的唯一性)。MySQL数据库为了解决这个问题，给我们提供了一个关键字：auto_increment（自动增长）</p><blockquote><p>主键自增：auto_increment</p><ul><li>每次插入新的行记录时，数据库自动生成id字段(主键)下的值</li><li>具有auto_increment的数据列是一个正数序列开始增长(从1开始自增)</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table tb_user (</span><br><span class="line">    id int primary key auto_increment comment &#x27;ID,唯一标识&#x27;, #主键自动增长</span><br><span class="line">    username varchar(20) not null unique comment &#x27;用户名&#x27;,</span><br><span class="line">    name varchar(10) not null comment &#x27;姓名&#x27;,</span><br><span class="line">    age int comment &#x27;年龄&#x27;,</span><br><span class="line">    gender char(1) default &#x27;男&#x27; comment &#x27;性别&#x27;</span><br><span class="line">) comment &#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure><p>测试：主键自增</p><p><img src="/.com//10.gif"></p><h5 id="2-3-1-3-数据类型"><a href="#2-3-1-3-数据类型" class="headerlink" title="2.3.1.3 数据类型"></a>2.3.1.3 数据类型</h5><p>在上面建表语句中，我们在指定字段的数据类型时，用到了int 、varchar、char，那么在MySQL中除了以上的数据类型，还有哪些常见的数据类型呢？ 接下来,我们就来详细介绍一下MySQL的数据类型。</p><p>MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p><p><strong>数值类型</strong></p><table><thead><tr><th>类型</th><th>大小</th><th>有符号(SIGNED)范围</th><th>无符号(UNSIGNED)范围</th><th>描述</th></tr></thead><tbody><tr><td>TINYINT</td><td>1byte</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2bytes</td><td>(-32768，32767)</td><td>(0，65535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3bytes</td><td>(-8388608，8388607)</td><td>(0，16777215)</td><td>大整数值</td></tr><tr><td>INT&#x2F;INTEGER</td><td>4bytes</td><td>(-2147483648，2147483647)</td><td>(0，4294967295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8bytes</td><td>(-2^63，2^63-1)</td><td>(0，2^64-1)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4bytes</td><td>(-3.402823466 E+38，3.402823466351 E+38)</td><td>0 和 (1.175494351  E-38，3.402823466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8bytes</td><td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td><td>0 和  (2.2250738585072014 E-308，1.7976931348623157 E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td></td><td>依赖于M(精度)和D(标度)的值</td><td>依赖于M(精度)和D(标度)的值</td><td>小数值(精确定点数)</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例: </span><br><span class="line">    年龄字段 <span class="comment">---不会出现负数, 而且人的年龄不会太大</span></span><br><span class="line">age tinyint unsigned</span><br><span class="line"></span><br><span class="line">分数 <span class="comment">---总分100分, 最多出现一位小数</span></span><br><span class="line">score <span class="keyword">double</span>(<span class="number">4</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>字符串类型</strong></p><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串(需要指定长度)</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串(需要指定长度)</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><p>char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例： </span><br><span class="line">    用户名 username <span class="comment">---长度不定, 最长不会超过50</span></span><br><span class="line">username <span class="type">varchar</span>(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">手机号 phone <span class="comment">---固定长度为11</span></span><br><span class="line">phone <span class="type">char</span>(<span class="number">11</span>)</span><br></pre></td></tr></table></figure><p><strong>日期时间类型</strong></p><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01 至  9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>-838:59:59 至  838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901 至 2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例: </span><br><span class="line">生日字段  birthday <span class="comment">---生日只需要年月日  </span></span><br><span class="line">birthday <span class="type">date</span></span><br><span class="line"></span><br><span class="line">创建时间 createtime <span class="comment">--- 需要精确到时分秒</span></span><br><span class="line">createtime  datetime</span><br></pre></td></tr></table></figure><h5 id="2-3-1-4-案例"><a href="#2-3-1-4-案例" class="headerlink" title="2.3.1.4 案例"></a>2.3.1.4 案例</h5><p>需求：根据产品原型&#x2F;需求创建表((设计合理的数据类型、长度、约束) </p><blockquote><p>参考资料中提供的《黑马-tlias智能学习辅助系统》页面原型，设计员工管理模块的表结构</p><p>暂不考虑所属部门字段</p></blockquote><p>产品原型及需求如下：</p><p><img src="/.com//image-20220829151032029-1715613343039-103.png" alt="image-20220829151032029"></p><p> <img src="/.com//image-20220829151228102-1715613343039-104.png"></p><p><img src="/.com//image-20220829151245450-1715613343039-105.png"></p><p><strong>步骤：</strong></p><ol><li><p>阅读产品原型及需求文档，看看里面涉及到哪些字段。</p></li><li><p>查看需求文档说明，确认各个字段的类型以及字段存储数据的长度限制。</p></li><li><p>在页面原型中描述的基础字段的基础上，再增加额外的基础字段。</p></li></ol><p>使用SQL创建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp (</span><br><span class="line">  id <span class="type">int</span> unsigned <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">  username <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  password <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="string">&#x27;123456&#x27;</span> comment <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  gender tinyint unsigned <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;性别, 说明: 1 男, 2 女&#x27;</span>,</span><br><span class="line">  image <span class="type">varchar</span>(<span class="number">300</span>) comment <span class="string">&#x27;图像&#x27;</span>,</span><br><span class="line">  job tinyint unsigned comment <span class="string">&#x27;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管&#x27;</span>,</span><br><span class="line">  entrydate <span class="type">date</span> comment <span class="string">&#x27;入职时间&#x27;</span>,</span><br><span class="line">  create_time datetime <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  update_time datetime <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;修改时间&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;员工表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>除了使用SQL语句创建表外，我们还可以借助于图形化界面来创建表结构，这种创建方式会更加直观、更加方便。</p><p>操作步骤如下：</p><ol><li>在指定操作的数据库上，右键New &#x3D;&#x3D;&gt; Table</li></ol><p><img src="/.com//image-20221205230447721-1715613343039-106.png" alt="image-20221205230447721"></p><ol start="2"><li>编辑表结构的相关信息</li></ol><p><img src="/.com//image-20221205231846161-1715613343039-107.png" alt="image-20221205231846161"></p><h5 id="2-3-1-5-设计表流程"><a href="#2-3-1-5-设计表流程" class="headerlink" title="2.3.1.5 设计表流程"></a>2.3.1.5 设计表流程</h5><p>通过上面的案例，我们明白了，设计一张表，基本的流程如下：</p><ol><li><p>阅读页面原型及需求文档</p></li><li><p>基于页面原则和需求文档，确定原型字段(类型、长度限制、约束)</p></li><li><p>再增加表设计所需要的业务基础字段(id主键、插入时间、修改时间)</p></li></ol><p><img src="/.com//image-20221205232253088-1715613343039-108.png" alt="image-20221205232253088"></p><blockquote><p>说明：</p><ul><li><p>create_time：记录的是当前这条数据插入的时间。 </p></li><li><p>update_time：记录当前这条数据最后更新的时间。</p></li></ul></blockquote><h4 id="2-3-2-查询"><a href="#2-3-2-查询" class="headerlink" title="2.3.2 查询"></a>2.3.2 查询</h4><blockquote><p>关于表结构的查询操作，工作中一般都是直接基于<strong>图形化界面操作</strong>。 </p></blockquote><p><strong>查询当前数据库所有表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221205233746548-1715613343039-109.png" alt="image-20221205233746548"></p><p><strong>查看指定表结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc 表名 ;#可以查看指定表的字段、字段的类型、是否可以为NULL、是否存在默认值等信息</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221205234114053.png" alt="image-20221205234114053"></p><p><strong>查询指定表的建表语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table 表名 ;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221205234334696-1715613343039-111.png" alt="image-20221205234334696"></p><p><img src="/.com//image-20221205234444906-1715613343039-112.png" alt="image-20221205234444906"></p><h4 id="2-3-3-修改"><a href="#2-3-3-修改" class="headerlink" title="2.3.3 修改"></a>2.3.3 修改</h4><blockquote><p>关于表结构的修改操作，工作中一般都是直接基于<strong>图形化界面操作</strong>。 </p></blockquote><p><strong>添加字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>  字段名  类型(长度)  [comment 注释]  [约束];</span><br></pre></td></tr></table></figure><p>案例： 为tb_emp表添加字段qq，字段类型为 varchar(11)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_emp <span class="keyword">add</span>  qq  <span class="type">varchar</span>(<span class="number">11</span>) comment <span class="string">&#x27;QQ号码&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>图形化操作：添加字段</p></blockquote><p><img src="/.com//image-20221205235542272-1715613343039-113.png" alt="image-20221205235542272"></p><p><img src="/.com//image-20221205235657807-1715613343039-114.png" alt="image-20221205235657807"></p><p><strong>修改数据类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 modify  字段名  新数据类型(长度);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change  旧字段名  新字段名  类型(长度)  [comment 注释]  [约束];</span><br></pre></td></tr></table></figure><p>案例：修改qq字段的字段类型，将其长度由11修改为13</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_emp modify qq <span class="type">varchar</span>(<span class="number">13</span>) comment <span class="string">&#x27;QQ号码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>案例：修改qq字段名为 qq_num，字段类型varchar(13)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_emp change qq qq_num <span class="type">varchar</span>(<span class="number">13</span>) comment <span class="string">&#x27;QQ号码&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>图形化操作：修改数据类型和字段名</p></blockquote><p><img src="/.com//image-20221205235950010-1715613343039-115.png" alt="image-20221205235950010"></p><p><img src="/.com//image-20221206000030734-1715613343039-116.png" alt="image-20221206000030734"></p><p><strong>删除字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 字段名;</span><br></pre></td></tr></table></figure><p>案例：删除tb_emp表中的qq_num字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_emp <span class="keyword">drop</span> qq_num;</span><br></pre></td></tr></table></figure><blockquote><p>图形化操作：删除字段</p></blockquote><p><img src="/.com//image-20221206000159237-1715613343039-117.png" alt="image-20221206000159237"></p><p><strong>修改表名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="keyword">table</span> 表名 <span class="keyword">to</span>  新表名;</span><br></pre></td></tr></table></figure><p>案例：将当前的tb_emp表的表名修改为emp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename table tb_emp to emp;</span><br></pre></td></tr></table></figure><blockquote><p>图形化操作：修改表名</p></blockquote><p><img src="/.com//image-20221206000636659-1715613343039-118.png" alt="image-20221206000636659"></p><h4 id="2-3-4-删除"><a href="#2-3-4-删除" class="headerlink" title="2.3.4 删除"></a>2.3.4 删除</h4><blockquote><p>关于表结构的删除操作，工作中一般都是直接基于<strong>图形化界面操作</strong>。 </p></blockquote><p>删除表语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span>  <span class="keyword">table</span> [ if <span class="keyword">exists</span> ]  表名;</span><br></pre></td></tr></table></figure><blockquote><p>if exists ：只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。</p></blockquote><p>案例：如果tb_emp表存在，则删除tb_emp表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists tb_emp;  -- 在删除表时，表中的全部数据也会被删除。</span><br></pre></td></tr></table></figure><blockquote><p>图形化操作：删除表</p></blockquote><p><img src="/.com//image-20221206001026916-1715613343039-119.png" alt="image-20221206001026916"> </p><h2 id="3-数据库操作-DML"><a href="#3-数据库操作-DML" class="headerlink" title="3. 数据库操作-DML"></a>3. 数据库操作-DML</h2><p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。</p><ul><li>添加数据（INSERT）</li><li>修改数据（UPDATE）</li><li>删除数据（DELETE）</li></ul><h3 id="3-1-增加-insert"><a href="#3-1-增加-insert" class="headerlink" title="3.1 增加(insert)"></a>3.1 增加(insert)</h3><p>insert语法：</p><ul><li><p>向指定字段添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 (字段名1, 字段名2) values (值1, 值2);</span><br></pre></td></tr></table></figure></li><li><p>全部字段添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 values (值1, 值2, ...);</span><br></pre></td></tr></table></figure></li><li><p>批量添加数据（指定字段）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 (字段名1, 字段名2) values (值1, 值2), (值1, 值2);</span><br></pre></td></tr></table></figure></li><li><p>批量添加数据（全部字段）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 values (值1, 值2, ...), (值1, 值2, ...);</span><br></pre></td></tr></table></figure></li></ul><p>案例1：向tb_emp表的username、name、gender字段插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 因为设计表时create_time, update_time两个字段不能为NULL，所以也做为要插入的字段</span><br><span class="line">insert into tb_emp(username, name, gender, create_time, update_time)</span><br><span class="line">values (&#x27;wuji&#x27;, &#x27;张无忌&#x27;, 1, now(), now());</span><br></pre></td></tr></table></figure><p>案例2：向tb_emp表的所有字段插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_emp(id, username, password, name, gender, image, job, entrydate, create_time, update_time)</span><br><span class="line">values (null, &#x27;zhirou&#x27;, &#x27;123&#x27;, &#x27;周芷若&#x27;, 2, &#x27;1.jpg&#x27;, 1, &#x27;2010-01-01&#x27;, now(), now());</span><br></pre></td></tr></table></figure><p>案例3：批量向tb_emp表的username、name、gender字段插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_emp(username, name, gender, create_time, update_time)</span><br><span class="line">values (&#x27;weifuwang&#x27;, &#x27;韦一笑&#x27;, 1, now(), now()),</span><br><span class="line">       (&#x27;fengzi&#x27;, &#x27;张三疯&#x27;, 1, now(), now());</span><br></pre></td></tr></table></figure><blockquote><p>图形化操作：双击tb_emp表查看数据</p></blockquote><p><img src="/.com//image-20221206002807531-1715613343039-120.png" alt="image-20221206002807531"></p><p>Insert操作的注意事项：</p><ol><li><p>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</p></li><li><p>字符串和日期型数据应该包含在引号中。</p></li><li><p>插入的数据大小，应该在字段的规定范围内。</p></li></ol><h3 id="3-2-修改-update"><a href="#3-2-修改-update" class="headerlink" title="3.2 修改(update)"></a>3.2 修改(update)</h3><p>update语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span> , 字段名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span> , .... [<span class="keyword">where</span> 条件] ;</span><br></pre></td></tr></table></figure><p>案例1：将tb_emp表中id为1的员工，姓名name字段更新为’张三’</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_emp <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>,update_time<span class="operator">=</span>now() <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>案例2：将tb_emp表的所有员工入职日期更新为’2010-01-01’</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_emp <span class="keyword">set</span> entrydate<span class="operator">=</span><span class="string">&#x27;2010-01-01&#x27;</span>,update_time<span class="operator">=</span>now();</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206004425527-1715613343039-121.png" alt="image-20221206004425527"></p><blockquote><p>注意事项:</p><ol><li><p>修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</p></li><li><p>在修改数据时，一般需要同时修改公共字段update_time，将其修改为当前操作时间。</p></li></ol></blockquote><h3 id="3-3-删除-delete"><a href="#3-3-删除-delete" class="headerlink" title="3.3 删除(delete)"></a>3.3 删除(delete)</h3><p>delete语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名  [<span class="keyword">where</span>  条件] ;</span><br></pre></td></tr></table></figure><p>案例1：删除tb_emp表中id为1的员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>案例2：删除tb_emp表中所有员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_emp;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项:</p><p>​• DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。</p><p>​• DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。</p><p>​• 当进行删除全部数据操作时，会提示询问是否确认删除所有数据，直接点击Execute即可。 </p></blockquote><h2 id="4-数据库操作-DQL"><a href="#4-数据库操作-DQL" class="headerlink" title="4. 数据库操作-DQL"></a>4. 数据库操作-DQL</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p>DQL英文全称是Data Query Language(数据查询语言)，用来查询数据库表中的记录。</p><p>查询关键字：SELECT</p><p>查询操作是所有SQL语句当中最为常见，也是最为重要的操作。在一个正常的业务系统中，查询操作的使用频次是要远高于增删改操作的。当我们打开某个网站或APP所看到的展示信息，都是通过从数据库中查询得到的，而在这个查询过程中，还会涉及到条件、排序、分页等操作。</p><p><img src="/.com//image-20220611103943417.png" alt="image-20220611103943417"> </p><h3 id="4-2-语法"><a href="#4-2-语法" class="headerlink" title="4.2 语法"></a>4.2 语法</h3><p>DQL查询语句，语法结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表名列表</span><br><span class="line">WHERE</span><br><span class="line">条件列表</span><br><span class="line">GROUP  BY</span><br><span class="line">分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">分组后条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><p>我们今天会将上面的完整语法拆分为以下几个部分学习：</p><ul><li>基本查询（不带任何条件）</li><li>条件查询（where）</li><li>分组查询（group by）</li><li>排序查询（order by）</li><li>分页查询（limit）</li></ul><p>准备一些测试数据用于查询操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">create database db02; -- 创建数据库</span><br><span class="line">use db02; -- 切换数据库</span><br><span class="line">-- 员工管理(带约束)</span><br><span class="line">create table tb_emp (</span><br><span class="line">    id int unsigned primary key auto_increment comment &#x27;ID&#x27;,</span><br><span class="line">    username varchar(20) not null unique comment &#x27;用户名&#x27;,</span><br><span class="line">    password varchar(32) default &#x27;123456&#x27; comment &#x27;密码&#x27;,</span><br><span class="line">    name varchar(10) not null comment &#x27;姓名&#x27;,</span><br><span class="line">    gender tinyint unsigned not null comment &#x27;性别, 说明: 1 男, 2 女&#x27;,</span><br><span class="line">    image varchar(300) comment &#x27;图像&#x27;,</span><br><span class="line">    job tinyint unsigned comment &#x27;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管&#x27;,</span><br><span class="line">    entrydate date comment &#x27;入职时间&#x27;,</span><br><span class="line">    create_time datetime not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    update_time datetime not null comment &#x27;修改时间&#x27;</span><br><span class="line">) comment &#x27;员工表&#x27;;</span><br><span class="line"></span><br><span class="line">-- 准备测试数据</span><br><span class="line">INSERT INTO tb_emp (id, username, password, name, gender, image, job, entrydate, create_time, update_time) VALUES</span><br><span class="line">    (1, &#x27;jinyong&#x27;, &#x27;123456&#x27;, &#x27;金庸&#x27;, 1, &#x27;1.jpg&#x27;, 4, &#x27;2000-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:35&#x27;),</span><br><span class="line">    (2, &#x27;zhangwuji&#x27;, &#x27;123456&#x27;, &#x27;张无忌&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2015-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:37&#x27;),</span><br><span class="line">    (3, &#x27;yangxiao&#x27;, &#x27;123456&#x27;, &#x27;杨逍&#x27;, 1, &#x27;3.jpg&#x27;, 2, &#x27;2008-05-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:39&#x27;),</span><br><span class="line">    (4, &#x27;weiyixiao&#x27;, &#x27;123456&#x27;, &#x27;韦一笑&#x27;, 1, &#x27;4.jpg&#x27;, 2, &#x27;2007-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:41&#x27;),</span><br><span class="line">    (5, &#x27;changyuchun&#x27;, &#x27;123456&#x27;, &#x27;常遇春&#x27;, 1, &#x27;5.jpg&#x27;, 2, &#x27;2012-12-05&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:43&#x27;),</span><br><span class="line">    (6, &#x27;xiaozhao&#x27;, &#x27;123456&#x27;, &#x27;小昭&#x27;, 2, &#x27;6.jpg&#x27;, 3, &#x27;2013-09-05&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:45&#x27;),</span><br><span class="line">    (7, &#x27;jixiaofu&#x27;, &#x27;123456&#x27;, &#x27;纪晓芙&#x27;, 2, &#x27;7.jpg&#x27;, 1, &#x27;2005-08-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:47&#x27;),</span><br><span class="line">    (8, &#x27;zhouzhiruo&#x27;, &#x27;123456&#x27;, &#x27;周芷若&#x27;, 2, &#x27;8.jpg&#x27;, 1, &#x27;2014-11-09&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:49&#x27;),</span><br><span class="line">    (9, &#x27;dingminjun&#x27;, &#x27;123456&#x27;, &#x27;丁敏君&#x27;, 2, &#x27;9.jpg&#x27;, 1, &#x27;2011-03-11&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:51&#x27;),</span><br><span class="line">    (10, &#x27;zhaomin&#x27;, &#x27;123456&#x27;, &#x27;赵敏&#x27;, 2, &#x27;10.jpg&#x27;, 1, &#x27;2013-09-05&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:53&#x27;),</span><br><span class="line">    (11, &#x27;luzhangke&#x27;, &#x27;123456&#x27;, &#x27;鹿杖客&#x27;, 1, &#x27;11.jpg&#x27;, 2, &#x27;2007-02-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:55&#x27;),</span><br><span class="line">    (12, &#x27;hebiweng&#x27;, &#x27;123456&#x27;, &#x27;鹤笔翁&#x27;, 1, &#x27;12.jpg&#x27;, 2, &#x27;2008-08-18&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:57&#x27;),</span><br><span class="line">    (13, &#x27;fangdongbai&#x27;, &#x27;123456&#x27;, &#x27;方东白&#x27;, 1, &#x27;13.jpg&#x27;, 1, &#x27;2012-11-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:35:59&#x27;),</span><br><span class="line">    (14, &#x27;zhangsanfeng&#x27;, &#x27;123456&#x27;, &#x27;张三丰&#x27;, 1, &#x27;14.jpg&#x27;, 2, &#x27;2002-08-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:01&#x27;),</span><br><span class="line">    (15, &#x27;yulianzhou&#x27;, &#x27;123456&#x27;, &#x27;俞莲舟&#x27;, 1, &#x27;15.jpg&#x27;, 2, &#x27;2011-05-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:03&#x27;),</span><br><span class="line">    (16, &#x27;songyuanqiao&#x27;, &#x27;123456&#x27;, &#x27;宋远桥&#x27;, 1, &#x27;16.jpg&#x27;, 2, &#x27;2010-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:05&#x27;),</span><br><span class="line">    (17, &#x27;chenyouliang&#x27;, &#x27;12345678&#x27;, &#x27;陈友谅&#x27;, 1, &#x27;17.jpg&#x27;, null, &#x27;2015-03-21&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:07&#x27;),</span><br><span class="line">    (18, &#x27;zhang1&#x27;, &#x27;123456&#x27;, &#x27;张一&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2015-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:09&#x27;),</span><br><span class="line">    (19, &#x27;zhang2&#x27;, &#x27;123456&#x27;, &#x27;张二&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2012-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:11&#x27;),</span><br><span class="line">    (20, &#x27;zhang3&#x27;, &#x27;123456&#x27;, &#x27;张三&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2018-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:13&#x27;),</span><br><span class="line">    (21, &#x27;zhang4&#x27;, &#x27;123456&#x27;, &#x27;张四&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2015-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:15&#x27;),</span><br><span class="line">    (22, &#x27;zhang5&#x27;, &#x27;123456&#x27;, &#x27;张五&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2016-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:17&#x27;),</span><br><span class="line">    (23, &#x27;zhang6&#x27;, &#x27;123456&#x27;, &#x27;张六&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2012-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:19&#x27;),</span><br><span class="line">    (24, &#x27;zhang7&#x27;, &#x27;123456&#x27;, &#x27;张七&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2006-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:21&#x27;),</span><br><span class="line">    (25, &#x27;zhang8&#x27;, &#x27;123456&#x27;, &#x27;张八&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2002-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:23&#x27;),</span><br><span class="line">    (26, &#x27;zhang9&#x27;, &#x27;123456&#x27;, &#x27;张九&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2011-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:25&#x27;),</span><br><span class="line">    (27, &#x27;zhang10&#x27;, &#x27;123456&#x27;, &#x27;张十&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2004-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:27&#x27;),</span><br><span class="line">    (28, &#x27;zhang11&#x27;, &#x27;123456&#x27;, &#x27;张十一&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2007-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:29&#x27;),</span><br><span class="line">    (29, &#x27;zhang12&#x27;, &#x27;123456&#x27;, &#x27;张十二&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2020-01-01&#x27;, &#x27;2022-10-27 16:35:33&#x27;, &#x27;2022-10-27 16:36:31&#x27;);</span><br></pre></td></tr></table></figure><h3 id="4-3-基本查询"><a href="#4-3-基本查询" class="headerlink" title="4.3 基本查询"></a>4.3 基本查询</h3><p>在基本查询的DQL语句中，不带任何的查询条件，语法如下：</p><ul><li><p>查询多个字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段1, 字段2, 字段3 from  表名;</span><br></pre></td></tr></table></figure></li><li><p>查询所有字段（通配符）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *  from  表名;</span><br></pre></td></tr></table></figure></li><li><p>设置别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段1 [ as 别名1 ] , 字段2 [ as 别名2 ]  from  表名;</span><br></pre></td></tr></table></figure></li><li><p>去除重复记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct 字段列表 from  表名;</span><br></pre></td></tr></table></figure></li></ul><p>案例1：查询指定字段 name，entrydate并返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,entrydate from tb_emp;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206112810199-1715613343039-123.png" alt="image-20221206112810199"></p><p>案例2：查询返回所有字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_emp;</span><br></pre></td></tr></table></figure><blockquote><p><code>*</code>号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）</p></blockquote><p><img src="/.com//image-20221206113904763-1715613343039-124.png" alt="image-20221206113904763"></p><p>案例3：查询所有员工的 name,entrydate，并起别名(姓名、入职日期)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 方式1：</span><br><span class="line">select name AS 姓名, entrydate AS 入职日期 from tb_emp;</span><br><span class="line">-- 方式2： 别名中有特殊字符时，使用&#x27;&#x27;或&quot;&quot;包含</span><br><span class="line">select name AS &#x27;姓 名&#x27;, entrydate AS &#x27;入职日期&#x27; from tb_emp;</span><br><span class="line">-- 方式3：</span><br><span class="line">select name AS &quot;姓名&quot;, entrydate AS &quot;入职日期&quot; from tb_emp;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206114752149-1715613343039-125.png" alt="image-20221206114752149"></p><p>案例4：查询已有的员工关联了哪几种职位(不要重复)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct job from tb_emp;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206115440117-1715613343039-126.png" alt="image-20221206115440117"></p><h3 id="4-4-条件查询"><a href="#4-4-条件查询" class="headerlink" title="4.4 条件查询"></a>4.4 条件查询</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  字段列表  <span class="keyword">from</span>   表名   <span class="keyword">where</span>   条件列表 ; <span class="comment">-- 条件列表：意味着可以有多个条件</span></span><br></pre></td></tr></table></figure><p>学习条件查询就是学习条件的构建方式，而在SQL语句当中构造条件的运算符分为两类：</p><ul><li>比较运算符</li><li>逻辑运算符</li></ul><p>常用的比较运算符如下: </p><table><thead><tr><th><strong>比较运算符</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>between …  and …</td><td>在某个范围之内(含最小、最大值)</td></tr><tr><td>in(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>like 占位符</td><td>模糊匹配(_匹配单个字符, %匹配任意个字符)</td></tr><tr><td>is null</td><td>是null</td></tr></tbody></table><p>常用的逻辑运算符如下:</p><table><thead><tr><th><strong>逻辑运算符</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>and 或 &amp;&amp;</td><td>并且 (多个条件同时成立)</td></tr><tr><td>or 或 ||</td><td>或者 (多个条件任意一个成立)</td></tr><tr><td>not 或 !</td><td>非 , 不是</td></tr></tbody></table><p>案例1：查询 姓名 为 杨逍 的员工</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where name = &#x27;杨逍&#x27;; -- 字符串使用&#x27;&#x27;或&quot;&quot;包含</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206121255784-1715613343039-127.png" alt="image-20221206121255784"></p><p>案例2：查询 id小于等于5 的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where id &lt;=5;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206121523712-1715613343039-129.png" alt="image-20221206121523712"></p><p>案例3：查询 没有分配职位 的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where job is null ;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206121754267-1715613343039-128.png" alt="image-20221206121754267"></p><blockquote><p>注意：查询为NULL的数据时，不能使用 <code>= null</code></p><p><img src="/.com//image-20221206122036970-1715613343039-131.png" alt="image-20221206122036970"></p></blockquote><p>案例4：查询 有职位 的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where job is not null ;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206122454101-1715613343039-130.png" alt="image-20221206122454101"></p><p>案例5：查询 密码不等于 ‘123456’ 的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 方式1：</span><br><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where password &lt;&gt; &#x27;123456&#x27;;</span><br><span class="line">-- 方式2：</span><br><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where password != &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206122712152-1715613343039-132.png" alt="image-20221206122712152"></p><p>案例6：查询 入职日期 在 ‘2000-01-01’ (包含) 到 ‘2010-01-01’(包含) 之间的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 方式1：</span><br><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where entrydate&gt;=&#x27;2000-01-01&#x27; and entrydate&lt;=&#x27;2010-01-01&#x27;;</span><br><span class="line">-- 方式2： between...and</span><br><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where entrydate between &#x27;2000-01-01&#x27; and &#x27;2010-01-01&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206125100857-1715613343039-136.png" alt="image-20221206125100857"></p><p>案例7：查询 入职时间 在 ‘2000-01-01’ (包含) 到 ‘2010-01-01’(包含) 之间 且 性别为女 的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where entrydate between &#x27;2000-01-01&#x27; and &#x27;2010-01-01&#x27;</span><br><span class="line">      and gender = 2;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206125356737-1715613343039-133.png" alt="image-20221206125356737"></p><p>案例8：查询 职位是 2 (讲师), 3 (学工主管), 4 (教研主管) 的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 方式1：使用or连接多个条件</span><br><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where job=2 or job=3 or job=4;</span><br><span class="line">-- 方式2：in关键字</span><br><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where job in (2,3,4);</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206141451342-1715613343039-134.png" alt="image-20221206141451342"></p><p>案例9：查询 姓名 为两个字的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where name like &#x27;__&#x27;;  # 通配符 &quot;_&quot; 代表任意1个字符</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206141937293-1715613343039-135.png" alt="image-20221206141937293"></p><p>案例10：查询 姓 ‘张’ 的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where name like &#x27;张%&#x27;; # 通配符 &quot;%&quot; 代表任意个字符（0个 ~ 多个）</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206142156154-1715613343039-137.png" alt="image-20221206142156154"></p><h3 id="4-5-聚合函数"><a href="#4-5-聚合函数" class="headerlink" title="4.5 聚合函数"></a>4.5 聚合函数</h3><p>之前我们做的查询都是横向查询，就是根据条件一行一行的进行判断，而使用聚合函数查询就是纵向查询，它是对一列的值进行计算，然后返回一个结果值。（将一列数据作为一个整体，进行纵向计算）</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  聚合函数(字段列表)  from  表名 ;</span><br></pre></td></tr></table></figure><blockquote><p>注意 : 聚合函数会忽略空值，对NULL值不作为统计。</p></blockquote><p>常用聚合函数：</p><table><thead><tr><th><strong>函数</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><blockquote><p>count ：按照列去统计有多少行数据。</p><ul><li>在根据指定的列统计的时候，如果这一列中有null的行，该行不会被统计在其中。</li></ul><p>sum ：计算指定列的数值和，如果不是数值类型，那么计算结果为0</p><p>max ：计算指定列的最大值</p><p>min ：计算指定列的最小值</p><p>avg ：计算指定列的平均值</p></blockquote><p>案例1：统计该企业员工数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># count(字段)</span><br><span class="line">select count(id) from tb_emp;-- 结果：29</span><br><span class="line">select count(job) from tb_emp;-- 结果：28 （聚合函数对NULL值不做计算）</span><br><span class="line"></span><br><span class="line"># count(常量)</span><br><span class="line">select count(0) from tb_emp;</span><br><span class="line">select count(&#x27;A&#x27;) from tb_emp;</span><br><span class="line"></span><br><span class="line"># count(*)  推荐此写法（MySQL底层进行了优化）</span><br><span class="line">select count(*) from tb_emp;</span><br></pre></td></tr></table></figure><p>案例2：统计该企业最早入职的员工</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select min(entrydate) from tb_emp;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206160145339-1715613343039-138.png" alt="image-20221206160145339"></p><p>案例3：统计该企业最迟入职的员工</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(entrydate) from tb_emp;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206160307416-1715613343039-139.png" alt="image-20221206160307416"></p><p>案例4：统计该企业员工 ID 的平均值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(id) from tb_emp;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206160416605-1715613343039-140.png" alt="image-20221206160416605"></p><p>案例5：统计该企业员工的 ID 之和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(id) from tb_emp;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206160604073-1715613343039-141.png" alt="image-20221206160604073"></p><h3 id="4-6-分组查询"><a href="#4-6-分组查询" class="headerlink" title="4.6 分组查询"></a>4.6 分组查询</h3><p>分组： 按照某一列或者某几列，把相同的数据进行合并输出。</p><blockquote><p>分组其实就是按列进行分类(指定列下相同的数据归为一类)，然后可以对分类完的数据进行合并计算。</p><p>分组查询通常会使用聚合函数进行计算。</p></blockquote><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  字段列表  from  表名  [where 条件]  group by 分组字段名  [having 分组后过滤条件];</span><br></pre></td></tr></table></figure><p>案例1：根据性别分组 , 统计男性和女性员工的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select gender, count(*)</span><br><span class="line">from tb_emp</span><br><span class="line">group by gender; -- 按照gender字段进行分组（gender字段下相同的数据归为一组）</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206172615000-1715613343039-142.png" alt="image-20221206172615000"></p><p>案例2：查询入职时间在 ‘2015-01-01’ (包含) 以前的员工 , 并对结果根据职位分组 , 获取员工数量大于等于2的职位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select job, count(*)</span><br><span class="line">from tb_emp</span><br><span class="line">where entrydate &lt;= &#x27;2015-01-01&#x27;   -- 分组前条件</span><br><span class="line">group by job                      -- 按照job字段分组</span><br><span class="line">having count(*) &gt;= 2;             -- 分组后条件</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206172431873-1715613343039-143.png"></p><blockquote><p>注意事项:</p><p>​• 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</p><p>​• 执行顺序：where &gt; 聚合函数 &gt; having </p></blockquote><p><strong>where与having区别（面试题）</strong></p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><h3 id="4-7-排序查询"><a href="#4-7-排序查询" class="headerlink" title="4.7 排序查询"></a>4.7 排序查询</h3><p>排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select  字段列表  </span><br><span class="line">from   表名   </span><br><span class="line">[where  条件列表] </span><br><span class="line">[group by  分组字段 ] </span><br><span class="line">order  by  字段1  排序方式1 , 字段2  排序方式2 … ;</span><br></pre></td></tr></table></figure><ul><li><p>排序方式：</p><ul><li><p>ASC ：升序（默认值）</p></li><li><p>DESC：降序</p></li></ul></li></ul><p>案例1：根据入职时间, 对员工进行升序排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">order by entrydate ASC; -- 按照entrydate字段下的数据进行升序排序</span><br><span class="line"></span><br><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">order by  entrydate; -- 默认就是ASC（升序）</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206175720337-1715613343039-144.png" alt="image-20221206175720337"></p><blockquote><p>注意事项：如果是升序, 可以不指定排序方式ASC </p></blockquote><p>案例2：根据入职时间，对员工进行降序排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">order by entrydate DESC; -- 按照entrydate字段下的数据进行降序排序</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206180358367-1715613343039-145.png" alt="image-20221206180358367"></p><p>案例3：根据入职时间对公司的员工进行升序排序，入职时间相同，再按照更新时间进行降序排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">order by entrydate ASC , update_time DESC;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206180824583-1715613343039-146.png" alt="image-20221206180824583"></p><blockquote><p>注意事项：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 </p></blockquote><h3 id="4-8-分页查询"><a href="#4-8-分页查询" class="headerlink" title="4.8 分页查询"></a>4.8 分页查询</h3><p>分页操作在业务系统开发时，也是非常常见的一个功能，日常我们在网站中看到的各种各样的分页条，后台也都需要借助于数据库的分页操作。</p><p><img src="/.com//image-20221206183310586.png" alt="image-20221206183310586"></p><p>分页查询语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  字段列表  <span class="keyword">from</span>   表名  limit  起始索引, 查询记录数 ;</span><br></pre></td></tr></table></figure><p>案例1：从起始索引0开始查询员工数据, 每页展示5条记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">limit 0 , 5; -- 从索引0开始，向后取5条记录</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206185257834-1715613343040-148.png" alt="image-20221206185257834"></p><p>案例2：查询 第1页 员工数据, 每页展示5条记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">limit 5; -- 如果查询的是第1页数据，起始索引可以省略，直接简写为：limit 条数</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206184957410-1715613343040-149.png" alt="image-20221206184957410"></p><p>案例3：查询 第2页 员工数据, 每页展示5条记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">limit 5 , 5; -- 从索引5开始，向后取5条记录</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206184602569-1715613343040-150.png" alt="image-20221206184602569"></p><p>案例4：查询 第3页 员工数据, 每页展示5条记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">limit 10 , 5; -- 从索引10开始，向后取5条记录</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206184414356-1715613343040-151.png" alt="image-20221206184414356"></p><blockquote><p>注意事项:</p><ol><li><p>起始索引从0开始。        计算公式 ：   起始索引 &#x3D; （查询页码 - 1）* 每页显示记录数</p></li><li><p>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT</p></li><li><p>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit  条数</p></li></ol></blockquote><h3 id="4-9-案例"><a href="#4-9-案例" class="headerlink" title="4.9 案例"></a>4.9 案例</h3><p>DQL的基本语法我们学习结束了，接下来我们就运用所掌握的DQL语句的语法来完成两个案例。</p><h4 id="4-9-1-案例一"><a href="#4-9-1-案例一" class="headerlink" title="4.9.1 案例一"></a>4.9.1 案例一</h4><p>案例：根据需求完成员工管理的条件分页查询</p><p><img src="/.com//image-20221206212240773.png" alt="image-20221206212240773"></p><blockquote><p>分析：根据输入的条件，查询第1页数据</p><ol><li><p>在员工管理的列表上方有一些查询条件：员工姓名、员工性别，员工入职时间(开始时间~结束时间)</p><ul><li>姓名：张</li><li>性别：男</li><li>入职时间：2000-01-01  ~  2015-12-31</li></ul></li><li><p>除了查询条件外，在列表的下面还有一个分页条，这就涉及到了分页查询</p><ul><li>查询第1页数据（每页显示10条数据）</li></ul></li><li><p>基于查询的结果，按照修改时间进行降序排序</p></li></ol><p>结论：条件查询 + 分页查询 + 排序查询</p></blockquote><p>SQL语句代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 根据输入条件查询第1页数据（每页展示10条记录）</span><br><span class="line">-- 输入条件：</span><br><span class="line">   -- 姓名：张 （模糊查询）</span><br><span class="line">   -- 性别：男</span><br><span class="line">   -- 入职时间：2000-01-01 ~ 2015-12-31</span><br><span class="line">-- 分页： 0 , 10</span><br><span class="line">-- 排序： 修改时间  DESC</span><br><span class="line">select id, username, password, name, gender, image, job, entrydate, create_time, update_time</span><br><span class="line">from tb_emp</span><br><span class="line">where name like &#x27;张%&#x27; and gender = 1 and entrydate between &#x27;2000-01-01&#x27; and &#x27;2015-12-31&#x27;</span><br><span class="line">order by update_time desc</span><br><span class="line">limit 0 , 10;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206213235786-1715613343040-153.png" alt="image-20221206213235786"></p><h4 id="4-9-2-案例二"><a href="#4-9-2-案例二" class="headerlink" title="4.9.2 案例二"></a>4.9.2 案例二</h4><p>案例：根据需求完成员工信息的统计</p><p><img src="/.com//image-20221206210536118-1715613343040-154.png" alt="image-20221206210536118"></p><blockquote><p>分析：以上信息统计在开发中也叫图形报表(将统计好的数据以可视化的形式展示出来)</p><ul><li>员工性别统计：以饼状图的形式展示出企业男性员人数和女性员工人数<ul><li>只要查询出男性员工和女性员工各自有多少人就可以了</li></ul></li><li>员工职位统计：以柱状图的形式展示各职位的在岗人数<ul><li>只要查询出各个职位有多少人就可以了</li></ul></li></ul></blockquote><p>员工性别统计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- if(条件表达式, true取值 , false取值)</span><br><span class="line">select if(gender=1,&#x27;男性员工&#x27;,&#x27;女性员工&#x27;) AS 性别, count(*) AS 人数</span><br><span class="line">from tb_emp</span><br><span class="line">group by gender;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206220908397-1715613343040-155.png" alt="image-20221206220908397"></p><blockquote><p>if(表达式, tvalue, fvalue) ：当表达式为true时，取值tvalue；当表达式为false时，取值fvalue</p></blockquote><p>员工职位统计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- case 表达式 when 值1 then 结果1  when 值2  then  结果2 ...  else  result  end</span><br><span class="line">select (case job</span><br><span class="line">             when 1 then &#x27;班主任&#x27;</span><br><span class="line">             when 2 then &#x27;讲师&#x27;</span><br><span class="line">             when 3 then &#x27;学工主管&#x27;</span><br><span class="line">             when 4 then &#x27;教研主管&#x27;</span><br><span class="line">             else &#x27;未分配职位&#x27;</span><br><span class="line">        end) AS 职位 ,</span><br><span class="line">       count(*) AS 人数</span><br><span class="line">from tb_emp</span><br><span class="line">group by job;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221206221718731-1715613343040-156.png" alt="image-20221206221718731"></p><blockquote><p>case   表达式    when   值1   then  结果1   [when 值2  then  结果2 …]     [else result]     end</p></blockquote><h2 id="5-多表设计"><a href="#5-多表设计" class="headerlink" title="5. 多表设计"></a>5. 多表设计</h2><p>关于单表的操作(单表的设计、单表的增删改查)我们就已经学习完了。接下来我们就要来学习多表的操作，首先来学习多表的设计。</p><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p><ul><li><p>一对多(多对一)</p></li><li><p>多对多</p></li><li><p>一对一</p></li></ul><h3 id="5-1-一对多"><a href="#5-1-一对多" class="headerlink" title="5.1 一对多"></a>5.1 一对多</h3><h4 id="5-1-1-表设计"><a href="#5-1-1-表设计" class="headerlink" title="5.1.1 表设计"></a>5.1.1 表设计</h4><p>需求：根据页面原型及需求文档 ，完成部门及员工的表结构设计</p><ul><li><p>员工管理页面原型：（前面已完成tb_emp表结构设计）</p><p><img src="/.com//image-20220831195520739-1715613343040-157.png" alt="image-20220831195520739"></p></li><li><p>部门管理页面原型：</p></li></ul><p><img src="/.com//image-20221206224149094-1709277282877-12-1715613343040-158.png"></p><blockquote><p>经过上述分析，现已明确的部门表结构：</p><ul><li>业务字段 ： 部门名称</li><li>基础字段 ： id(主键)、创建时间、修改时间</li></ul></blockquote><p>部门表 - SQL语句： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 建议：创建新的数据库（多表设计存放在新数据库下）</span><br><span class="line">create database db03;</span><br><span class="line">use db03;</span><br><span class="line"></span><br><span class="line">-- 部门表</span><br><span class="line">create table tb_dept</span><br><span class="line">(</span><br><span class="line">    id int unsigned primary key auto_increment comment &#x27;主键ID&#x27;,</span><br><span class="line">    name varchar(10) not null unique  comment &#x27;部门名称&#x27;,</span><br><span class="line">    create_time datetime not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    update_time datetime not null comment &#x27;修改时间&#x27;</span><br><span class="line">) comment &#x27;部门表&#x27;;</span><br></pre></td></tr></table></figure><p>部门表创建好之后，我们还需要再修改下员工表。为什么要修改员工表呢？是因为我们之前设计员工表(单表)的时候，并没有考虑员工的归属部门。</p><p><img src="/.com//image-20221206224642902-1715613343040-159.png" alt="image-20221206224642902"></p><p>员工表：添加归属部门字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 员工表</span><br><span class="line">create table tb_emp</span><br><span class="line">(</span><br><span class="line">    id          int unsigned primary key auto_increment comment &#x27;ID&#x27;,</span><br><span class="line">    username    varchar(20)      not null unique comment &#x27;用户名&#x27;,</span><br><span class="line">    password    varchar(32) default &#x27;123456&#x27; comment &#x27;密码&#x27;,</span><br><span class="line">    name        varchar(10)      not null comment &#x27;姓名&#x27;,</span><br><span class="line">    gender      tinyint unsigned not null comment &#x27;性别, 说明: 1 男, 2 女&#x27;,</span><br><span class="line">    image       varchar(300) comment &#x27;图像&#x27;,</span><br><span class="line">    job         tinyint unsigned comment &#x27;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管&#x27;,</span><br><span class="line">    entrydate   date comment &#x27;入职时间&#x27;,</span><br><span class="line">    </span><br><span class="line">    dept_id     int unsigned comment &#x27;部门ID&#x27;, -- 员工的归属部门</span><br><span class="line">    </span><br><span class="line">    create_time datetime         not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    update_time datetime         not null comment &#x27;修改时间&#x27;</span><br><span class="line">) comment &#x27;员工表&#x27;;</span><br></pre></td></tr></table></figure><p>测试数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-- 部门表测试数据</span><br><span class="line">insert into tb_dept (id, name, create_time, update_time) values</span><br><span class="line">(1,&#x27;学工部&#x27;,now(),now()),</span><br><span class="line">(2,&#x27;教研部&#x27;,now(),now()),</span><br><span class="line">(3,&#x27;咨询部&#x27;,now(),now()),</span><br><span class="line">(4,&#x27;就业部&#x27;,now(),now()),</span><br><span class="line">(5,&#x27;人事部&#x27;,now(),now());</span><br><span class="line"></span><br><span class="line">-- 员工表测试数据</span><br><span class="line">INSERT INTO tb_emp</span><br><span class="line">(id, username, password, name, gender, image, job, entrydate,dept_id, create_time, update_time) VALUES</span><br><span class="line">(1,&#x27;jinyong&#x27;,&#x27;123456&#x27;,&#x27;金庸&#x27;,1,&#x27;1.jpg&#x27;,4,&#x27;2000-01-01&#x27;,2,now(),now()),</span><br><span class="line">(2,&#x27;zhangwuji&#x27;,&#x27;123456&#x27;,&#x27;张无忌&#x27;,1,&#x27;2.jpg&#x27;,2,&#x27;2015-01-01&#x27;,2,now(),now()),</span><br><span class="line">(3,&#x27;yangxiao&#x27;,&#x27;123456&#x27;,&#x27;杨逍&#x27;,1,&#x27;3.jpg&#x27;,2,&#x27;2008-05-01&#x27;,2,now(),now()),</span><br><span class="line">(4,&#x27;weiyixiao&#x27;,&#x27;123456&#x27;,&#x27;韦一笑&#x27;,1,&#x27;4.jpg&#x27;,2,&#x27;2007-01-01&#x27;,2,now(),now()),</span><br><span class="line">(5,&#x27;changyuchun&#x27;,&#x27;123456&#x27;,&#x27;常遇春&#x27;,1,&#x27;5.jpg&#x27;,2,&#x27;2012-12-05&#x27;,2,now(),now()),</span><br><span class="line">(6,&#x27;xiaozhao&#x27;,&#x27;123456&#x27;,&#x27;小昭&#x27;,2,&#x27;6.jpg&#x27;,3,&#x27;2013-09-05&#x27;,1,now(),now()),</span><br><span class="line">(7,&#x27;jixiaofu&#x27;,&#x27;123456&#x27;,&#x27;纪晓芙&#x27;,2,&#x27;7.jpg&#x27;,1,&#x27;2005-08-01&#x27;,1,now(),now()),</span><br><span class="line">(8,&#x27;zhouzhiruo&#x27;,&#x27;123456&#x27;,&#x27;周芷若&#x27;,2,&#x27;8.jpg&#x27;,1,&#x27;2014-11-09&#x27;,1,now(),now()),</span><br><span class="line">(9,&#x27;dingminjun&#x27;,&#x27;123456&#x27;,&#x27;丁敏君&#x27;,2,&#x27;9.jpg&#x27;,1,&#x27;2011-03-11&#x27;,1,now(),now()),</span><br><span class="line">(10,&#x27;zhaomin&#x27;,&#x27;123456&#x27;,&#x27;赵敏&#x27;,2,&#x27;10.jpg&#x27;,1,&#x27;2013-09-05&#x27;,1,now(),now()),</span><br><span class="line">(11,&#x27;luzhangke&#x27;,&#x27;123456&#x27;,&#x27;鹿杖客&#x27;,1,&#x27;11.jpg&#x27;,1,&#x27;2007-02-01&#x27;,1,now(),now()),</span><br><span class="line">(12,&#x27;hebiweng&#x27;,&#x27;123456&#x27;,&#x27;鹤笔翁&#x27;,1,&#x27;12.jpg&#x27;,1,&#x27;2008-08-18&#x27;,1,now(),now()),</span><br><span class="line">(13,&#x27;fangdongbai&#x27;,&#x27;123456&#x27;,&#x27;方东白&#x27;,1,&#x27;13.jpg&#x27;,2,&#x27;2012-11-01&#x27;,2,now(),now()),</span><br><span class="line">(14,&#x27;zhangsanfeng&#x27;,&#x27;123456&#x27;,&#x27;张三丰&#x27;,1,&#x27;14.jpg&#x27;,2,&#x27;2002-08-01&#x27;,2,now(),now()),</span><br><span class="line">(15,&#x27;yulianzhou&#x27;,&#x27;123456&#x27;,&#x27;俞莲舟&#x27;,1,&#x27;15.jpg&#x27;,2,&#x27;2011-05-01&#x27;,2,now(),now()),</span><br><span class="line">(16,&#x27;songyuanqiao&#x27;,&#x27;123456&#x27;,&#x27;宋远桥&#x27;,1,&#x27;16.jpg&#x27;,2,&#x27;2010-01-01&#x27;,2,now(),now()),</span><br><span class="line">(17,&#x27;chenyouliang&#x27;,&#x27;123456&#x27;,&#x27;陈友谅&#x27;,1,&#x27;17.jpg&#x27;,NULL,&#x27;2015-03-21&#x27;,NULL,now(),now());</span><br></pre></td></tr></table></figure><p>员工表 - 部门表之间的关系：</p><p><img src="/.com//image-20221206230156403-1715613343040-160.png" alt="image-20221206230156403"></p><blockquote><p><strong>一对多关系实现：在数据库表中多的一方，添加字段，来关联属于一这方的主键。</strong></p></blockquote><h4 id="2-1-2-外键约束"><a href="#2-1-2-外键约束" class="headerlink" title="2.1.2 外键约束"></a>2.1.2 外键约束</h4><p><strong>问题</strong></p><ul><li>表结构创建完毕后，我们看到两张表的数据分别为：</li></ul><p><img src="/.com//image-20220831201844375.png" alt="image-20220831201844375"> </p><p>现在员工表中有五个员工都归属于1号部门(学工部)，当删除了1号部门后，数据变为：</p><p><img src="/.com//image-20220831202111247-1715613343040-162.png" alt="image-20220831202111247"> </p><p>1号部门被删除了，但是依然还有5个员工是属于1号部门的。 此时：就出现数据的不完整、不一致了。 </p><p><strong>问题分析</strong></p><p>目前上述的两张表(员工表、部门表)，在数据库层面，并未建立关联，所以是无法保证数据的一致性和完整性的</p><p><strong>问题解决</strong></p><p>想解决上述的问题呢，我们就可以通过数据库中的 <strong>外键约束</strong> 来解决。</p><blockquote><p>外键约束：让两张表的数据建立连接，保证数据的一致性和完整性。  </p><p>对应的关键字：foreign key</p></blockquote><p>外键约束的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表时指定</span><br><span class="line">create table 表名(</span><br><span class="line">字段名    数据类型,</span><br><span class="line">...</span><br><span class="line">[constraint]   [外键名称]  foreign  key (外键字段名)   references   主表 (主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 建完表后，添加外键</span><br><span class="line">alter table  表名  add constraint  外键名称  foreign key(外键字段名) references 主表(主表列名);</span><br></pre></td></tr></table></figure><p>那接下来，我们就为员工表的dept_id 建立外键约束，来关联部门表的主键。</p><p>方式1：通过SQL语句操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 修改表： 添加外键约束</span><br><span class="line">alter table tb_emp  </span><br><span class="line">add  constraint  fk_dept_id  foreign key (dept_id)  references  tb_dept(id);</span><br></pre></td></tr></table></figure><p>方式2：图形化界面操作</p><p><img src="/.com//image-20221206232750376-1715613343040-163.png" alt="image-20221206232750376"> </p><blockquote><p>当我们添加外键约束时，我们得保证当前数据库表中的数据是完整的。 所以，我们需要将之前删除掉的数据再添加回来。</p></blockquote><blockquote><p>当我们添加了外键之后，再删除ID为1的部门，就会发现，此时数据库报错了，不允许删除。</p><p><img src="/.com//image-20220831205523647-1715613343040-164.png"></p><p>外键约束（foreign key）：保证了数据的完整性和一致性。</p></blockquote><p><strong>物理外键和逻辑外键</strong></p><ul><li><p>物理外键</p><ul><li>概念：使用foreign key定义外键关联另外一张表。</li><li>缺点：<ul><li>影响增、删、改的效率（需要检查外键关系）。</li><li>仅用于单节点数据库，不适用与分布式、集群场景。</li><li>容易引发数据库的死锁问题，消耗性能。</li></ul></li></ul></li><li><p>逻辑外键</p><ul><li>概念：在业务层逻辑中，解决外键关联。</li><li>通过逻辑外键，就可以很方便的解决上述问题。</li></ul></li></ul><blockquote><p>**在现在的企业开发中，很少会使用物理外键，都是使用逻辑外键。 甚至在一些数据库开发规范中，会明确指出禁止使用物理外键 foreign key **</p></blockquote><h3 id="5-2-一对一"><a href="#5-2-一对一" class="headerlink" title="5.2 一对一"></a>5.2 一对一</h3><p>一对一关系表在实际开发中应用起来比较简单，通常是用来做单表的拆分，也就是将一张大表拆分成两张小表，将大表中的一些基础字段放在一张表当中，将其他的字段放在另外一张表当中，以此来提高数据的操作效率。</p><blockquote><p>一对一的应用场景： 用户表(基本信息+身份信息)</p><p><img src="/.com//image-20221207104508080.png" alt="image-20221207104508080"></p><ul><li>基本信息：用户的ID、姓名、性别、手机号、学历</li><li>身份信息：民族、生日、身份证号、身份证签发机关，身份证的有效期(开始时间、结束时间)</li></ul><p>如果在业务系统当中，对用户的基本信息查询频率特别的高，但是对于用户的身份信息查询频率很低，此时出于提高查询效率的考虑，我就可以将这张大表拆分成两张小表，第一张表存放的是用户的基本信息，而第二张表存放的就是用户的身份信息。他们两者之间一对一的关系，一个用户只能对应一个身份证，而一个身份证也只能关联一个用户。</p></blockquote><p>那么在数据库层面怎么去体现上述两者之间是一对一的关系呢？</p><p>其实一对一我们可以看成一种特殊的一对多。一对多我们是怎么设计表关系的？是不是在多的一方添加外键。同样我们也可以通过外键来体现一对一之间的关系，我们只需要在任意一方来添加一个外键就可以了。</p><p><img src="/.com//image-20221207105632634.png" alt="image-20221207105632634"></p><blockquote><p>一对一 ：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p></blockquote><p>SQL脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-- 用户基本信息表</span><br><span class="line">create table tb_user(</span><br><span class="line">    id int unsigned  primary key auto_increment comment &#x27;ID&#x27;,</span><br><span class="line">    name varchar(10) not null comment &#x27;姓名&#x27;,</span><br><span class="line">    gender tinyint unsigned not null comment &#x27;性别, 1 男  2 女&#x27;,</span><br><span class="line">    phone char(11) comment &#x27;手机号&#x27;,</span><br><span class="line">    degree varchar(10) comment &#x27;学历&#x27;</span><br><span class="line">) comment &#x27;用户基本信息表&#x27;;</span><br><span class="line">-- 测试数据</span><br><span class="line">insert into tb_user values (1,&#x27;白眉鹰王&#x27;,1,&#x27;18812340001&#x27;,&#x27;初中&#x27;),</span><br><span class="line">                        (2,&#x27;青翼蝠王&#x27;,1,&#x27;18812340002&#x27;,&#x27;大专&#x27;),</span><br><span class="line">                        (3,&#x27;金毛狮王&#x27;,1,&#x27;18812340003&#x27;,&#x27;初中&#x27;),</span><br><span class="line">                        (4,&#x27;紫衫龙王&#x27;,2,&#x27;18812340004&#x27;,&#x27;硕士&#x27;);</span><br><span class="line"></span><br><span class="line">-- 用户身份信息表</span><br><span class="line">create table tb_user_card(</span><br><span class="line">    id int unsigned  primary key auto_increment comment &#x27;ID&#x27;,</span><br><span class="line">    nationality varchar(10) not null comment &#x27;民族&#x27;,</span><br><span class="line">    birthday date not null comment &#x27;生日&#x27;,</span><br><span class="line">    idcard char(18) not null comment &#x27;身份证号&#x27;,</span><br><span class="line">    issued varchar(20) not null comment &#x27;签发机关&#x27;,</span><br><span class="line">    expire_begin date not null comment &#x27;有效期限-开始&#x27;,</span><br><span class="line">    expire_end date comment &#x27;有效期限-结束&#x27;,</span><br><span class="line">    user_id int unsigned not null unique comment &#x27;用户ID&#x27;,</span><br><span class="line">    constraint fk_user_id foreign key (user_id) references tb_user(id)</span><br><span class="line">) comment &#x27;用户身份信息表&#x27;;</span><br><span class="line">-- 测试数据</span><br><span class="line">insert into tb_user_card values (1,&#x27;汉&#x27;,&#x27;1960-11-06&#x27;,&#x27;100000100000100001&#x27;,&#x27;朝阳区公安局&#x27;,&#x27;2000-06-10&#x27;,null,1),</span><br><span class="line">        (2,&#x27;汉&#x27;,&#x27;1971-11-06&#x27;,&#x27;100000100000100002&#x27;,&#x27;静安区公安局&#x27;,&#x27;2005-06-10&#x27;,&#x27;2025-06-10&#x27;,2),</span><br><span class="line">        (3,&#x27;汉&#x27;,&#x27;1963-11-06&#x27;,&#x27;100000100000100003&#x27;,&#x27;昌平区公安局&#x27;,&#x27;2006-06-10&#x27;,null,3),</span><br><span class="line">        (4,&#x27;回&#x27;,&#x27;1980-11-06&#x27;,&#x27;100000100000100004&#x27;,&#x27;海淀区公安局&#x27;,&#x27;2008-06-10&#x27;,&#x27;2028-06-10&#x27;,4);</span><br></pre></td></tr></table></figure><h3 id="5-3-多对多"><a href="#5-3-多对多" class="headerlink" title="5.3 多对多"></a>5.3 多对多</h3><p>多对多的关系在开发中属于也比较常见的。比如：学生和老师的关系，一个学生可以有多个授课老师，一个授课老师也可以有多个学生。在比如：学生和课程的关系，一个学生可以选修多门课程，一个课程也可以供多个学生选修。</p><p>案例：学生与课程的关系</p><ul><li><p>关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</p></li><li><p>实现关系：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p></li></ul><p><img src="/.com//image-20221207113341028-1715613343040-167.png" alt="image-20221207113341028"></p><p>SQL脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 学生表</span><br><span class="line">create table tb_student(</span><br><span class="line">    id int auto_increment primary key comment &#x27;主键ID&#x27;,</span><br><span class="line">    name varchar(10) comment &#x27;姓名&#x27;,</span><br><span class="line">    no varchar(10) comment &#x27;学号&#x27;</span><br><span class="line">) comment &#x27;学生表&#x27;;</span><br><span class="line">-- 学生表测试数据</span><br><span class="line">insert into tb_student(name, no) values (&#x27;黛绮丝&#x27;, &#x27;2000100101&#x27;),(&#x27;谢逊&#x27;, &#x27;2000100102&#x27;),(&#x27;殷天正&#x27;, &#x27;2000100103&#x27;),(&#x27;韦一笑&#x27;, &#x27;2000100104&#x27;);</span><br><span class="line"></span><br><span class="line">-- 课程表</span><br><span class="line">create table tb_course(</span><br><span class="line">   id int auto_increment primary key comment &#x27;主键ID&#x27;,</span><br><span class="line">   name varchar(10) comment &#x27;课程名称&#x27;</span><br><span class="line">) comment &#x27;课程表&#x27;;</span><br><span class="line">-- 课程表测试数据</span><br><span class="line">insert into tb_course (name) values (&#x27;Java&#x27;), (&#x27;PHP&#x27;), (&#x27;MySQL&#x27;) , (&#x27;Hadoop&#x27;);</span><br><span class="line"></span><br><span class="line">-- 学生课程表（中间表）</span><br><span class="line">create table tb_student_course(</span><br><span class="line">   id int auto_increment comment &#x27;主键&#x27; primary key,</span><br><span class="line">   student_id int not null comment &#x27;学生ID&#x27;,</span><br><span class="line">   course_id  int not null comment &#x27;课程ID&#x27;,</span><br><span class="line">   constraint fk_courseid foreign key (course_id) references tb_course (id),</span><br><span class="line">   constraint fk_studentid foreign key (student_id) references tb_student (id)</span><br><span class="line">)comment &#x27;学生课程中间表&#x27;;</span><br><span class="line">-- 学生课程表测试数据</span><br><span class="line">insert into tb_student_course(student_id, course_id) values (1,1),(1,2),(1,3),(2,2),(2,3),(3,4);</span><br></pre></td></tr></table></figure><h3 id="5-4-案例"><a href="#5-4-案例" class="headerlink" title="5.4 案例"></a>5.4 案例</h3><p>下面通过一个综合案例加深对于多表关系的理解，并掌握多表设计的流程。</p><p><strong>需求</strong></p><ul><li>根据参考资料中提供的《<a href="https://app.mockplus.cn/app/share-e928208474edd220b75e9faff1380e4ashare-VaH7dpoIaqRr/preview/BlJ_BHC42AEaa/tKNB7Tamh14B54?allowShare=1&cps=expand&ha=1">苍穹外卖</a><a href="https://app.mockplus.cn/app/share-e928208474edd220b75e9faff1380e4ashare-VaH7dpoIaqRr/preview/BlJ_BHC42AEaa/tKNB7Tamh14B54?allowShare=1&cps=expand&ha=1">_</a><a href="https://app.mockplus.cn/app/share-e928208474edd220b75e9faff1380e4ashare-VaH7dpoIaqRr/preview/BlJ_BHC42AEaa/tKNB7Tamh14B54?allowShare=1&cps=expand&ha=1">管理后台</a>》页面原型，设计分类管理、菜品管理、套餐管理模块的表结构。</li></ul><p><strong>步骤</strong></p><ol><li><p>阅读页面原型及需求文档，分析各个模块涉及到的表结构，及表结构之间的关系。</p></li><li><p>根据页面原型及需求文档，分析各个表结构中具体的字段及约束。</p></li></ol><p><strong>分析</strong></p><ul><li>页面原型-分类管理</li></ul><p><img src="/.com//image-20221207114241260-1715613343040-168.png" alt="image-20221207114241260"></p><blockquote><p>分类的信息：分类名称、分类类型[菜品&#x2F;套餐]、分类排序、分类状态[禁用&#x2F;启用]、分类的操作时间(修改时间)。</p></blockquote><ul><li>页面原型-菜品管理</li></ul><p><img src="/.com//image-20221207114300057-1715613343040-169.png" alt="image-20221207114300057"></p><blockquote><p>菜品的信息：菜品名称、菜品图片、菜品分类、菜品售价、菜品售卖状态、菜品的操作时间(修改时间)。</p></blockquote><blockquote><p>思考：分类与菜品之间是什么关系？</p><ul><li>思考逻辑：一个分类下可以有多个菜品吗？反过来再想一想，一个菜品会对应多个分类吗？</li></ul><p>答案：一对多关系。一个分类下会有多个菜品，而一个菜品只能归属一个分类。</p><p>设计表原则：在多的一方，添加字段，关联属于一这方的主键。</p></blockquote><ul><li>页面原型-套餐管理</li></ul><p><img src="/.com//image-20221207114327139-1715613343040-170.png" alt="image-20221207114327139"> </p><blockquote><p>套餐的信息：套餐名称、套餐图片、套餐分类、套餐价格、套餐售卖状态、套餐的操作时间。</p></blockquote><blockquote><p>思考：套餐与菜品之间是什么关系？</p><ul><li>思考逻辑：一个套餐下可以有多个菜品吗？反过来再想一想，一个菜品可以出现在多个套餐中吗？</li></ul><p>答案：多对多关系。一个套餐下会有多个菜品，而一个菜品也可以出现在多个套餐中。</p><p>设计表原则：创建第三张中间表，建立两个字段分别关联菜品表的主键和套餐表的主键。</p></blockquote><p>分析页面原型及需求文档后，我们获得：</p><ul><li>分类表<ul><li>业务字段：分类名称、分类类型、分类排序、分类状态</li><li>基础字段：id(主键)、分类的创建时间、分类的修改时间</li></ul></li><li>菜品表<ul><li>业务字段：菜品名称、菜品图片、菜品分类、菜品售价、菜品售卖状态</li><li>基础字段：id(主键)、分类的创建时间、分类的修改时间</li></ul></li><li>套餐表<ul><li>业务字段：套餐名称、套餐图片、套餐分类、套餐价格、套餐售卖状态</li><li>基础字段：id(主键)、分类的创建时间、分类的修改时间</li></ul></li></ul><p>表结构之间的关系：</p><ul><li>分类表 - 菜品表 ： 一对多<ul><li>在菜品表中添加字段(菜品分类)，关联分类表</li></ul></li><li>菜品表 - 套餐表 ： 多对多<ul><li>创建第三张中间表(套餐菜品关联表)，在中间表上添加两个字段(菜品id、套餐id)，分别关联菜品表和分类表</li></ul></li></ul><p><img src="/.com//image-20220831211756004-1715613343040-171.png"></p><p><strong>表结构</strong></p><p>分类表：category</p><ul><li>业务字段：分类名称、分类类型、分类排序、分类状态</li><li>基础字段：id(主键)、创建时间、修改时间</li></ul><p><img src="/.com//image-20221207143907853-1715613343040-172.png" alt="image-20221207143907853"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 分类表</span><br><span class="line">create table category</span><br><span class="line">(</span><br><span class="line">    id          int unsigned primary key auto_increment comment &#x27;主键ID&#x27;,</span><br><span class="line">    name        varchar(20)      not null unique comment &#x27;分类名称&#x27;,</span><br><span class="line">    type        tinyint unsigned not null comment &#x27;类型 1 菜品分类 2 套餐分类&#x27;,</span><br><span class="line">    sort        tinyint unsigned not null comment &#x27;顺序&#x27;,</span><br><span class="line">    status      tinyint unsigned not null default 0 comment &#x27;状态 0 禁用，1 启用&#x27;,</span><br><span class="line">    create_time datetime         not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    update_time datetime         not null comment &#x27;更新时间&#x27;</span><br><span class="line">) comment &#x27;菜品及套餐分类&#x27;;</span><br></pre></td></tr></table></figure><p>菜品表：dish</p><ul><li>业务字段：菜品名称、菜品图片、菜品分类、菜品售价、菜品售卖状态</li><li>基础字段：id(主键)、分类的创建时间、分类的修改时间</li></ul><p><img src="/.com//image-20221207144323100-1715613343040-173.png" alt="image-20221207144323100"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 菜品表</span><br><span class="line">create table dish</span><br><span class="line">(</span><br><span class="line">    id          int unsigned primary key auto_increment comment &#x27;主键ID&#x27;,</span><br><span class="line">    name        varchar(20)      not null unique comment &#x27;菜品名称&#x27;,</span><br><span class="line">    category_id int unsigned     not null comment &#x27;菜品分类ID&#x27;,   -- 逻辑外键</span><br><span class="line">    price       decimal(8, 2)    not null comment &#x27;菜品价格&#x27;,</span><br><span class="line">    image       varchar(300)     not null comment &#x27;菜品图片&#x27;,</span><br><span class="line">    description varchar(200) comment &#x27;描述信息&#x27;,</span><br><span class="line">    status      tinyint unsigned not null default 0 comment &#x27;状态, 0 停售 1 起售&#x27;,</span><br><span class="line">    create_time datetime         not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    update_time datetime         not null comment &#x27;更新时间&#x27;</span><br><span class="line">) comment &#x27;菜品&#x27;;</span><br></pre></td></tr></table></figure><p>套餐表：setmeal</p><ul><li>业务字段：套餐名称、套餐图片、套餐分类、套餐价格、套餐售卖状态</li><li>基础字段：id(主键)、分类的创建时间、分类的修改时间</li></ul><p><img src="/.com//image-20221207144723621-1715613343040-174.png" alt="image-20221207144723621"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 套餐表</span><br><span class="line">create table setmeal</span><br><span class="line">(</span><br><span class="line">    id          int unsigned primary key auto_increment comment &#x27;主键ID&#x27;,</span><br><span class="line">    name        varchar(20)      not null unique comment &#x27;套餐名称&#x27;,</span><br><span class="line">    category_id int unsigned     not null comment &#x27;分类id&#x27;,       -- 逻辑外键</span><br><span class="line">    price       decimal(8, 2)    not null comment &#x27;套餐价格&#x27;,</span><br><span class="line">    image       varchar(300)     not null comment &#x27;图片&#x27;,</span><br><span class="line">    description varchar(200) comment &#x27;描述信息&#x27;,</span><br><span class="line">    status      tinyint unsigned not null default 0 comment &#x27;状态 0:停用 1:启用&#x27;,</span><br><span class="line">    create_time datetime         not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    update_time datetime         not null comment &#x27;更新时间&#x27;</span><br><span class="line">) comment &#x27;套餐&#x27;;</span><br></pre></td></tr></table></figure><p>套餐菜品关联表：setmeal_dish</p><p><img src="/.com//image-20221207145016440-1715613343040-175.png" alt="image-20221207145016440"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 套餐菜品关联表</span><br><span class="line">create table setmeal_dish</span><br><span class="line">(</span><br><span class="line">    id         int unsigned primary key auto_increment comment &#x27;主键ID&#x27;,</span><br><span class="line">    setmeal_id int unsigned     not null comment &#x27;套餐id &#x27;,    -- 逻辑外键</span><br><span class="line">    dish_id    int unsigned     not null comment &#x27;菜品id&#x27;,     -- 逻辑外键</span><br><span class="line">    copies     tinyint unsigned not null comment &#x27;份数&#x27;</span><br><span class="line">) comment &#x27;套餐菜品关联表&#x27;;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>1、一对多</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在多的一方添加外键，关联另一方的主键。</span><br></pre></td></tr></table></figure><p><strong>2、一对一</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意一方，添加外键，关联另一方的主键</span><br></pre></td></tr></table></figure><p><strong>3、多对多</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过中间表来维护，中间表的两个外键，分别关联另外两张表的主键</span><br></pre></td></tr></table></figure><h2 id="6-多表查询"><a href="#6-多表查询" class="headerlink" title="6. 多表查询"></a>6. 多表查询</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><h4 id="6-1-1-数据准备"><a href="#6-1-1-数据准备" class="headerlink" title="6.1.1 数据准备"></a>6.1.1 数据准备</h4><p>SQL脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#建议：创建新的数据库</span><br><span class="line">create database db04;</span><br><span class="line">use db04;</span><br><span class="line"></span><br><span class="line">-- 部门表</span><br><span class="line">create table tb_dept</span><br><span class="line">(</span><br><span class="line">    id          int unsigned primary key auto_increment comment &#x27;主键ID&#x27;,</span><br><span class="line">    name        varchar(10) not null unique comment &#x27;部门名称&#x27;,</span><br><span class="line">    create_time datetime    not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    update_time datetime    not null comment &#x27;修改时间&#x27;</span><br><span class="line">) comment &#x27;部门表&#x27;;</span><br><span class="line">-- 部门表测试</span><br><span class="line">insert into tb_dept (id, name, create_time, update_time)</span><br><span class="line">values (1, &#x27;学工部&#x27;, now(), now()),</span><br><span class="line">       (2, &#x27;教研部&#x27;, now(), now()),</span><br><span class="line">       (3, &#x27;咨询部&#x27;, now(), now()),</span><br><span class="line">       (4, &#x27;就业部&#x27;, now(), now()),</span><br><span class="line">       (5, &#x27;人事部&#x27;, now(), now());</span><br><span class="line"></span><br><span class="line">-- 员工表</span><br><span class="line">create table tb_emp</span><br><span class="line">(</span><br><span class="line">    id          int unsigned primary key auto_increment comment &#x27;ID&#x27;,</span><br><span class="line">    username    varchar(20)      not null unique comment &#x27;用户名&#x27;,</span><br><span class="line">    password    varchar(32) default &#x27;123456&#x27; comment &#x27;密码&#x27;,</span><br><span class="line">    name        varchar(10)      not null comment &#x27;姓名&#x27;,</span><br><span class="line">    gender      tinyint unsigned not null comment &#x27;性别, 说明: 1 男, 2 女&#x27;,</span><br><span class="line">    image       varchar(300) comment &#x27;图像&#x27;,</span><br><span class="line">    job         tinyint unsigned comment &#x27;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师&#x27;,</span><br><span class="line">    entrydate   date comment &#x27;入职时间&#x27;,</span><br><span class="line">    dept_id     int unsigned comment &#x27;部门ID&#x27;,</span><br><span class="line">    create_time datetime         not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    update_time datetime         not null comment &#x27;修改时间&#x27;</span><br><span class="line">) comment &#x27;员工表&#x27;;</span><br><span class="line">-- 员工表测试数据</span><br><span class="line">INSERT INTO tb_emp(id, username, password, name, gender, image, job, entrydate,dept_id, create_time, update_time) </span><br><span class="line">VALUES </span><br><span class="line">(1,&#x27;jinyong&#x27;,&#x27;123456&#x27;,&#x27;金庸&#x27;,1,&#x27;1.jpg&#x27;,4,&#x27;2000-01-01&#x27;,2,now(),now()),</span><br><span class="line">(2,&#x27;zhangwuji&#x27;,&#x27;123456&#x27;,&#x27;张无忌&#x27;,1,&#x27;2.jpg&#x27;,2,&#x27;2015-01-01&#x27;,2,now(),now()),</span><br><span class="line">(3,&#x27;yangxiao&#x27;,&#x27;123456&#x27;,&#x27;杨逍&#x27;,1,&#x27;3.jpg&#x27;,2,&#x27;2008-05-01&#x27;,2,now(),now()),</span><br><span class="line">(4,&#x27;weiyixiao&#x27;,&#x27;123456&#x27;,&#x27;韦一笑&#x27;,1,&#x27;4.jpg&#x27;,2,&#x27;2007-01-01&#x27;,2,now(),now()),</span><br><span class="line">(5,&#x27;changyuchun&#x27;,&#x27;123456&#x27;,&#x27;常遇春&#x27;,1,&#x27;5.jpg&#x27;,2,&#x27;2012-12-05&#x27;,2,now(),now()),</span><br><span class="line">(6,&#x27;xiaozhao&#x27;,&#x27;123456&#x27;,&#x27;小昭&#x27;,2,&#x27;6.jpg&#x27;,3,&#x27;2013-09-05&#x27;,1,now(),now()),</span><br><span class="line">(7,&#x27;jixiaofu&#x27;,&#x27;123456&#x27;,&#x27;纪晓芙&#x27;,2,&#x27;7.jpg&#x27;,1,&#x27;2005-08-01&#x27;,1,now(),now()),</span><br><span class="line">(8,&#x27;zhouzhiruo&#x27;,&#x27;123456&#x27;,&#x27;周芷若&#x27;,2,&#x27;8.jpg&#x27;,1,&#x27;2014-11-09&#x27;,1,now(),now()),</span><br><span class="line">(9,&#x27;dingminjun&#x27;,&#x27;123456&#x27;,&#x27;丁敏君&#x27;,2,&#x27;9.jpg&#x27;,1,&#x27;2011-03-11&#x27;,1,now(),now()),</span><br><span class="line">(10,&#x27;zhaomin&#x27;,&#x27;123456&#x27;,&#x27;赵敏&#x27;,2,&#x27;10.jpg&#x27;,1,&#x27;2013-09-05&#x27;,1,now(),now()),</span><br><span class="line">(11,&#x27;luzhangke&#x27;,&#x27;123456&#x27;,&#x27;鹿杖客&#x27;,1,&#x27;11.jpg&#x27;,5,&#x27;2007-02-01&#x27;,3,now(),now()),</span><br><span class="line">(12,&#x27;hebiweng&#x27;,&#x27;123456&#x27;,&#x27;鹤笔翁&#x27;,1,&#x27;12.jpg&#x27;,5,&#x27;2008-08-18&#x27;,3,now(),now()),</span><br><span class="line">(13,&#x27;fangdongbai&#x27;,&#x27;123456&#x27;,&#x27;方东白&#x27;,1,&#x27;13.jpg&#x27;,5,&#x27;2012-11-01&#x27;,3,now(),now()),</span><br><span class="line">(14,&#x27;zhangsanfeng&#x27;,&#x27;123456&#x27;,&#x27;张三丰&#x27;,1,&#x27;14.jpg&#x27;,2,&#x27;2002-08-01&#x27;,2,now(),now()),</span><br><span class="line">(15,&#x27;yulianzhou&#x27;,&#x27;123456&#x27;,&#x27;俞莲舟&#x27;,1,&#x27;15.jpg&#x27;,2,&#x27;2011-05-01&#x27;,2,now(),now()),</span><br><span class="line">(16,&#x27;songyuanqiao&#x27;,&#x27;123456&#x27;,&#x27;宋远桥&#x27;,1,&#x27;16.jpg&#x27;,2,&#x27;2007-01-01&#x27;,2,now(),now()),</span><br><span class="line">(17,&#x27;chenyouliang&#x27;,&#x27;123456&#x27;,&#x27;陈友谅&#x27;,1,&#x27;17.jpg&#x27;,NULL,&#x27;2015-03-21&#x27;,NULL,now(),now());</span><br></pre></td></tr></table></figure><h4 id="6-1-2-介绍"><a href="#6-1-2-介绍" class="headerlink" title="6.1.2 介绍"></a>6.1.2 介绍</h4><p>多表查询：查询时从多张表中获取所需数据</p><blockquote><p>单表查询的SQL语句：select  字段列表  from  表名;</p><p>那么要执行多表查询，只需要使用逗号分隔多张表即可，如： select   字段列表  from  表1, 表2;</p></blockquote><p>查询用户表和部门表中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from  tb_emp , tb_dept;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20220901093654673-1715613343040-176.png" alt="image-20220901093654673">  </p><p>此时,我们看到查询结果中包含了大量的结果集，总共85条记录，而这其实就是员工表所有的记录(17行)与部门表所有记录(5行)的所有组合情况，这种现象称之为笛卡尔积。</p><p>笛卡尔积：笛卡尔乘积是指在数学中，两个集合(A集合和B集合)的所有组合情况。</p><p><img src="/.com//image-20221207155509696-1715613343040-177.png" alt="image-20221207155509696"></p><blockquote><p>在多表查询时，需要消除无效的笛卡尔积，只保留表关联部分的数据</p></blockquote><p><img src="/.com//image-20220901093756992-1715613343040-178.png"></p><p>在SQL语句中，如何去除无效的笛卡尔积呢？只需要给多表查询加上连接查询的条件即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_emp , tb_dept where tb_emp.dept_id = tb_dept.id ;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221207164518904-1715613343040-179.png" alt="image-20221207164518904"></p><blockquote><p>由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询到。</p></blockquote><h4 id="6-1-3-分类"><a href="#6-1-3-分类" class="headerlink" title="6.1.3 分类"></a>6.1.3 分类</h4><p>多表查询可以分为：</p><ol><li><p>连接查询</p><ul><li>内连接：相当于查询A、B交集部分数据</li></ul><p><img src="/.com//image-20221207165446062-1715613343040-180.png" alt="image-20221207165446062"> </p></li><li><p>外连接</p><ul><li><p>左外连接：查询左表所有数据(包括两张表交集部分数据)</p></li><li><p>右外连接：查询右表所有数据(包括两张表交集部分数据)</p></li></ul></li><li><p>子查询</p></li></ol><h3 id="6-2-内连接"><a href="#6-2-内连接" class="headerlink" title="6.2 内连接"></a>6.2 内连接</h3><p>内连接查询：查询两表或多表中交集部分数据。</p><p>内连接从语法上可以分为：</p><ul><li><p>隐式内连接</p></li><li><p>显式内连接</p></li></ul><p>隐式内连接语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  字段列表   from   表1 , 表2   where  条件 ... ;</span><br></pre></td></tr></table></figure><p>显式内连接语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  字段列表   from   表1  [ inner ]  join 表2  on  连接条件 ... ;</span><br></pre></td></tr></table></figure><p>案例：查询员工的姓名及所属的部门名称</p><ul><li>隐式内连接实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select tb_emp.name , tb_dept.name -- 分别查询两张表中的数据</span><br><span class="line">from tb_emp , tb_dept -- 关联两张表</span><br><span class="line">where tb_emp.dept_id = tb_dept.id; -- 消除笛卡尔积</span><br></pre></td></tr></table></figure><ul><li>显式内连接实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select tb_emp.name , tb_dept.name</span><br><span class="line">from tb_emp inner join tb_dept</span><br><span class="line">on tb_emp.dept_id = tb_dept.id;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221207173435289-1715613343040-181.png" alt="image-20221207173435289"></p><p>多表查询时给表起别名：</p><ul><li><p>tableA  as  别名1  ,  tableB  as  别名2 ;</p></li><li><p>tableA  别名1  ,  tableB  别名2 ;</p></li></ul><p><img src="/.com//image-20221207174234522.png" alt="image-20221207174234522"></p><p>使用了别名的多表查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select emp.name , dept.name</span><br><span class="line">from tb_emp emp inner join tb_dept dept</span><br><span class="line">on emp.dept_id = dept.id;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项:</p><p>一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。</p></blockquote><h3 id="6-3-外连接"><a href="#6-3-外连接" class="headerlink" title="6.3 外连接"></a>6.3 外连接</h3><p>外连接分为两种：左外连接 和 右外连接。</p><p>左外连接语法结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  字段列表   from   表1  left  [ outer ]  join 表2  on  连接条件 ... ;</span><br></pre></td></tr></table></figure><blockquote><p>左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。</p></blockquote><p>右外连接语法结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  字段列表   from   表1  right  [ outer ]  join 表2  on  连接条件 ... ;</span><br></pre></td></tr></table></figure><blockquote><p>右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。</p></blockquote><p>案例：查询员工表中所有员工的姓名, 和对应的部门名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 左外连接：以left join关键字左边的表为主表，查询主表中所有数据，以及和主表匹配的右边表中的数据</span><br><span class="line">select emp.name , dept.name</span><br><span class="line">from tb_emp AS emp left join tb_dept AS dept </span><br><span class="line">     on emp.dept_id = dept.id;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221207181204792-1715613343040-183.png" alt="image-20221207181204792"></p><p>案例：查询部门表中所有部门的名称, 和对应的员工名称 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 右外连接</span><br><span class="line">select dept.name , emp.name</span><br><span class="line">from tb_emp AS emp right join  tb_dept AS dept</span><br><span class="line">     on emp.dept_id = dept.id;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221207181048208-1715613343040-184.png" alt="image-20221207181048208"></p><blockquote><p>注意事项：</p><p>左外连接和右外连接是可以相互替换的，只需要调整连接查询时SQL语句中表的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。</p></blockquote><h3 id="6-4-子查询"><a href="#6-4-子查询" class="headerlink" title="6.4 子查询"></a>6.4 子查询</h3><h4 id="6-4-1-介绍"><a href="#6-4-1-介绍" class="headerlink" title="6.4.1 介绍"></a>6.4.1 介绍</h4><p>SQL语句中嵌套select语句，称为嵌套查询，又称子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span>  <span class="keyword">FROM</span>   t1   <span class="keyword">WHERE</span>  column1 <span class="operator">=</span>  ( <span class="keyword">SELECT</span>  column1  <span class="keyword">FROM</span>  t2 ... );</span><br></pre></td></tr></table></figure><blockquote><p>子查询外部的语句可以是insert &#x2F; update &#x2F; delete &#x2F; select 的任何一个，最常见的是 select。</p></blockquote><p>根据子查询结果的不同分为：</p><ol><li><p>标量子查询（子查询结果为单个值[一行一列]）</p></li><li><p>列子查询（子查询结果为一列，但可以是多行）</p></li><li><p>行子查询（子查询结果为一行，但可以是多列）</p></li><li><p>表子查询（子查询结果为多行多列[相当于子查询结果是一张表]）</p></li></ol><p>子查询可以书写的位置：</p><ol><li>where之后</li><li>from之后</li><li>select之后</li></ol><h4 id="6-4-2-标量子查询"><a href="#6-4-2-标量子查询" class="headerlink" title="6.4.2 标量子查询"></a>6.4.2 标量子查询</h4><p>子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式，这种子查询称为标量子查询。</p><p>常用的操作符： &#x3D;   &lt;&gt;   &gt;    &gt;&#x3D;    &lt;   &lt;&#x3D;   </p><p>案例1：查询”教研部”的所有员工信息</p><blockquote><p>可以将需求分解为两步：</p><ol><li>查询 “教研部” 部门ID</li><li>根据 “教研部” 部门ID，查询员工信息</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 1.查询&quot;教研部&quot;部门ID</span><br><span class="line">select id from tb_dept where name = &#x27;教研部&#x27;;    #查询结果：2</span><br><span class="line">-- 2.根据&quot;教研部&quot;部门ID, 查询员工信息</span><br><span class="line">select * from tb_emp where dept_id = 2;</span><br><span class="line"></span><br><span class="line">-- 合并出上两条SQL语句</span><br><span class="line">select * from tb_emp where dept_id = (select id from tb_dept where name = &#x27;教研部&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221207202215946-1715613343040-185.png" alt="image-20221207202215946"></p><p>案例2：查询在 “方东白” 入职之后的员工信息</p><blockquote><p>可以将需求分解为两步：</p><ol><li>查询 方东白 的入职日期</li><li>查询 指定入职日期之后入职的员工信息</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 1.查询&quot;方东白&quot;的入职日期</span><br><span class="line">select entrydate from tb_emp where name = &#x27;方东白&#x27;;     #查询结果：2012-11-01</span><br><span class="line">-- 2.查询指定入职日期之后入职的员工信息</span><br><span class="line">select * from tb_emp where entrydate &gt; &#x27;2012-11-01&#x27;;</span><br><span class="line"></span><br><span class="line">-- 合并以上两条SQL语句</span><br><span class="line">select * from tb_emp where entrydate &gt; (select entrydate from tb_emp where name = &#x27;方东白&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221207203000445-1715613343040-186.png" alt="image-20221207203000445"></p><h4 id="6-4-3-列子查询"><a href="#6-4-3-列子查询" class="headerlink" title="6.4.3 列子查询"></a>6.4.3 列子查询</h4><p>子查询返回的结果是一列(可以是多行)，这种子查询称为列子查询。</p><p>常用的操作符：</p><table><thead><tr><th><strong>操作符</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr></tbody></table><p>案例：查询”教研部”和”咨询部”的所有员工信息</p><blockquote><p>分解为以下两步：</p><ol><li>查询 “销售部” 和 “市场部” 的部门ID</li><li>根据部门ID, 查询员工信息</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 1.查询&quot;销售部&quot;和&quot;市场部&quot;的部门ID</span><br><span class="line">select id from tb_dept where name = &#x27;教研部&#x27; or name = &#x27;咨询部&#x27;;    #查询结果：3,2</span><br><span class="line">-- 2.根据部门ID, 查询员工信息</span><br><span class="line">select * from tb_emp where dept_id in (3,2);</span><br><span class="line"></span><br><span class="line">-- 合并以上两条SQL语句</span><br><span class="line">select * from tb_emp where dept_id in (select id from tb_dept where name = &#x27;教研部&#x27; or name = &#x27;咨询部&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221207203620472-1715613343040-187.png" alt="image-20221207203620472"></p><h4 id="6-4-4-行子查询"><a href="#6-4-4-行子查询" class="headerlink" title="6.4.4 行子查询"></a>6.4.4 行子查询</h4><p>子查询返回的结果是一行(可以是多列)，这种子查询称为行子查询。</p><p>常用的操作符：&#x3D; 、&lt;&gt; 、IN 、NOT IN</p><p>案例：查询与”韦一笑”的入职日期及职位都相同的员工信息 </p><blockquote><p>可以拆解为两步进行： </p><ol><li>查询 “韦一笑” 的入职日期 及 职位</li><li>查询与”韦一笑”的入职日期及职位相同的员工信息</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查询&quot;韦一笑&quot;的入职日期 及 职位</span><br><span class="line">select entrydate , job from tb_emp where name = &#x27;韦一笑&#x27;;  #查询结果： 2007-01-01 , 2</span><br><span class="line">-- 查询与&quot;韦一笑&quot;的入职日期及职位相同的员工信息</span><br><span class="line">select * from tb_emp where (entrydate,job) = (&#x27;2007-01-01&#x27;,2);</span><br><span class="line"></span><br><span class="line">-- 合并以上两条SQL语句</span><br><span class="line">select * from tb_emp where (entrydate,job) = (select entrydate , job from tb_emp where name = &#x27;韦一笑&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221207204452202-1715613343040-188.png" alt="image-20221207204452202"></p><h4 id="6-4-5-表子查询"><a href="#6-4-5-表子查询" class="headerlink" title="6.4.5 表子查询"></a>6.4.5 表子查询</h4><p>子查询返回的结果是多行多列，常作为临时表，这种子查询称为表子查询。</p><p>案例：查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息</p><blockquote><p>分解为两步执行：</p><ol><li>查询入职日期是 “2006-01-01” 之后的员工信息</li><li>基于查询到的员工信息，在查询对应的部门信息</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where entrydate &gt; &#x27;2006-01-01&#x27;;</span><br><span class="line"></span><br><span class="line">select e.*, d.* from (select * from emp where entrydate &gt; &#x27;2006-01-01&#x27;) e left join dept d on e.dept_id = d.id ;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221208142154263-1715613343040-189.png" alt="image-20221208142154263"></p><h3 id="6-5-案例"><a href="#6-5-案例" class="headerlink" title="6.5 案例"></a>6.5 案例</h3><p>基于之前设计的多表案例的表结构，我们来完成今天的多表查询案例需求。</p><p><strong>准备环境</strong></p><p>将资料中准备好的多表查询的数据准备的SQL脚本导入数据库中。</p><p><img src="/.com//image-20221208143318921-1715613343040-190.png" alt="image-20221208143318921"> </p><ul><li>分类表：category</li><li>菜品表：dish</li><li>套餐表：setmeal</li><li>套餐菜品关系表：setmeal_dish</li></ul><p><img src="/.com//image-20221208143312292-1715613343040-191.png" alt="image-20221208143312292"> </p><p><strong>需求实现</strong></p><ol><li>查询价格低于 10元 的菜品的名称 、价格 及其 菜品的分类名称</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*查询技巧：</span><br><span class="line">     明确1：查询需要用到哪些字段</span><br><span class="line">        菜品名称、菜品价格 、 菜品分类名</span><br><span class="line">     明确2：查询的字段分别归属于哪张表</span><br><span class="line">        菜品表：[菜品名称、菜品价格]</span><br><span class="line">        分类表：[分类名]</span><br><span class="line">     明确3：如查多表，建立表与表之间的关联</span><br><span class="line">        菜品表.caategory_id = 分类表.id</span><br><span class="line">     其他：（其他条件、其他要求）</span><br><span class="line">        价格 &lt; 10</span><br><span class="line">*/</span><br><span class="line">select d.name , d.price , c.name</span><br><span class="line">from dish AS d , category AS c</span><br><span class="line">where d.category_id = c.id</span><br><span class="line">      and d.price &lt; 10;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221208145036602-1715613343040-192.png" alt="image-20221208145036602"></p><ol start="2"><li>查询所有价格在 10元(含)到50元(含)之间 且 状态为”起售”的菜品名称、价格及其分类名称 (即使菜品没有分类 , 也要将菜品查询出来)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select d.name , d.price, c.name</span><br><span class="line">from dish AS d left join category AS c on d.category_id = c.id</span><br><span class="line">where d.price between 10 and 50</span><br><span class="line">      and d.status = 1;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221208145432077-1715613343040-193.png" alt="image-20221208145432077"></p><ol start="3"><li>查询每个分类下最贵的菜品, 展示出分类的名称、最贵的菜品的价格</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select c.name , max(d.price)</span><br><span class="line">from dish AS d , category AS c</span><br><span class="line">where d.category_id = c.id</span><br><span class="line">group by c.name;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221208150016895-1715613343040-194.png" alt="image-20221208150016895"></p><ol start="4"><li>查询各个分类下 菜品状态为 “起售” , 并且 该分类下菜品总数量大于等于3 的 分类名称</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*查询技巧：</span><br><span class="line">     明确1：查询需要用到哪些字段</span><br><span class="line">        分类名称、菜品总数量</span><br><span class="line">     明确2：查询用到的字段分别归属于哪张表</span><br><span class="line">        分类表：[分类名]</span><br><span class="line">        菜品表：[菜品状态]</span><br><span class="line">     明确3：如查多表，建立表与表之间的关联</span><br><span class="line">        菜品表.caategory_id = 分类表.id</span><br><span class="line">     其他：（其他条件、其他要求）</span><br><span class="line">        条件：菜品状态 = 1 (1表示起售)</span><br><span class="line">        分组：分类名</span><br><span class="line">        分组后条件： 总数量 &gt;= 3</span><br><span class="line">*/</span><br><span class="line">select c.name , count(*)</span><br><span class="line">from dish AS d , category AS c</span><br><span class="line">where d.category_id = c.id</span><br><span class="line">      and d.status = 1 -- 起售状态</span><br><span class="line">group by c.name  -- 按照分类名分组</span><br><span class="line">having count(*)&gt;=3; -- 各组后筛选菜品总数据&gt;=3</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221208152107502-1715613343040-195.png" alt="image-20221208152107502"></p><ol start="5"><li>查询出 “商务套餐A” 中包含了哪些菜品 （展示出套餐名称、价格, 包含的菜品名称、价格、份数）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select s.name, s.price, d.name, d.price, sd.copies</span><br><span class="line">from setmeal AS s , setmeal_dish AS sd , dish AS d</span><br><span class="line">where s.id = sd.setmeal_id and sd.dish_id = d.id</span><br><span class="line">      and s.name=&#x27;商务套餐A&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221208152626138-1715613343040-196.png" alt="image-20221208152626138"></p><ol start="6"><li>查询出低于菜品平均价格的菜品信息 (展示出菜品名称、菜品价格)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 1.计算菜品平均价格</span><br><span class="line">select avg(price) from dish;    -- 查询结果：37.736842</span><br><span class="line">-- 2.查询出低于菜品平均价格的菜品信息</span><br><span class="line">select * from dish where price &lt; 37.736842;</span><br><span class="line"></span><br><span class="line">-- 合并以上两条SQL语句</span><br><span class="line">select * from dish where price &lt; (select avg(price) from dish);</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221208153051333.png" alt="image-20221208153051333"></p><h2 id="7-事务"><a href="#7-事务" class="headerlink" title="7. 事务"></a>7. 事务</h2><p>场景：学工部整个部门解散了，该部门及部门下的员工都需要删除了。</p><ul><li><p>操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除学工部</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> dept <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 删除成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除学工部的员工</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 删除失败（操作过程中出现错误：造成删除没有成功）</span></span><br></pre></td></tr></table></figure></li><li><p>问题：如果删除部门成功了，而删除该部门的员工时失败了，此时就造成了数据的不一致。</p></li></ul><p>​要解决上述的问题，就需要通过数据库中的事务来解决。</p><h3 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h3><p>在实际的业务开发中，有些业务操作要多次访问数据库。一个业务要发送多条SQL语句给数据库执行。需要将多次访问数据库的操作视为一个整体来执行，要么所有的SQL语句全部执行成功。如果其中有一条SQL语句失败，就进行事务的回滚，所有的SQL语句全部执行失败。</p><p>简而言之：事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>事务作用：保证在一个事务中多次操作数据库表中数据时，要么全都成功,要么全都失败。</p><h3 id="7-2-操作"><a href="#7-2-操作" class="headerlink" title="7.2 操作"></a>7.2 操作</h3><p>MYSQL中有两种方式进行事务的操作：</p><ol><li>自动提交事务：即执行一条sql语句提交一次事务。（默认MySQL的事务是自动提交）</li><li>手动提交事务：先开启，再提交</li></ol><p>事务操作有关的SQL语句：</p><table><thead><tr><th>SQL语句</th><th>描述</th></tr></thead><tbody><tr><td>start transaction;  &#x2F;  begin ;</td><td>开启手动控制事务</td></tr><tr><td>commit;</td><td>提交事务</td></tr><tr><td>rollback;</td><td>回滚事务</td></tr></tbody></table><blockquote><p>手动提交事务使用步骤：</p><ul><li>第1种情况：开启事务  &#x3D;&gt;  执行SQL语句   &#x3D;&gt;  成功  &#x3D;&gt;  提交事务</li><li>第2种情况：开启事务  &#x3D;&gt;  执行SQL语句   &#x3D;&gt;  失败  &#x3D;&gt;  回滚事务</li></ul></blockquote><p>使用事务控制删除部门和删除该部门下的员工的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除学工部</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_dept <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除学工部的员工</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>上述的这组SQL语句，如果如果执行成功，则提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 提交事务 (成功时执行)</span></span><br><span class="line"><span class="keyword">commit</span> ;</span><br></pre></td></tr></table></figure><ul><li>上述的这组SQL语句，如果如果执行失败，则回滚事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 回滚事务 (出错时执行)</span></span><br><span class="line"><span class="keyword">rollback</span> ;</span><br></pre></td></tr></table></figure><h3 id="7-3-四大特性"><a href="#7-3-四大特性" class="headerlink" title="7.3 四大特性"></a>7.3 四大特性</h3><p>面试题：事务有哪些特性？</p><ul><li>原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><blockquote><p>事务的四大特性简称为：ACID</p></blockquote><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul><li><p><strong>原子性（Atomicity）</strong> ：原子性是指事务包装的一组sql是一个不可分割的工作单元，事务中的操作要么全部成功，要么全部失败。</p></li><li><p><strong>一致性（Consistency）</strong>：一个事务完成之后数据都必须处于一致性状态。</p></li></ul><p>​如果事务成功的完成，那么数据库的所有变化将生效。</p><p>​如果事务执行出现错误，那么数据库的所有变化将会被回滚(撤销)，返回到原始状态。</p><ul><li><strong>隔离性（Isolation）</strong>：多个用户并发的访问数据库时，一个用户的事务不能被其他用户的事务干扰，多个并发的事务之间要相互隔离。</li></ul><p>​一个事务的成功或者失败对于其他的事务是没有影响。</p><ul><li><strong>持久性（Durability）</strong>：一个事务一旦被提交或回滚，它对数据库的改变将是永久性的，哪怕数据库发生异常，重启之后数据亦然存在。</li></ul><h2 id="8-索引"><a href="#8-索引" class="headerlink" title="8. 索引"></a>8. 索引</h2><h3 id="8-1-介绍"><a href="#8-1-介绍" class="headerlink" title="8.1 介绍"></a>8.1 介绍</h3><p>索引(index)：是帮助数据库高效获取数据的数据结构 。</p><ul><li>简单来讲，就是使用索引可以提高查询的效率。</li></ul><p>测试没有使用索引的查询：</p><p><img src="/.com//image-20221209115617429-1715613343040-198.png" alt="image-20221209115617429"></p><p>添加索引后查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 添加索引</span><br><span class="line">create index idx_sku_sn on tb_sku (sn);  #在添加索引时，也需要消耗时间</span><br><span class="line"></span><br><span class="line">-- 查询数据（使用了索引）</span><br><span class="line">select * from tb_sku where sn = &#x27;100000003145008&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221209120107543-1715613343040-199.png" alt="image-20221209120107543"></p><p>优点：</p><ol><li>提高数据查询的效率，降低数据库的IO成本。</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。</li></ol><p>缺点：</p><ol><li>索引会占用存储空间。</li><li>索引大大提高了查询效率，同时却也降低了insert、update、delete的效率。</li></ol><h3 id="8-2-结构"><a href="#8-2-结构" class="headerlink" title="8.2 结构"></a>8.2 结构</h3><p>MySQL数据库支持的索引结构有很多，如：Hash索引、B+Tree索引、Full-Text索引等。</p><p>我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。</p><p>在没有了解B+Tree结构前，我们先回顾下之前所学习的树结构：</p><blockquote><p>二叉查找树：左边的子节点比父节点小，右边的子节点比父节点大</p></blockquote><p><img src="/.com//image-20221208174135229-1715613343040-200.png" alt="image-20221208174135229"> </p><blockquote><p>当我们向二叉查找树保存数据时，是按照从大到小(或从小到大)的顺序保存的，此时就会形成一个单向链表，搜索性能会打折扣。</p></blockquote><p><img src="/.com//image-20221208174859866-1715613343040-201.png" alt="image-20221208174859866"> </p><blockquote><p>可以选择平衡二叉树或者是红黑树来解决上述问题。（红黑树也是一棵平衡的二叉树）</p></blockquote><p><img src="/.com//image-20221209100647867-1715613343040-202.png" alt="image-20221209100647867"></p><blockquote><p>但是在Mysql数据库中并没有使用二叉搜索数或二叉平衡数或红黑树来作为索引的结构。</p></blockquote><p>思考：采用二叉搜索树或者是红黑树来作为索引的结构有什么问题？</p><details>    <summary>答案</summary>    最大的问题就是在数据量大的情况下，树的层级比较深，会影响检索速度。因为不管是二叉搜索数还是红黑数，一个节点下面只能有两个子节点。此时在数据量大的情况下，就会造成数的高度比较高，树的高度一旦高了，检索速度就会降低。</details><blockquote><p>说明：如果数据结构是红黑树，那么查询1000万条数据，根据计算树的高度大概是23左右，这样确实比之前的方式快了很多，但是如果高并发访问，那么一个用户有可能需要23次磁盘IO，那么100万用户，那么会造成效率极其低下。所以为了减少红黑树的高度，那么就得增加树的宽度，就是不再像红黑树一样每个节点只能保存一个数据，可以引入另外一种数据结构，一个节点可以保存多个数据，这样宽度就会增加从而降低树的高度。这种数据结构例如BTree就满足。</p></blockquote><p>下面我们来看看B+Tree(多路平衡搜索树)结构中如何避免这个问题：</p><p><img src="/.com//image-20221208181315728-1715613343040-203.png" alt="image-20221208181315728"></p><p>B+Tree结构：</p><ul><li>每一个节点，可以存储多个key（有n个key，就有n个指针）</li><li>节点分为：叶子节点、非叶子节点<ul><li>叶子节点，就是最后一层子节点，所有的数据都存储在叶子节点上</li><li>非叶子节点，不是树结构最下面的节点，用于索引数据，存储的的是：key+指针</li></ul></li><li>为了提高范围查询效率，叶子节点形成了一个双向链表，便于数据的排序及区间范围查询</li></ul><blockquote><p><strong>拓展：</strong></p><p>非叶子节点都是由key+指针域组成的，一个key占8字节，一个指针占6字节，而一个节点总共容量是16KB，那么可以计算出一个节点可以存储的元素个数：16*1024字节 &#x2F; (8+6)&#x3D;1170个元素。</p><ul><li>查看mysql索引节点大小：show global status like ‘innodb_page_size’;    – 节点大小：16384</li></ul><p>当根节点中可以存储1170个元素，那么根据每个元素的地址值又会找到下面的子节点，每个子节点也会存储1170个元素，那么第二层即第二次IO的时候就会找到数据大概是：1170*1170&#x3D;135W。也就是说B+Tree数据结构中只需要经历两次磁盘IO就可以找到135W条数据。</p><p>对于第二层每个元素有指针，那么会找到第三层，第三层由key+数据组成，假设key+数据总大小是1KB，而每个节点一共能存储16KB，所以一个第三层一个节点大概可以存储16个元素(即16条记录)。那么结合第二层每个元素通过指针域找到第三层的节点，第二层一共是135W个元素，那么第三层总元素大小就是：135W*16结果就是2000W+的元素个数。</p><p>结合上述分析B+Tree有如下优点：</p><ul><li>千万条数据，B+Tree可以控制在小于等于3的高度</li><li>所有的数据都存储在叶子节点上，并且底层已经实现了按照索引进行排序，还可以支持范围查询，叶子节点是一个双向链表，支持从小到大或者从大到小查找</li></ul></blockquote><h3 id="8-3-语法"><a href="#8-3-语法" class="headerlink" title="8.3 语法"></a>8.3 语法</h3><p><strong>创建索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create  [ unique ]  index 索引名 on  表名 (字段名,... ) ;</span><br></pre></td></tr></table></figure><p>案例：为tb_emp表的name字段建立一个索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_emp_name on tb_emp(name);</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221209105119159-1715613343040-204.png" alt="image-20221209105119159"></p><blockquote><p>在创建表时，如果添加了主键和唯一约束，就会默认创建：主键索引、唯一约束</p><p><img src="/.com//image-20221209105846211.png" alt="image-20221209105846211"></p></blockquote><p><strong>查看索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show  index  from  表名;</span><br></pre></td></tr></table></figure><p>案例：查询 tb_emp 表的索引信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show  index  from  tb_emp;</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221209110317092-1715613343040-206.png" alt="image-20221209110317092"></p><p><strong>删除索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop  index  索引名  on  表名;</span><br></pre></td></tr></table></figure><p>案例：删除 tb_emp 表中name字段的索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index idx_emp_name on tb_emp;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ul><li><p>主键字段，在建表时，会自动创建主键索引</p></li><li><p>添加唯一约束时，数据库实际上会添加唯一索引</p></li></ul></blockquote><h1 id="Mybatis入门"><a href="#Mybatis入门" class="headerlink" title="Mybatis入门"></a>Mybatis入门</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>在前面我们学习MySQL数据库时，都是利用图形化客户端工具(如：idea、datagrip)，来操作数据库的。</p><blockquote><p>在客户端工具中，编写增删改查的SQL语句，发给MySQL数据库管理系统，由数据库管理系统执行SQL语句并返回执行结果。</p><p>增删改操作：返回受影响行数</p><p>查询操作：返回结果集(查询的结果)</p></blockquote><p>我们做为后端程序开发人员，通常会使用Java程序来完成对数据库的操作。Java程序操作数据库，现在主流的方式是：Mybatis。</p><p>什么是MyBatis?</p><ul><li><p>MyBatis是一款优秀的 <strong>持久层</strong> <strong>框架</strong>，用于简化JDBC的开发。</p></li><li><p>MyBatis本是 Apache的一个开源项目iBatis，2010年这个项目由apache迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。</p></li><li><p>官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p></li></ul><p>在上面我们提到了两个词：一个是持久层，另一个是框架。</p><ul><li>持久层：指的是就是数据访问层(dao)，是用来操作数据库的。</li></ul><p><img src="/.com//image-20220901114951631-1715613343040-207.png" alt="image-20220901114951631"> </p><ul><li>框架：是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。在框架的基础上进行软件开发更加高效、规范、通用、可拓展。</li></ul><p>Mybatis课程安排：</p><ul><li><p>Mybatis入门</p></li><li><p>Mybatis基础增删改查</p></li><li><p>Mybatis动态SQL</p></li></ul><p>接下来，我们就通过一个入门程序，让大家快速感受一下通过Mybatis如何来操作数据库。</p><h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h2><p>需求：使用Mybatis查询所有用户数据。</p><h3 id="1-1-入门程序分析"><a href="#1-1-入门程序分析" class="headerlink" title="1.1 入门程序分析"></a>1.1 入门程序分析</h3><p>以前我们是在图形化客户端工具中编写SQL查询代码，发送给数据库执行，数据库执行后返回操作结果。</p><p><img src="/.com//image-20221209155704203-1715613343040-208.png" alt="image-20221209155704203"> </p><p>图形化工具会把数据库执行的查询结果，使用表格的形式展现出来</p><p><img src="/.com//image-20220901121116813-1715613343040-209.png" alt="image-20220901121116813"> </p><p>现在使用Mybatis操作数据库，就是在Mybatis中编写SQL查询代码，发送给数据库执行，数据库执行后返回结果。</p><p><img src="/.com//image-20221209155904370-1715613343040-210.png" alt="image-20221209155904370"></p><p> Mybatis会把数据库执行的查询结果，使用实体类封装起来（一行记录对应一个实体类对象）</p><p><img src="/.com//image-20221209161623051-1715613343040-211.png" alt="image-20221209161623051"></p><p>Mybatis操作数据库的步骤：</p><ol><li><p>准备工作(创建springboot工程、数据库表user、实体类User)</p></li><li><p>引入Mybatis的相关依赖，配置Mybatis(数据库连接信息)</p></li><li><p>编写SQL语句(注解&#x2F;XML)</p></li></ol><h3 id="1-2-入门程序实现"><a href="#1-2-入门程序实现" class="headerlink" title="1.2 入门程序实现"></a>1.2 入门程序实现</h3><h4 id="1-2-1-准备工作"><a href="#1-2-1-准备工作" class="headerlink" title="1.2.1 准备工作"></a>1.2.1 准备工作</h4><h5 id="1-2-1-1-创建springboot工程"><a href="#1-2-1-1-创建springboot工程" class="headerlink" title="1.2.1.1 创建springboot工程"></a>1.2.1.1 创建springboot工程</h5><p>创建springboot工程，并导入 mybatis的起步依赖、mysql的驱动包。</p><p><img src="/.com//image-20221209162827242-1715613343040-212.png" alt="image-20221209162827242"></p><p><img src="/.com//image-20221209163123443-1715613343040-213.png" alt="image-20221209163123443"></p><blockquote><p>项目工程创建完成后，自动在pom.xml文件中，导入Mybatis依赖和MySQL驱动依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 仅供参考：只粘贴了pom.xml中部分内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis起步依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mysql驱动包依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- spring单元测试 (集成了junit) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-2-配置Mybatis"><a href="#1-2-2-配置Mybatis" class="headerlink" title="1.2.2 配置Mybatis"></a>1.2.2 配置Mybatis</h4><blockquote><p>在之前使用图形化客户端工具，连接MySQL数据库时，需要配置：</p><p><img src="/.com//image-20221209172527630-1715613343040-214.png" alt="image-20221209172527630"></p><p>连接数据库的四大参数：</p><ul><li>MySQL驱动类 </li><li>登录名</li><li>密码</li><li>数据库连接字符串</li></ul></blockquote><p>基于上述分析，在Mybatis中要连接数据库，同样也需要以上4个参数配置。</p><p>在springboot项目中，可以编写application.properties文件，配置数据库连接信息。我们要连接数据库，就需要配置数据库连接的基本信息，包括：driver-class-name、url 、username，password。</p><blockquote><p>在入门程序中，大家可以直接这么配置，后面会介绍什么是驱动。</p></blockquote><p>application.properties:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#驱动类名称</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库连接的url</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="comment">#连接数据库的用户名</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#连接数据库的密码</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure><blockquote><p>上述的配置，可以直接复制过去，不要敲错了。 全部都是 spring.datasource.xxxx 开头。</p></blockquote><h4 id="1-2-3-编写SQL语句"><a href="#1-2-3-编写SQL语句" class="headerlink" title="1.2.3 编写SQL语句"></a>1.2.3 编写SQL语句</h4><p>在创建出来的springboot工程中，在引导类所在包下，在创建一个包 mapper。在mapper包下创建一个接口 UserMapper ，这是一个持久层接口（Mybatis的持久层接口规范一般都叫 XxxMapper）。</p><p><img src="/.com//image-20221209175843651-1715613343040-215.png" alt="image-20221209175843651"></p><p>UserMapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询所有用户数据</span></span><br><span class="line">    <span class="meta">@Select(&quot;select id, name, age, gender, phone from user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Mapper注解：表示是mybatis中的Mapper接口</p><ul><li>程序运行时：框架会自动生成接口的实现类对象(代理对象)，并给交Spring的IOC容器管理</li></ul><p> @Select注解：代表的就是select查询，用于书写select查询语句</p></blockquote><h4 id="1-2-4-单元测试"><a href="#1-2-4-单元测试" class="headerlink" title="1.2.4 单元测试"></a>1.2.4 单元测试</h4><p>在创建出来的SpringBoot工程中，在src下的test目录下，已经自动帮我们创建好了测试类 ，并且在测试类上已经添加了注解 @SpringBootTest，代表该测试类已经与SpringBoot整合。 </p><p>该测试类在运行时，会自动通过引导类加载Spring的环境（IOC容器）。我们要测试那个bean对象，就可以直接通过@Autowired注解直接将其注入进行，然后就可以测试了。 </p><p>测试类代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisQuickstartApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = userMapper.list();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User&#123;id=1, name=&#x27;白眉鹰王&#x27;, age=55, gender=1, phone=&#x27;18800000000&#x27;&#125;</span><br><span class="line">User&#123;id=2, name=&#x27;金毛狮王&#x27;, age=45, gender=1, phone=&#x27;18800000001&#x27;&#125;</span><br><span class="line">User&#123;id=3, name=&#x27;青翼蝠王&#x27;, age=38, gender=1, phone=&#x27;18800000002&#x27;&#125;</span><br><span class="line">User&#123;id=4, name=&#x27;紫衫龙王&#x27;, age=42, gender=2, phone=&#x27;18800000003&#x27;&#125;</span><br><span class="line">User&#123;id=5, name=&#x27;光明左使&#x27;, age=37, gender=1, phone=&#x27;18800000004&#x27;&#125;</span><br><span class="line">User&#123;id=6, name=&#x27;光明右使&#x27;, age=48, gender=1, phone=&#x27;18800000005&#x27;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-3-解决SQL警告与提示"><a href="#1-3-解决SQL警告与提示" class="headerlink" title="1.3 解决SQL警告与提示"></a>1.3 解决SQL警告与提示</h3><p>默认我们在UserMapper接口上加的@Select注解中编写SQL语句是没有提示的。 如果想让idea给我们提示对应的SQL语句，我们需要在IDEA中配置与MySQL数据库的链接。 </p><p>默认我们在UserMapper接口上的@Select注解中编写SQL语句是没有提示的。如果想让idea给出提示，可以做如下配置：</p><p><img src="/.com//image-20221210143348119.png" alt="image-20221210143348119"></p><p>配置完成之后，发现SQL语句中的关键字有提示了，但还存在不识别表名(列名)的情况：</p><p><img src="/.com//image-20221210143934318-1715613343040-217.png" alt="image-20221210143934318"></p><blockquote><p>产生原因：Idea和数据库没有建立连接，不识别表信息</p><p>解决方案：在Idea中配置MySQL数据库连接</p></blockquote><p><img src="/.com//image-20221210144139792.png" alt="image-20221210144139792"> </p><blockquote><p>在配置的时候指定连接那个数据库，如上图所示连接的就是mybatis数据库。</p></blockquote><h2 id="2-JDBC介绍-了解"><a href="#2-JDBC介绍-了解" class="headerlink" title="2. JDBC介绍(了解)"></a>2. JDBC介绍(了解)</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>通过Mybatis的快速入门，我们明白了，通过Mybatis可以很方便的进行数据库的访问操作。但是大家要明白，其实java语言操作数据库呢，只能通过一种方式：使用sun公司提供的 JDBC 规范。</p><blockquote><p>Mybatis框架，就是对原始的JDBC程序的封装。 </p></blockquote><p>那到底什么是JDBC呢，接下来，我们就来介绍一下。</p><p>JDBC： ( Java DataBase Connectivity )，就是使用Java语言操作关系型数据库的一套API。</p><p><img src="/.com//image-20221210144811961-1715613343040-219.png" alt="image-20221210144811961"> </p><blockquote><p>本质：</p><ul><li><p>sun公司官方定义的一套操作所有关系型数据库的规范，即接口。</p></li><li><p>各个数据库厂商去实现这套接口，提供数据库驱动jar包。</p></li><li><p>我们可以使用这套接口(JDBC)编程，真正执行的代码是驱动jar包中的实现类。</p></li></ul></blockquote><h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><p>下面我们看看原始的JDBC程序是如何操作数据库的。操作步骤如下：</p><ol><li>注册驱动</li><li>获取连接对象</li><li>执行SQL语句，返回执行结果</li><li>处理执行结果</li><li>释放资源</li></ol><blockquote><p>在pom.xml文件中已引入MySQL驱动依赖，我们直接编写JDBC代码即可</p></blockquote><p>JDBC具体代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJdbc</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取数据库连接</span></span><br><span class="line">        String url=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mybatis&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 执行SQL</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement(); <span class="comment">//操作SQL的对象</span></span><br><span class="line">        String sql=<span class="string">&quot;select id,name,age,gender,phone from user&quot;</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);<span class="comment">//SQL查询结果会封装在ResultSet对象中</span></span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//集合对象（用于存储User对象）</span></span><br><span class="line">        <span class="comment">//4. 处理SQL执行结果</span></span><br><span class="line">        <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">            <span class="comment">//取出一行记录中id、name、age、gender、phone下的数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">short</span> <span class="variable">age</span> <span class="operator">=</span> rs.getShort(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">            <span class="type">short</span> <span class="variable">gender</span> <span class="operator">=</span> rs.getShort(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;phone&quot;</span>);</span><br><span class="line">            <span class="comment">//把一行记录中的数据，封装到User对象中</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id,name,age,gender,phone);</span><br><span class="line">            userList.add(user);<span class="comment">//User对象添加到集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 释放资源</span></span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        rs.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DriverManager(类)：数据库驱动管理类。</p><ul><li><p>作用：</p><ol><li><p>注册驱动</p></li><li><p>创建java代码和数据库之间的连接，即获取Connection对象</p></li></ol></li></ul><p>Connection(接口)：建立数据库连接的对象</p><ul><li>作用：用于建立java程序和数据库之间的连接</li></ul><p>Statement(接口)： 数据库操作对象(执行SQL语句的对象)。</p><ul><li>作用：用于向数据库发送sql语句</li></ul><p>ResultSet(接口)：结果集对象（一张虚拟表）</p><ul><li>作用：sql查询语句的执行结果会封装在ResultSet中</li></ul></blockquote><p>通过上述代码，我们看到直接基于JDBC程序来操作数据库，代码实现非常繁琐，所以在项目开发中，我们很少使用。  在项目开发中，通常会使用Mybatis这类的高级技术来操作数据库，从而简化数据库操作、提高开发效率。</p><h3 id="2-3-问题分析"><a href="#2-3-问题分析" class="headerlink" title="2.3 问题分析"></a>2.3 问题分析</h3><p>原始的JDBC程序，存在以下几点问题：</p><ol><li>数据库链接的四要素(驱动、链接、用户名、密码)全部硬编码在java代码中</li><li>查询结果的解析及封装非常繁琐</li><li>每一次查询数据库都需要获取连接,操作完毕后释放连接, 资源浪费, 性能降低</li></ol><p><img src="/.com//image-20221210153407998.png" alt="image-20221210153407998"></p><h3 id="2-4-技术对比"><a href="#2-4-技术对比" class="headerlink" title="2.4 技术对比"></a>2.4 技术对比</h3><p>分析了JDBC的缺点之后，我们再来看一下在mybatis中，是如何解决这些问题的：</p><ol><li><p>数据库连接四要素(驱动、链接、用户名、密码)，都配置在springboot默认的配置文件 application.properties中</p></li><li><p>查询结果的解析及封装，由mybatis自动完成映射封装，我们无需关注</p></li><li><p>在mybatis中使用了数据库连接池技术，从而避免了频繁的创建连接、销毁连接而带来的资源浪费。</p></li></ol><p><img src="/.com//image-20221210154324151.png" alt="image-20221210154324151"></p><blockquote><p>使用SpringBoot+Mybatis的方式操作数据库，能够提升开发效率、降低资源浪费</p></blockquote><p>而对于Mybatis来说，我们在开发持久层程序操作数据库时，需要重点关注以下两个方面：</p><ol><li><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#驱动类名称</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库连接的url</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="comment">#连接数据库的用户名</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#连接数据库的密码</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure></li><li><p>Mapper接口（编写SQL语句）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id, name, age, gender, phone from user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-数据库连接池"><a href="#3-数据库连接池" class="headerlink" title="3. 数据库连接池"></a>3. 数据库连接池</h2><p>在前面我们所讲解的mybatis中，使用了数据库连接池技术，避免频繁的创建连接、销毁连接而带来的资源浪费。</p><p>下面我们就具体的了解下数据库连接池。</p><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p><img src="/.com//image-20221210160341852-1715613343040-222.png" alt="image-20221210160341852"></p><blockquote><p>没有使用数据库连接池：</p><ul><li>客户端执行SQL语句：要先创建一个新的连接对象，然后执行SQL语句，SQL语句执行后又需要关闭连接对象从而释放资源，每次执行SQL时都需要创建连接、销毁链接，这种频繁的重复创建销毁的过程是比较耗费计算机的性能。</li></ul></blockquote><p><img src="/.com//image-20221210161016314-1715613343040-223.png" alt="image-20221210161016314"></p><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</p><ul><li>程序在启动时，会在数据库连接池(容器)中，创建一定数量的Connection对象</li></ul><p>允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</p><ul><li>客户端在执行SQL时，先从连接池中获取一个Connection对象，然后在执行SQL语句，SQL语句执行完之后，释放Connection时就会把Connection对象归还给连接池（Connection对象可以复用）</li></ul><p>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏</p><ul><li>客户端获取到Connection对象了，但是Connection对象并没有去访问数据库(处于空闲)，数据库连接池发现Connection对象的空闲时间 &gt; 连接池中预设的最大空闲时间，此时数据库连接池就会自动释放掉这个连接对象</li></ul><p>数据库连接池的好处：</p><ol><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ol><h3 id="3-2-产品"><a href="#3-2-产品" class="headerlink" title="3.2 产品"></a>3.2 产品</h3><p>要怎么样实现数据库连接池呢？</p><ul><li><p>官方(sun)提供了数据库连接池标准（javax.sql.DataSource接口）</p><ul><li><p>功能：获取连接 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure></li><li><p>第三方组织必须按照DataSource接口实现</p></li></ul></li></ul><p>常见的数据库连接池：</p><ul><li>C3P0</li><li>DBCP</li><li>Druid</li><li>Hikari (springboot默认)</li></ul><p>现在使用更多的是：Hikari、Druid  （性能更优越）</p><ul><li>Hikari（追光者） [默认的连接池]</li></ul><p><img src="/.com//image-20220901144923251-1715613343040-224.png" alt="image-20220901144923251"> </p><ul><li><p>Druid（德鲁伊）</p><ul><li><p>Druid连接池是阿里巴巴开源的数据库连接池项目 </p></li><li><p>功能强大，性能优秀，是Java语言最好的数据库连接池之一</p></li></ul></li></ul><p>​</p><p>如果我们想把默认的数据库连接池切换为Druid数据库连接池，只需要完成以下两步操作即可：</p><blockquote><p>参考官方地址：<a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></p></blockquote><ol><li>在pom.xml文件中引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Druid连接池依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在application.properties中引入数据库连接配置</li></ol><p>方式1：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.druid.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.druid.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="attr">spring.datasource.druid.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.druid.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure><p>方式2：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure><h2 id="4-lombok"><a href="#4-lombok" class="headerlink" title="4. lombok"></a>4. lombok</h2><h3 id="4-1-介绍-1"><a href="#4-1-介绍-1" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p>Lombok是一个实用的Java类库，可以通过简单的注解来简化和消除一些必须有但显得很臃肿的Java代码。</p><p><img src="/.com//image-20221210164641266.png" alt="image-20221210164641266"></p><blockquote><p>通过注解的形式自动生成构造器、getter&#x2F;setter、equals、hashcode、toString等方法，并可以自动化生成日志变量，简化java开发、提高效率。</p></blockquote><table><thead><tr><th><strong>注解</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>@Getter&#x2F;@Setter</td><td>为所有的属性提供get&#x2F;set方法</td></tr><tr><td>@ToString</td><td>会给类自动生成易阅读的  toString 方法</td></tr><tr><td>@EqualsAndHashCode</td><td>根据类所拥有的非静态字段自动重写 equals 方法和  hashCode 方法</td></tr><tr><td>@Data</td><td>提供了更综合的生成代码功能（@Getter  + @Setter + @ToString + @EqualsAndHashCode）</td></tr><tr><td>@NoArgsConstructor</td><td>为实体类生成无参的构造器方法</td></tr><tr><td>@AllArgsConstructor</td><td>为实体类生成除了static修饰的字段之外带有各参数的构造器方法。</td></tr></tbody></table><h3 id="4-2-使用"><a href="#4-2-使用" class="headerlink" title="4.2 使用"></a>4.2 使用</h3><p>第1步：在pom.xml文件中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在springboot的父工程中，已经集成了lombok并指定了版本号，故当前引入依赖时不需要指定version --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第2步：在实体类上添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Short age;</span><br><span class="line">    <span class="keyword">private</span> Short gender;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在实体类上添加了@Data注解，那么这个类在编译时期，就会生成getter&#x2F;setter、equals、hashcode、toString等方法。</p><p><img src="/.com//image-20221210170733921-1715613343040-226.png" alt="image-20221210170733921"></p></blockquote><p>说明：@Data注解中不包含全参构造方法，通常在实体类上，还会添加上：全参构造、无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">//getter方法、setter方法、toString方法、hashCode方法、equals方法</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">//无参构造</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span><span class="comment">//全参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Short age;</span><br><span class="line">    <span class="keyword">private</span> Short gender;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lombok的注意事项：</p><ul><li>Lombok会在编译时，会自动生成对应的java代码</li><li>在使用lombok时，还需要安装一个lombok的插件（新版本的IDEA中自带）</li></ul><p><img src="/.com//image-20221210165506359-1715613343040-227.png" alt="image-20221210165506359"></p><h2 id="5-Mybatis基础操作"><a href="#5-Mybatis基础操作" class="headerlink" title="5. Mybatis基础操作"></a>5. Mybatis基础操作</h2><p>学习完mybatis入门后，我们继续学习mybatis基础操作。</p><h3 id="5-1-需求"><a href="#5-1-需求" class="headerlink" title="5.1 需求"></a>5.1 需求</h3><p>需求说明：</p><ul><li>根据资料中提供的《tlias智能学习辅助系统》页面原型及需求，完成员工管理的需求开发。</li></ul><p><img src="/.com//image-20221210180155700-1715613343040-228.png" alt="image-20221210180155700"> </p><p><img src="/.com//image-20221210180343288-1715613343040-229.png" alt="image-20221210180343288"></p><p><img src="/.com//image-20221210180515206-1715613343040-230.png" alt="image-20221210180515206"></p><p>通过分析以上的页面原型和需求，我们确定了功能列表：</p><ol><li><p>查询</p><ul><li>根据主键ID查询</li><li>条件查询</li></ul></li><li><p>新增</p></li><li><p>更新</p></li><li><p>删除</p><ul><li>根据主键ID删除</li><li>根据主键ID批量删除</li></ul></li></ol><h3 id="5-2-准备"><a href="#5-2-准备" class="headerlink" title="5.2 准备"></a>5.2 准备</h3><p>实施前的准备工作：</p><ol><li>准备数据库表</li><li>创建一个新的springboot工程，选择引入对应的起步依赖（mybatis、mysql驱动、lombok）</li><li>application.properties中引入数据库连接信息</li><li>创建对应的实体类 Emp（实体类属性采用驼峰命名）</li><li>准备Mapper接口 EmpMapper</li></ol><p><strong>准备数据库表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">-- 部门管理</span><br><span class="line">create table dept</span><br><span class="line">(</span><br><span class="line">    id          int unsigned primary key auto_increment comment &#x27;主键ID&#x27;,</span><br><span class="line">    name        varchar(10) not null unique comment &#x27;部门名称&#x27;,</span><br><span class="line">    create_time datetime    not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    update_time datetime    not null comment &#x27;修改时间&#x27;</span><br><span class="line">) comment &#x27;部门表&#x27;;</span><br><span class="line">-- 部门表测试数据</span><br><span class="line">insert into dept (id, name, create_time, update_time)</span><br><span class="line">values (1, &#x27;学工部&#x27;, now(), now()),</span><br><span class="line">       (2, &#x27;教研部&#x27;, now(), now()),</span><br><span class="line">       (3, &#x27;咨询部&#x27;, now(), now()),</span><br><span class="line">       (4, &#x27;就业部&#x27;, now(), now()),</span><br><span class="line">       (5, &#x27;人事部&#x27;, now(), now());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 员工管理</span><br><span class="line">create table emp</span><br><span class="line">(</span><br><span class="line">    id          int unsigned primary key auto_increment comment &#x27;ID&#x27;,</span><br><span class="line">    username    varchar(20)      not null unique comment &#x27;用户名&#x27;,</span><br><span class="line">    password    varchar(32) default &#x27;123456&#x27; comment &#x27;密码&#x27;,</span><br><span class="line">    name        varchar(10)      not null comment &#x27;姓名&#x27;,</span><br><span class="line">    gender      tinyint unsigned not null comment &#x27;性别, 说明: 1 男, 2 女&#x27;,</span><br><span class="line">    image       varchar(300) comment &#x27;图像&#x27;,</span><br><span class="line">    job         tinyint unsigned comment &#x27;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师&#x27;,</span><br><span class="line">    entrydate   date comment &#x27;入职时间&#x27;,</span><br><span class="line">    dept_id     int unsigned comment &#x27;部门ID&#x27;,</span><br><span class="line">    create_time datetime         not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    update_time datetime         not null comment &#x27;修改时间&#x27;</span><br><span class="line">) comment &#x27;员工表&#x27;;</span><br><span class="line">-- 员工表测试数据</span><br><span class="line">INSERT INTO emp (id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time)</span><br><span class="line">VALUES </span><br><span class="line">(1, &#x27;jinyong&#x27;, &#x27;123456&#x27;, &#x27;金庸&#x27;, 1, &#x27;1.jpg&#x27;, 4, &#x27;2000-01-01&#x27;, 2, now(), now()),</span><br><span class="line">(2, &#x27;zhangwuji&#x27;, &#x27;123456&#x27;, &#x27;张无忌&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2015-01-01&#x27;, 2, now(), now()),</span><br><span class="line">(3, &#x27;yangxiao&#x27;, &#x27;123456&#x27;, &#x27;杨逍&#x27;, 1, &#x27;3.jpg&#x27;, 2, &#x27;2008-05-01&#x27;, 2, now(), now()),</span><br><span class="line">(4, &#x27;weiyixiao&#x27;, &#x27;123456&#x27;, &#x27;韦一笑&#x27;, 1, &#x27;4.jpg&#x27;, 2, &#x27;2007-01-01&#x27;, 2, now(), now()),</span><br><span class="line">(5, &#x27;changyuchun&#x27;, &#x27;123456&#x27;, &#x27;常遇春&#x27;, 1, &#x27;5.jpg&#x27;, 2, &#x27;2012-12-05&#x27;, 2, now(), now()),</span><br><span class="line">(6, &#x27;xiaozhao&#x27;, &#x27;123456&#x27;, &#x27;小昭&#x27;, 2, &#x27;6.jpg&#x27;, 3, &#x27;2013-09-05&#x27;, 1, now(), now()),</span><br><span class="line">(7, &#x27;jixiaofu&#x27;, &#x27;123456&#x27;, &#x27;纪晓芙&#x27;, 2, &#x27;7.jpg&#x27;, 1, &#x27;2005-08-01&#x27;, 1, now(), now()),</span><br><span class="line">(8, &#x27;zhouzhiruo&#x27;, &#x27;123456&#x27;, &#x27;周芷若&#x27;, 2, &#x27;8.jpg&#x27;, 1, &#x27;2014-11-09&#x27;, 1, now(), now()),</span><br><span class="line">(9, &#x27;dingminjun&#x27;, &#x27;123456&#x27;, &#x27;丁敏君&#x27;, 2, &#x27;9.jpg&#x27;, 1, &#x27;2011-03-11&#x27;, 1, now(), now()),</span><br><span class="line">(10, &#x27;zhaomin&#x27;, &#x27;123456&#x27;, &#x27;赵敏&#x27;, 2, &#x27;10.jpg&#x27;, 1, &#x27;2013-09-05&#x27;, 1, now(), now()),</span><br><span class="line">(11, &#x27;luzhangke&#x27;, &#x27;123456&#x27;, &#x27;鹿杖客&#x27;, 1, &#x27;11.jpg&#x27;, 5, &#x27;2007-02-01&#x27;, 3, now(), now()),</span><br><span class="line">(12, &#x27;hebiweng&#x27;, &#x27;123456&#x27;, &#x27;鹤笔翁&#x27;, 1, &#x27;12.jpg&#x27;, 5, &#x27;2008-08-18&#x27;, 3, now(), now()),</span><br><span class="line">(13, &#x27;fangdongbai&#x27;, &#x27;123456&#x27;, &#x27;方东白&#x27;, 1, &#x27;13.jpg&#x27;, 5, &#x27;2012-11-01&#x27;, 3, now(), now()),</span><br><span class="line">(14, &#x27;zhangsanfeng&#x27;, &#x27;123456&#x27;, &#x27;张三丰&#x27;, 1, &#x27;14.jpg&#x27;, 2, &#x27;2002-08-01&#x27;, 2, now(), now()),</span><br><span class="line">(15, &#x27;yulianzhou&#x27;, &#x27;123456&#x27;, &#x27;俞莲舟&#x27;, 1, &#x27;15.jpg&#x27;, 2, &#x27;2011-05-01&#x27;, 2, now(), now()),</span><br><span class="line">(16, &#x27;songyuanqiao&#x27;, &#x27;123456&#x27;, &#x27;宋远桥&#x27;, 1, &#x27;16.jpg&#x27;, 2, &#x27;2010-01-01&#x27;, 2, now(), now()),</span><br><span class="line">(17, &#x27;chenyouliang&#x27;, &#x27;123456&#x27;, &#x27;陈友谅&#x27;, 1, &#x27;17.jpg&#x27;, NULL, &#x27;2015-03-21&#x27;, NULL, now(), now());</span><br></pre></td></tr></table></figure><p><strong>创建一个新的springboot工程，选择引入对应的起步依赖（mybatis、mysql驱动、lombok）</strong></p><p><img src="/.com//image-20221210182008131-1715613343040-231.png" alt="image-20221210182008131"></p><p><strong>application.properties中引入数据库连接信息</strong></p><blockquote><p>提示：可以把之前项目中已有的配置信息复制过来即可</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#驱动类名称</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库连接的url</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="comment">#连接数据库的用户名</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#连接数据库的密码</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure><p><strong>创建对应的实体类Emp（实体类属性采用驼峰命名）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Short gender;</span><br><span class="line">    <span class="keyword">private</span> String image;</span><br><span class="line">    <span class="keyword">private</span> Short job;</span><br><span class="line">    <span class="keyword">private</span> LocalDate entrydate;     <span class="comment">//LocalDate类型对应数据表中的date类型</span></span><br><span class="line">    <span class="keyword">private</span> Integer deptId;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;<span class="comment">//LocalDateTime类型对应数据表中的datetime类型</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>准备Mapper接口：EmpMapper</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@Mapper注解：表示当前接口为mybatis中的Mapper接口</span></span><br><span class="line"><span class="comment">  程序运行时会自动创建接口的实现类对象(代理对象)，并交给Spring的IOC容器管理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成以上操作后，项目工程结构目录如下：</p><p><img src="/.com//image-20221210182500817-1715613343041-232.png" alt="image-20221210182500817"></p><h3 id="5-3-删除"><a href="#5-3-删除" class="headerlink" title="5.3 删除"></a>5.3 删除</h3><h4 id="5-3-1-功能实现"><a href="#5-3-1-功能实现" class="headerlink" title="5.3.1 功能实现"></a>5.3.1 功能实现</h4><p>页面原型：</p><p><img src="/.com//image-20221210183336095-1715613343041-233.png" alt="image-20221210183336095"></p><blockquote><p>当我们点击后面的”删除”按钮时，前端页面会给服务端传递一个参数，也就是该行数据的ID。 我们接收到ID后，根据ID删除数据即可。</p></blockquote><p><strong>功能：根据主键删除数据</strong></p><ul><li>SQL语句</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=17的数据</span><br><span class="line">delete from emp where id = 17;</span><br></pre></td></tr></table></figure><blockquote><p>Mybatis框架让程序员更关注于SQL语句</p></blockquote><ul><li>接口方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@Delete(&quot;delete from emp where id = 17&quot;)</span></span><br><span class="line">    <span class="comment">//public void delete();</span></span><br><span class="line">    <span class="comment">//以上delete操作的SQL语句中的id值写成固定的17，就表示只能删除id=17的用户数据</span></span><br><span class="line">    <span class="comment">//SQL语句中的id值不能写成固定数值，需要变为动态的数值</span></span><br><span class="line">    <span class="comment">//解决方案：在delete方法中添加一个参数(用户id)，将方法中的参数，传给SQL语句</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id删除数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id    用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)</span><span class="comment">//使用#&#123;key&#125;方式获取方法中的参数值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Delete注解：用于编写delete操作的SQL语句</p></blockquote><blockquote><p>如果mapper接口方法形参只有一个普通类型的参数，#{…} 里面的属性名可以随便写，如：#{id}、#{value}。但是建议保持名字一致。</p></blockquote><ul><li>测试<ul><li>在单元测试类中通过@Autowired注解注入EmpMapper类型对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisCrudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//从Spring的IOC容器中，获取类型是EmpMapper的对象并注入</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调用删除方法</span></span><br><span class="line">        empMapper.delete(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-2-日志输入"><a href="#5-3-2-日志输入" class="headerlink" title="5.3.2 日志输入"></a>5.3.2 日志输入</h4><p>在Mybatis当中我们可以借助日志，查看到sql语句的执行、执行传递的参数以及执行结果。具体操作如下：</p><ol><li><p>打开application.properties文件</p></li><li><p>开启mybatis的日志，并指定输出到控制台</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定mybatis输出日志的位置, 输出控制台</span></span><br><span class="line"><span class="attr">mybatis.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>开启日志之后，我们再次运行单元测试，可以看到在控制台中，输出了以下的SQL语句信息：</p><p><img src="/.com//image-20220901164225644.png" alt="image-20220901164225644"> </p><blockquote><p>但是我们发现输出的SQL语句：delete from emp where id &#x3D; ?，我们输入的参数16并没有在后面拼接，id的值是使用?进行占位。那这种SQL语句我们称为预编译SQL。</p></blockquote><h4 id="5-3-3-预编译SQL"><a href="#5-3-3-预编译SQL" class="headerlink" title="5.3.3 预编译SQL"></a>5.3.3 预编译SQL</h4><h5 id="5-3-3-1-介绍"><a href="#5-3-3-1-介绍" class="headerlink" title="5.3.3.1 介绍"></a>5.3.3.1 介绍</h5><p>预编译SQL有两个优势：</p><ol><li>性能更高</li><li>更安全(防止SQL注入)</li></ol><p><img src="/.com//image-20221210202222206-1715613343041-235.png" alt="image-20221210202222206"></p><blockquote><p>性能更高：预编译SQL，编译一次之后会将编译后的SQL语句缓存起来，后面再次执行这条语句时，不会再次编译。（只是输入的参数不同）</p><p>更安全(防止SQL注入)：将敏感字进行转义，保障SQL的安全性。</p></blockquote><h5 id="5-3-3-2-SQL注入"><a href="#5-3-3-2-SQL注入" class="headerlink" title="5.3.3.2 SQL注入"></a>5.3.3.2 SQL注入</h5><p>SQL注入：是通过操作输入的数据来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。</p><blockquote><p>由于没有对用户输入进行充分检查，而SQL又是拼接而成，在用户输入参数时，在参数中添加一些SQL关键字，达到改变SQL运行结果的目的，也可以完成恶意攻击。</p></blockquote><p><strong>测试1：使用资料中提供的程序，来验证SQL注入问题</strong></p><p><img src="/.com//image-20221210205419634-1715613343041-236.png" alt="image-20221210205419634"></p><p>第1步：进入到DOS</p><p><img src="/.com//image-20221211124744203-1715613343041-237.png" alt="image-20221211124744203"></p><p><img src="/.com//image-20221211124840720-1715613343041-238.png" alt="image-20221211124840720"></p><p>第2步：执行以下命令，启动程序</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动存在SQL注入的程序</span></span><br><span class="line">java <span class="literal">-jar</span> sql_Injection_demo<span class="literal">-0</span>.<span class="number">0.1</span><span class="literal">-SNAPSHOT</span>.jar </span><br></pre></td></tr></table></figure><p><img src="/.com//image-20221210211605231-1715613343041-239.png" alt="image-20221210211605231"></p><p>第3步：打开浏览器输入<code>http://localhost:9090/login.html</code></p><p><img src="/.com//image-20221210212406527.png" alt="image-20221210212406527"></p><p>发现竟然能够登录成功：</p><p><img src="/.com//image-20221210212511915-1715613343041-241.png" alt="image-20221210212511915"></p><p>以上操作为什么能够登录成功呢？</p><ul><li>由于没有对用户输入内容进行充分检查，而SQL又是字符串拼接方式而成，在用户输入参数时，在参数中添加一些SQL关键字，达到改变SQL运行结果的目的，从而完成恶意攻击。</li></ul><p><img src="/.com//image-20221210213311518-1715613343041-242.png" alt="image-20221210213311518"></p><blockquote><p><img src="/.com//image-20221210214431228-1715613343041-243.png" alt="image-20221210214431228"></p><p>用户在页面提交数据的时候人为的添加一些特殊字符，使得sql语句的结构发生了变化，最终可以在没有用户名或者密码的情况下进行登录。</p></blockquote><p><strong>测试2：使用资料中提供的程序，来验证SQL注入问题</strong></p><p>第1步：进入到DOS</p><p>第2步：执行以下命令，启动程序：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动解决了SQL注入的程序</span></span><br><span class="line">java <span class="literal">-jar</span> sql_prepared_demo<span class="literal">-0</span>.<span class="number">0.1</span><span class="literal">-SNAPSHOT</span>.jar</span><br></pre></td></tr></table></figure><p>第3步：打开浏览器输入<code>http://localhost:9090/login.html</code></p><p><img src="/.com//image-20221210212406527.png" alt="image-20221210212406527"></p><p>发现无法登录：</p><p><img src="/.com//image-20221211125751981.png" alt="image-20221211125751981"></p><p>以上操作SQL语句的执行：</p><p><img src="/.com//image-20221211130011973-1715613343041-245.png" alt="image-20221211130011973"></p><blockquote><p>把整个<code>&#39; or &#39;1&#39;=&#39;1</code>作为一个完整的参数，赋值给第2个问号（<code>&#39; or &#39;1&#39;=&#39;1</code>进行了转义，只当做字符串使用）</p></blockquote><h5 id="5-3-3-3-参数占位符"><a href="#5-3-3-3-参数占位符" class="headerlink" title="5.3.3.3 参数占位符"></a>5.3.3.3 参数占位符</h5><p>在Mybatis中提供的参数占位符有两种：${…} 、#{…}</p><ul><li><p>#{…}</p><ul><li>执行SQL时，会将#{…}替换为?，生成预编译SQL，会自动设置参数值</li><li>使用时机：参数传递，都使用#{…}</li></ul></li><li><p>${…}</p><ul><li>拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题</li><li>使用时机：如果对表名、列表进行动态设置时使用</li></ul></li></ul><blockquote><p>注意事项：在项目开发中，建议使用#{…}，生成预编译SQL，防止SQL注入安全。</p></blockquote><h3 id="5-4-新增"><a href="#5-4-新增" class="headerlink" title="5.4 新增"></a>5.4 新增</h3><p>功能：新增员工信息</p><p><img src="/.com//image-20221211134239610-1715613343041-246.png" alt="image-20221211134239610"></p><h4 id="5-4-1-基本新增"><a href="#5-4-1-基本新增" class="headerlink" title="5.4.1 基本新增"></a>5.4.1 基本新增</h4><p>员工表结构：</p><p><img src="/.com//image-20221211134746319-1715613343041-247.png" alt="image-20221211134746319"></p><p>SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) <span class="keyword">values</span> (<span class="string">&#x27;songyuanqiao&#x27;</span>,<span class="string">&#x27;宋远桥&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1.jpg&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;2012-10-09&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;2022-10-01 10:00:00&#x27;</span>,<span class="string">&#x27;2022-10-01 10:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><p>接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#&#123;username&#125;, #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entrydate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Emp emp)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：#{…} 里面写的名称是对象的属性名</p></blockquote><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.mapper.EmpMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.pojo.Emp;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisCrudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建员工对象</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        emp.setUsername(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        emp.setName(<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        emp.setImage(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        emp.setGender((<span class="type">short</span>)<span class="number">1</span>);</span><br><span class="line">        emp.setJob((<span class="type">short</span>)<span class="number">1</span>);</span><br><span class="line">        emp.setEntrydate(LocalDate.of(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">        emp.setCreateTime(LocalDateTime.now());</span><br><span class="line">        emp.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        emp.setDeptId(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//调用添加方法</span></span><br><span class="line">        empMapper.insert(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>日志输出：</p><p><img src="/.com//image-20221211140222240-1715613343041-248.png" alt="image-20221211140222240"></p></blockquote><h4 id="5-4-2-主键返回"><a href="#5-4-2-主键返回" class="headerlink" title="5.4.2 主键返回"></a>5.4.2 主键返回</h4><p>概念：在数据添加成功后，需要获取插入数据库数据的主键。</p><blockquote><p>如：添加套餐数据时，还需要维护套餐菜品关系表数据。</p><p><img src="/.com//image-20221211150353385-1715613343041-249.png" alt="image-20221211150353385"></p><p>业务场景：在前面讲解到的苍穹外卖菜品与套餐模块的表结构，菜品与套餐是多对多的关系，一个套餐对应多个菜品。既然是多对多的关系，是不是有一张套餐菜品中间表来维护它们之间的关系。</p><p><img src="/.com//image-20221212093655389-1715613343041-250.png" alt="image-20221212093655389"></p><p>在添加套餐的时候，我们需要在界面当中来录入套餐的基本信息，还需要来录入套餐与菜品的关联信息。这些信息录入完毕之后，我们一点保存，就需要将套餐的信息以及套餐与菜品的关联信息都需要保存到数据库当中。其实具体的过程包括两步，首先第一步先需要将套餐的基本信息保存了，接下来第二步再来保存套餐与菜品的关联信息。套餐与菜品的关联信息就是往中间表当中来插入数据，来维护它们之间的关系。而中间表当中有两个外键字段，一个是菜品的ID，就是当前菜品的ID，还有一个就是套餐的ID，而这个套餐的 ID 指的就是此次我所添加的套餐的ID，所以我们在第一步保存完套餐的基本信息之后，就需要将套餐的主键值返回来供第二步进行使用。这个时候就需要用到主键返回功能。</p></blockquote><p>那要如何实现在插入数据之后返回所插入行的主键值呢？</p><ul><li>默认情况下，执行插入操作时，是不会主键值返回的。如果我们想要拿到主键值，需要在Mapper接口中的方法上添加一个Options注解，并在注解中指定属性useGeneratedKeys&#x3D;true和keyProperty&#x3D;”实体类属性名”</li></ul><p>主键返回代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//会自动将生成的主键值，赋值给emp对象的id属性</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#&#123;username&#125;, #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entrydate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Emp emp)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisCrudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建员工对象</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        emp.setUsername(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        emp.setName(<span class="string">&quot;杰克&quot;</span>);</span><br><span class="line">        emp.setImage(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        emp.setGender((<span class="type">short</span>)<span class="number">1</span>);</span><br><span class="line">        emp.setJob((<span class="type">short</span>)<span class="number">1</span>);</span><br><span class="line">        emp.setEntrydate(LocalDate.of(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">        emp.setCreateTime(LocalDateTime.now());</span><br><span class="line">        emp.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        emp.setDeptId(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//调用添加方法</span></span><br><span class="line">        empMapper.insert(emp);</span><br><span class="line"></span><br><span class="line">        System.out.println(emp.getDeptId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-更新"><a href="#5-5-更新" class="headerlink" title="5.5 更新"></a>5.5 更新</h3><p>功能：修改员工信息</p><p><img src="/.com//image-20221212095605863.png" alt="image-20221212095605863"></p><blockquote><p>点击”编辑”按钮后，会查询所在行记录的员工信息，并把员工信息回显在修改员工的窗体上(下个知识点学习)</p><p>在修改员工的窗体上，可以修改的员工数据：用户名、员工姓名、性别、图像、职位、入职日期、归属部门</p><p>思考：在修改员工数据时，要以什么做为条件呢？</p><p>答案：员工id</p></blockquote><p>SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> username <span class="operator">=</span> <span class="string">&#x27;linghushaoxia&#x27;</span>, name <span class="operator">=</span> <span class="string">&#x27;令狐少侠&#x27;</span>, gender <span class="operator">=</span> <span class="number">1</span> , image <span class="operator">=</span> <span class="string">&#x27;1.jpg&#x27;</span> , job <span class="operator">=</span> <span class="number">2</span>, entrydate <span class="operator">=</span> <span class="string">&#x27;2012-01-01&#x27;</span>, dept_id <span class="operator">=</span> <span class="number">2</span>, update_time <span class="operator">=</span> <span class="string">&#x27;2022-10-01 12:12:12&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id修改员工信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> emp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Update(&quot;update emp set username=#&#123;username&#125;, name=#&#123;name&#125;, gender=#&#123;gender&#125;, image=#&#123;image&#125;, job=#&#123;job&#125;, entrydate=#&#123;entrydate&#125;, dept_id=#&#123;deptId&#125;, update_time=#&#123;updateTime&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Emp emp)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisCrudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要修改的员工信息</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        emp.setId(<span class="number">23</span>);</span><br><span class="line">        emp.setUsername(<span class="string">&quot;songdaxia&quot;</span>);</span><br><span class="line">        emp.setPassword(<span class="literal">null</span>);</span><br><span class="line">        emp.setName(<span class="string">&quot;老宋&quot;</span>);</span><br><span class="line">        emp.setImage(<span class="string">&quot;2.jpg&quot;</span>);</span><br><span class="line">        emp.setGender((<span class="type">short</span>)<span class="number">1</span>);</span><br><span class="line">        emp.setJob((<span class="type">short</span>)<span class="number">2</span>);</span><br><span class="line">        emp.setEntrydate(LocalDate.of(<span class="number">2012</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">        emp.setCreateTime(<span class="literal">null</span>);</span><br><span class="line">        emp.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        emp.setDeptId(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//调用方法，修改员工数据</span></span><br><span class="line">        empMapper.update(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-查询"><a href="#5-6-查询" class="headerlink" title="5.6 查询"></a>5.6 查询</h3><h4 id="5-6-1-根据ID查询"><a href="#5-6-1-根据ID查询" class="headerlink" title="5.6.1 根据ID查询"></a>5.6.1 根据ID查询</h4><p>在员工管理的页面中，当我们进行更新数据时，会点击 “编辑” 按钮，然后此时会发送一个请求到服务端，会根据Id查询该员工信息，并将员工数据回显在页面上。</p><p><img src="/.com//image-20221212101331292-1715613343041-252.png" alt="image-20221212101331292"> </p><p>SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp;</span><br></pre></td></tr></table></figure><p>接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisCrudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> empMapper.getById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p><img src="/.com//image-20221212103004961-1715613343041-253.png" alt="image-20221212103004961"></p><p>而在测试的过程中，我们会发现有几个字段(deptId、createTime、updateTime)是没有数据值的</p></blockquote><h4 id="5-6-2-数据封装"><a href="#5-6-2-数据封装" class="headerlink" title="5.6.2 数据封装"></a>5.6.2 数据封装</h4><p>我们看到查询返回的结果中大部分字段是有值的，但是deptId，createTime，updateTime这几个字段是没有值的，而数据库中是有对应的字段值的，这是为什么呢？</p><p><img src="/.com//image-20221212103124490.png" alt="image-20221212103124490"></p><p>原因如下： </p><ul><li>实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。</li><li>如果实体类属性名和数据库表查询返回的字段名不一致，不能自动封装。</li></ul><p> 解决方案：</p><ol><li>起别名</li><li>结果映射</li><li>开启驼峰命名</li></ol><p><strong>起别名</strong>：在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select id, username, password, name, gender, image, job, entrydate, &quot; +</span></span><br><span class="line"><span class="meta">        &quot;dept_id AS deptId, create_time AS createTime, update_time AS updateTime &quot; +</span></span><br><span class="line"><span class="meta">        &quot;from emp &quot; +</span></span><br><span class="line"><span class="meta">        &quot;where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>再次执行测试类：</p><p><img src="/.com//image-20221212111027396-1715613343041-255.png" alt="image-20221212111027396"></p></blockquote><p><strong>手动结果映射</strong>：通过 @Results及@Result 进行手动结果映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results(&#123;@Result(column = &quot;dept_id&quot;, property = &quot;deptId&quot;),</span></span><br><span class="line"><span class="meta">          @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;),</span></span><br><span class="line"><span class="meta">          @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;)&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>@Results源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Results &#123;</span><br><span class="line">String <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">Result[] value() <span class="keyword">default</span> &#123;&#125;;  <span class="comment">//Result类型的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Result源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Repeatable(Results.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Result &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;<span class="comment">//表示当前列是否为主键（true:是主键）</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">column</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;<span class="comment">//指定表中字段名</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">property</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;<span class="comment">//指定类中属性名</span></span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; javaType() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">JdbcType <span class="title function_">jdbcType</span><span class="params">()</span> <span class="keyword">default</span> JdbcType.UNDEFINED;</span><br><span class="line"></span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">TypeHandler</span>&gt; typeHandler() <span class="keyword">default</span> UnknownTypeHandler.class;</span><br><span class="line"></span><br><span class="line">One <span class="title function_">one</span><span class="params">()</span> <span class="keyword">default</span> <span class="meta">@One</span>;</span><br><span class="line"></span><br><span class="line">Many <span class="title function_">many</span><span class="params">()</span> <span class="keyword">default</span> <span class="meta">@Many</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>**开启驼峰命名(推荐)**：如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射</p><blockquote><p>驼峰命名规则：   abc_xyz    &#x3D;&gt;   abcXyz</p><ul><li>表中字段名：abc_xyz</li><li>类中属性名：abcXyz</li></ul></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在application.properties中添加：</span></span><br><span class="line"><span class="attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><blockquote><p>要使用驼峰命名前提是 实体类的属性 与 数据库表中的字段名严格遵守驼峰命名。</p></blockquote><h4 id="5-6-3-条件查询"><a href="#5-6-3-条件查询" class="headerlink" title="5.6.3 条件查询"></a>5.6.3 条件查询</h4><p>在员工管理的列表页面中，我们需要根据条件查询员工信息，查询条件包括：姓名、性别、入职时间。 </p><p><img src="/.com//image-20221212113422924.png" alt="image-20221212113422924"></p><p>通过页面原型以及需求描述我们要实现的查询：</p><ul><li>姓名：要求支持模糊匹配</li><li>性别：要求精确匹配</li><li>入职时间：要求进行范围查询</li><li>根据最后修改时间进行降序排序</li></ul><p>SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time </span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> gender <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line">      <span class="keyword">and</span> entrydate <span class="keyword">between</span> <span class="string">&#x27;2010-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2020-01-01 &#x27;</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> update_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>接口方法：</p><ul><li>方式一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from emp &quot; +</span></span><br><span class="line"><span class="meta">            &quot;where name like &#x27;%$&#123;name&#125;%&#x27; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;and gender = #&#123;gender&#125; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;and entrydate between #&#123;begin&#125; and #&#123;end&#125; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;order by update_time desc&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">(String name, Short gender, LocalDate begin, LocalDate end)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="/.com//image-20221212115149151-1715613343041-258.png" alt="image-20221212115149151"></p><p>以上方式注意事项：</p><ol><li><p>方法中的形参名和SQL语句中的参数占位符名保持一致</p></li><li><p>模糊查询使用${…}进行字符串拼接，这种方式呢，由于是字符串拼接，并不是预编译的形式，所以效率不高、且存在sql注入风险。</p></li></ol></blockquote><ul><li>方式二（解决SQL注入风险）<ul><li>使用MySQL提供的字符串拼接函数：concat(‘%’ , ‘关键字’ , ‘%’)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from emp &quot; +</span></span><br><span class="line"><span class="meta">            &quot;where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) &quot; +</span></span><br><span class="line"><span class="meta">            &quot;and gender = #&#123;gender&#125; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;and entrydate between #&#123;begin&#125; and #&#123;end&#125; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;order by update_time desc&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">(String name, Short gender, LocalDate begin, LocalDate end)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>执行结果：生成的SQL都是预编译的SQL语句（性能高、安全）</p><p><img src="/.com//image-20221212120006242-1715613343041-257.png" alt="image-20221212120006242"></p></blockquote><h4 id="5-6-4-参数名说明"><a href="#5-6-4-参数名说明" class="headerlink" title="5.6.4 参数名说明"></a>5.6.4 参数名说明</h4><p>在上面我们所编写的条件查询功能中，我们需要保证接口中方法的形参名和SQL语句中的参数占位符名相同。</p><blockquote><p>当方法中的形参名和SQL语句中的占位符参数名不相同时，就会出现以下问题：</p><p><img src="/.com//image-20221212150611796.png" alt="image-20221212150611796"></p></blockquote><p>参数名在不同的SpringBoot版本中，处理方案还不同：</p><ul><li>在springBoot的2.x版本（保证参数名一致）</li></ul><p><img src="/.com//image-20221212151156273-1715613343041-260.png" alt="image-20221212151156273"></p><blockquote><p>springBoot的父工程对compiler编译插件进行了默认的参数parameters配置，使得在编译时，会在生成的字节码文件中保留原方法形参的名称，所以#{…}里面可以直接通过形参名获取对应的值</p><p><img src="/.com//image-20221212151411154-1715613343041-261.png" alt="image-20221212151411154"></p></blockquote><ul><li>在springBoot的1.x版本&#x2F;单独使用mybatis（使用@Param注解来指定SQL语句中的参数名）</li></ul><p><img src="/.com//image-20221212151628715-1715613343041-262.png" alt="image-20221212151628715"></p><blockquote><p>在编译时，生成的字节码文件当中，不会保留Mapper接口中方法的形参名称，而是使用var1、var2、…这样的形参名字，此时要获取参数值时，就要通过@Param注解来指定SQL语句中的参数名</p><p><img src="/.com//image-20221212151736274-1715613343041-263.png" alt="image-20221212151736274"></p></blockquote><ol start="2"><li>Mybatis的XML配置文件</li></ol><p>Mybatis的开发有两种方式：</p><ol><li>注解</li><li>XML</li></ol><h2 id="6-XML"><a href="#6-XML" class="headerlink" title="6.XML"></a>6.XML</h2><h3 id="6-1-XML配置文件规范"><a href="#6-1-XML配置文件规范" class="headerlink" title="6.1 XML配置文件规范"></a>6.1 XML配置文件规范</h3><p>使用Mybatis的注解方式，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句，也就是将SQL语句写在XML配置文件中。</p><p>在Mybatis中使用XML映射文件方式开发，需要符合一定的规范：</p><ul><li><p><strong>XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）</strong></p></li><li><p><strong>XML映射文件的namespace属性为Mapper接口全限定名一致</strong></p></li><li><p><strong>XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致。</strong></p></li></ul><p><img src="/.com//image-20221212153529732.png" alt="image-20221212153529732"></p><blockquote><p>&lt;select&gt;标签：就是用于编写select查询语句的。</p><ul><li>resultType属性，指的是查询返回的单条记录所封装的类型。</li></ul></blockquote><p><img src="/.com//image-20240309163347721-1715613343041-265.png" alt="image-20240309163347721"></p><p>由于XML映射文件中的id绑定的list方法 而list方法封装的是Emp  所以 resultType为Emp的全类名</p><p><img src="/.com//image-20240309163504652-1715613343041-266.png" alt="image-20240309163504652"></p><h3 id="6-2-XML配置文件实现"><a href="#6-2-XML配置文件实现" class="headerlink" title="6.2 XML配置文件实现"></a>6.2 XML配置文件实现</h3><p>第1步：创建XML映射文件</p><p><img src="/.com//image-20221212154908306-1715613343041-267.png" alt="image-20221212154908306"></p><p><img src="/.com//image-20221212155304635-1715613343041-268.png" alt="image-20221212155304635"></p><p><img src="/.com//image-20221212155544404-1715613343041-269.png" alt="image-20221212155544404"></p><p>第2步：编写XML映射文件</p><blockquote><p>xml映射文件中的dtd约束，直接从mybatis官网复制即可</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置：XML映射文件的namespace属性为Mapper接口全限定名</p><p><img src="/.com//image-20221212160316644-1715613343041-270.png" alt="image-20221212160316644"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置：XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致</p><p><img src="/.com//image-20221212163528787.png" alt="image-20221212163528787"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--查询操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">        where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">              and gender = #&#123;gender&#125;</span><br><span class="line">              and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">        order by update_time desc</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>运行测试类，执行结果：</p><p><img src="/.com//image-20221212163719534-1715613343041-272.png" alt="image-20221212163719534"></p></blockquote><h3 id="6-3-MybatisX的使用"><a href="#6-3-MybatisX的使用" class="headerlink" title="6.3 MybatisX的使用"></a>6.3 MybatisX的使用</h3><p>MybatisX是一款基于IDEA的快速开发Mybatis的插件，为效率而生。</p><p>MybatisX的安装：</p><p><img src="/.com//image-20221213120923252-1715613343041-273.png" alt="image-20221213120923252"></p><p>可以通过MybatisX快速定位：</p><p><img src="/.com//image-20221213121521406.png" alt="image-20221213121521406"></p><blockquote><p>MybatisX的使用在后续学习中会继续分享</p></blockquote><p>学习了Mybatis中XML配置文件的开发方式了，大家可能会存在一个疑问：到底是使用注解方式开发还是使用XML方式开发？</p><blockquote><p>官方说明：<a href="https://mybatis.net.cn/getting-started.html">https://mybatis.net.cn/getting-started.html</a></p><p><img src="/.com//image-20220901173948645.png" alt="image-20220901173948645"> </p></blockquote><p><strong>结论：</strong>*<em><strong>使用Mybatis的注解，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句</strong>。</em>*</p><h2 id="7-Mybatis动态SQL"><a href="#7-Mybatis动态SQL" class="headerlink" title="7. Mybatis动态SQL"></a>7. Mybatis动态SQL</h2><h3 id="7-1-什么是动态SQL"><a href="#7-1-什么是动态SQL" class="headerlink" title="7.1 什么是动态SQL"></a>7.1 什么是动态SQL</h3><p>在页面原型中，列表上方的条件是动态的，是可以不传递的，也可以只传递其中的1个或者2个或者全部。</p><p><img src="/.com//image-20220901172933012.png"></p><p><img src="/.com//image-20220901173203491-1715613343041-277.png" alt="image-20220901173203491"></p><p>而在我们刚才编写的SQL语句中，我们会看到，我们将三个条件直接写死了。 如果页面只传递了参数姓名name 字段，其他两个字段 性别 和 入职时间没有传递，那么这两个参数的值就是null。</p><p>此时，执行的SQL语句为：</p><p><img src="/.com//image-20220901173431554-1715613343041-278.png" alt="image-20220901173431554"> </p><p>这个查询结果是不正确的。正确的做法应该是：传递了参数，再组装这个查询条件；如果没有传递参数，就不应该组装这个查询条件。</p><p>比如：如果姓名输入了”张”, 对应的SQL为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> update_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>如果姓名输入了”张”,，性别选择了”男”，则对应的SQL为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span> <span class="keyword">and</span> gender <span class="operator">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> update_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>SQL语句会随着用户的输入或外部条件的变化而变化，我们称为：<strong>动态SQL</strong>。</p><p><img src="/.com//image-20221213122623278-1715613343041-279.png" alt="image-20221213122623278"></p><p>在Mybatis中提供了很多实现动态SQL的标签，我们学习Mybatis中的动态SQL就是掌握这些动态SQL标签。</p><h3 id="7-2-动态SQL-if"><a href="#7-2-动态SQL-if" class="headerlink" title="7.2 动态SQL-if"></a>7.2 动态SQL-if</h3><p><code>&lt;if&gt;</code>：用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;条件表达式&quot;</span>&gt;</span></span><br><span class="line">   要拼接的sql语句</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，我们就通过<code>&lt;if&gt;</code>标签来改造之前条件查询的案例。</p><h4 id="7-2-1-条件查询"><a href="#7-2-1-条件查询" class="headerlink" title="7.2.1 条件查询"></a>7.2.1 条件查询</h4><p>示例：把SQL语句改造为动态SQL方式</p><ul><li>原有的SQL语句</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">        where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">              and gender = #&#123;gender&#125;</span><br><span class="line">              and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">        order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>动态SQL语句</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">        where</span><br><span class="line">    </span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                 name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">                 and gender = #&#123;gender&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">                 and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//性别数据为null、开始时间和结束时间也为null</span></span><br><span class="line">    List&lt;Emp&gt; list = empMapper.list(<span class="string">&quot;张&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span>(Emp emp : list)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行的SQL语句： </p><p><img src="/.com//image-20221213140353285-1715613343041-280.png" alt="image-20221213140353285"></p></blockquote><p>下面呢，我们修改测试方法中的代码，再次进行测试，观察执行情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//姓名为null</span></span><br><span class="line">    List&lt;Emp&gt; list = empMapper.list(<span class="literal">null</span>, (<span class="type">short</span>)<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span>(Emp emp : list)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/.com//image-20221213141139015-1715613343041-281.png" alt="image-20221213141139015"> </p><p><img src="/.com//image-20221213141253355-1715613343041-282.png" alt="image-20221213141253355"> </p><p>再次修改测试方法中的代码，再次进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//传递的数据全部为null</span></span><br><span class="line">    List&lt;Emp&gt; list = empMapper.list(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span>(Emp emp : list)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的SQL语句：</p><p><img src="/.com//image-20221213143854434-1715613343041-283.png" alt="image-20221213143854434"></p><p>以上问题的解决方案：使用<code>&lt;where&gt;</code>标签代替SQL语句中的where关键字</p><ul><li><code>&lt;where&gt;</code>只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- if做为where标签的子元素 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                 and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">                 and gender = #&#123;gender&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">                 and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">        order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//只有性别</span></span><br><span class="line">    List&lt;Emp&gt; list = empMapper.list(<span class="literal">null</span>, (<span class="type">short</span>)<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span>(Emp emp : list)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行的SQL语句：</p><p><img src="/.com//image-20221213141909455-1715613343041-284.png" alt="image-20221213141909455"></p></blockquote><h4 id="7-2-2-更新员工"><a href="#7-2-2-更新员工" class="headerlink" title="7.2.2 更新员工"></a>7.2.2 更新员工</h4><p>案例：完善更新员工功能，修改为动态更新员工数据信息</p><ul><li>动态更新员工信息，如果更新时传递有值，则更新；如果更新时没有传递值，则不更新</li><li>解决方案：动态SQL</li></ul><p>修改Mapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="comment">//删除@Update注解编写的SQL语句</span></span><br><span class="line">    <span class="comment">//update操作的SQL语句编写在Mapper映射文件中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Emp emp)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Mapper映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--更新操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        update emp</span><br><span class="line">        set</span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">                username=#&#123;username&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                name=#&#123;name&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">                gender=#&#123;gender&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;image != null&quot;</span>&gt;</span></span><br><span class="line">                image=#&#123;image&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span></span><br><span class="line">                job=#&#123;job&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;entrydate != null&quot;</span>&gt;</span></span><br><span class="line">                entrydate=#&#123;entrydate&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptId != null&quot;</span>&gt;</span></span><br><span class="line">                dept_id=#&#123;deptId&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateTime != null&quot;</span>&gt;</span></span><br><span class="line">                update_time=#&#123;updateTime&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要修改的员工信息</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        emp.setId(<span class="number">20</span>);</span><br><span class="line">        emp.setUsername(<span class="string">&quot;Tom111&quot;</span>);</span><br><span class="line">        emp.setName(<span class="string">&quot;汤姆111&quot;</span>);</span><br><span class="line"></span><br><span class="line">        emp.setUpdateTime(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，修改员工数据</span></span><br><span class="line">        empMapper.update(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行的SQL语句：</p><p><img src="/.com//image-20221213152533851-1715613343041-285.png" alt="image-20221213152533851"></p></blockquote><p>再次修改测试方法，观察SQL语句执行情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要修改的员工信息</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        emp.setId(<span class="number">20</span>);</span><br><span class="line">        emp.setUsername(<span class="string">&quot;Tom222&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//调用方法，修改员工数据</span></span><br><span class="line">        empMapper.update(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行的SQL语句：</p><p><img src="/.com//image-20221213152850322-1715613343041-286.png" alt="image-20221213152850322"></p></blockquote><p>以上问题的解决方案：使用<code>&lt;set&gt;</code>标签代替SQL语句中的set关键字</p><ul><li><code>&lt;set&gt;</code>：动态的在SQL语句中插入set关键字，并会删掉额外的逗号。（用于update语句中）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--更新操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        update emp</span><br><span class="line">        <span class="comment">&lt;!-- 使用set标签，代替update语句中的set关键字 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">                username=#&#123;username&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                name=#&#123;name&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">                gender=#&#123;gender&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;image != null&quot;</span>&gt;</span></span><br><span class="line">                image=#&#123;image&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span></span><br><span class="line">                job=#&#123;job&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;entrydate != null&quot;</span>&gt;</span></span><br><span class="line">                entrydate=#&#123;entrydate&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptId != null&quot;</span>&gt;</span></span><br><span class="line">                dept_id=#&#123;deptId&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateTime != null&quot;</span>&gt;</span></span><br><span class="line">                update_time=#&#123;updateTime&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>再次执行测试方法，执行的SQL语句：</p><p><img src="/.com//image-20221213153329553-1715613343041-287.png" alt="image-20221213153329553"></p></blockquote><p><strong>小结</strong></p><ul><li><p><code>&lt;if&gt;</code></p><ul><li><p>用于判断条件是否成立，如果条件为true，则拼接SQL</p></li><li><p>形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span> … <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>&lt;where&gt;</code></p><ul><li>where元素只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR</li></ul></li><li><p><code>&lt;set&gt;</code></p><ul><li>动态地在行首插入 SET 关键字，并会删掉额外的逗号。（用在update语句中）</li></ul></li></ul><h4 id="7-3-动态SQL-foreach"><a href="#7-3-动态SQL-foreach" class="headerlink" title="7.3 动态SQL-foreach"></a>7.3 动态SQL-foreach</h4><p>案例：员工删除功能（既支持删除单条记录，又支持批量删除）</p><p><img src="/.com//image-20220901181751004-1715613343041-288.png" alt="image-20220901181751004"> </p><p>SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from emp where id in (1,2,3);</span><br></pre></td></tr></table></figure><p>Mapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="comment">//批量删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(List&lt;Integer&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML映射文件：</p><ul><li>使用<code>&lt;foreach&gt;</code>遍历deleteByIds方法中传递的参数ids集合</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;集合名称&quot;</span> <span class="attr">item</span>=<span class="string">&quot;集合遍历出来的元素/项&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;每一次遍历使用的分隔符&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">open</span>=<span class="string">&quot;遍历开始前拼接的片段&quot;</span> <span class="attr">close</span>=<span class="string">&quot;遍历结束后拼接的片段&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--删除操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">        delete from emp where id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span> </span><br></pre></td></tr></table></figure><blockquote><p><img src="/.com//image-20221213165710141-1715613343041-289.png" alt="image-20221213165710141"></p></blockquote><blockquote><p>执行的SQL语句：</p><p><img src="/.com//image-20221213164957636-1715613343041-290.png" alt="image-20221213164957636"></p></blockquote><h4 id="7-4-动态SQL-sql-include"><a href="#7-4-动态SQL-sql-include" class="headerlink" title="7.4 动态SQL-sql&amp;include"></a>7.4 动态SQL-sql&amp;include</h4><p>问题分析：</p><ul><li>在xml映射文件中配置的SQL，有时可能会存在很多重复的片段，此时就会存在很多冗余的代码</li></ul><p><img src="/.com//image-20220901182204358-1715613343041-291.png"></p><p><img src="/.com//image-20220901182249421-1715613343041-292.png"></p><p>我们可以对重复的代码片段进行抽取，将其通过<code>&lt;sql&gt;</code>标签封装到一个SQL片段，然后再通过<code>&lt;include&gt;</code>标签进行引用。</p><ul><li><p><code>&lt;sql&gt;</code>：定义可重用的SQL片段</p></li><li><p><code>&lt;include&gt;</code>：通过属性refid，指定包含的SQL片段</p></li></ul><p><img src="/.com//image-20221213171244796-1715613343041-293.png" alt="image-20221213171244796"></p><p>SQL片段： 抽取重复的代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;commonSelect&quot;</span>&gt;</span></span><br><span class="line"> select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后通过<code>&lt;include&gt;</code> 标签在原来抽取的地方进行引用。操作如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">![image-20220826161735076](./JavaWeb/image-20220826161735076.png)<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;commonSelect&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">            and gender = #&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">            and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通常当我们访问某一个网页时 登陆后才能访问后端操作数据 但我们目前实现的这个 不管登不登陆都可以访问后端操作数据</span><br></pre></td></tr></table></figure><p>为什么会出现这个问题 是因为我们缺少了最重要的一步：<strong>登录校验</strong></p><p><img src="/.com//image-20230105180811717-1715613343041-294.png"></p><p>什么是登录校验？</p><ul><li><p>所谓登录校验，指的是我们在服务器端接收到浏览器发送过来的请求之后，首先我们要对请求进行校验。先要校验一下用户登录了没有，如果用户已经登录了，就直接执行对应的业务操作就可以了；如果用户没有登录，此时就不允许他执行相关的业务操作，直接给前端响应一个错误的结果，最终跳转到登录页面，要求他登录成功之后，再来访问对应的数据。</p></li><li><p><img src="/.com//image-20230105194710533-1715613343041-295.png"></p><p>那应该怎么来实现登录校验的操作呢？具体的实现思路可以分为两部分：</p><ol><li>在员工登录成功后，需要将用户登录成功的信息存起来，记录用户已经登录成功的标记。</li><li>在浏览器发起请求时，需要在服务端进行统一拦截，拦截后进行登录校验。</li></ol></li></ul><p>我们要完成以上操作，会涉及到web开发中的两个技术：</p><ol><li>会话技术</li><li>统一拦截技术</li></ol><h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><p>什么是会话？</p><ul><li><p>在我们日常生活当中，会话指的就是谈话、交谈。</p></li><li><p>在web开发当中，会话指的就是浏览器与服务器之间的一次连接，我们就称为一次会话。</p></li></ul><blockquote><p>在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p><p>比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）</p><ul><li>第1次：访问的是登录的接口，完成登录操作</li><li>第2次：访问的是部门管理接口，查询所有部门数据</li><li>第3次：访问的是员工管理接口，查询员工数据</li></ul><p>只要浏览器和服务器都没有关闭，以上3次请求都属于一次会话当中完成的。</p></blockquote><p><img src="/.com//image-20230105203827355-1715613343041-296.png" alt="image-20230105203827355"></p><p>会话跟踪技术有两种：</p><ol><li>Cookie（客户端会话跟踪技术）<ul><li>数据存储在客户端浏览器当中</li></ul></li><li>Session（服务端会话跟踪技术）<ul><li>数据存储在储在服务端</li></ul></li><li>令牌技术</li></ol><h3 id="方案一-Cookie"><a href="#方案一-Cookie" class="headerlink" title="方案一 - Cookie"></a>方案一 - Cookie</h3><p>cookie 是客户端会话跟踪技术，它是存储在客户端浏览器的，我们使用 cookie 来跟踪会话，我们就可以在浏览器第一次发起请求来请求服务器的时候，我们在服务器端来设置一个cookie。</p><p>比如第一次请求了登录接口，登录接口执行完成之后，我们就可以设置一个cookie，在 cookie 当中我们就可以来存储用户相关的一些数据信息。比如我可以在 cookie 当中来存储当前登录用户的用户名，用户的ID。</p><p>服务器端在给客户端在响应数据的时候，会<strong>自动</strong>的将 cookie 响应给浏览器，浏览器接收到响应回来的 cookie 之后，会<strong>自动</strong>的将 cookie 的值存储在浏览器本地。接下来在后续的每一次请求当中，都会将浏览器本地所存储的 cookie <strong>自动</strong>地携带到服务端。</p><p><img src="/.com//image-20230112101901417-1715613343041-297.png" alt="image-20230112101901417"> </p><p>接下来在服务端我们就可以获取到 cookie 的值。我们可以去判断一下这个 cookie 的值是否存在，如果不存在这个cookie，就说明客户端之前是没有访问登录接口的；如果存在 cookie 的值，就说明客户端之前已经登录完成了。这样我们就可以基于 cookie 在同一次会话的不同请求之间来共享数据。</p><p>我刚才在介绍流程的时候，用了 3 个自动：</p><ul><li><p>服务器会 <strong>自动</strong> 的将 cookie 响应给浏览器。</p></li><li><p>浏览器接收到响应回来的数据之后，会 <strong>自动</strong> 的将 cookie 存储在浏览器本地。</p></li><li><p>在后续的请求当中，浏览器会 <strong>自动</strong> 的将 cookie 携带到服务器端。</p></li></ul><p><strong>为什么这一切都是自动化进行的？</strong></p><p>是因为 cookie 它是 HTP 协议当中所支持的技术，而各大浏览器厂商都支持了这一标准。在 HTTP 协议官方给我们提供了一个响应头和请求头：</p><ul><li><p>响应头 Set-Cookie ：设置Cookie数据的</p></li><li><p>请求头 Cookie：携带Cookie数据的</p></li></ul><p><img src="/.com//image-20230112101804878-1715613343041-298.png" alt="image-20230112101804878"> </p><p><strong>代码测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置Cookie</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/c1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">cookie1</span><span class="params">(HttpServletResponse response)</span>&#123;</span><br><span class="line">        response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;login_username&quot;</span>,<span class="string">&quot;itheima&quot;</span>)); <span class="comment">//设置Cookie/响应Cookie</span></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Cookie</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/c2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">cookie2</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cookie.getName().equals(<span class="string">&quot;login_username&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;login_username: &quot;</span>+cookie.getValue()); <span class="comment">//输出name为login_username的cookie</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>A. 访问c1接口，设置Cookie，<a href="http://localhost:8080/c1">http://localhost:8080/c1</a></p><p><img src="/.com//image-20230112105410076.png" alt="image-20230112105410076"> </p><p>我们可以看到，设置的cookie，通过<strong>响应头Set-Cookie</strong>响应给浏览器，并且浏览器会将Cookie，存储在浏览器端。</p><p><img src="/.com//image-20230112105538131-1715613343041-300.png" alt="image-20230112105538131"> </p><p>B. 访问c2接口 <a href="http://localhost:8080/c2%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%9A%84%E5%B0%86Cookie%E6%90%BA%E5%B8%A6%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%8C%E6%98%AF%E9%80%9A%E8%BF%87**%E8%AF%B7%E6%B1%82%E5%A4%B4Cookie**%EF%BC%8C%E6%90%BA%E5%B8%A6%E7%9A%84%E3%80%82">http://localhost:8080/c2，此时浏览器会自动的将Cookie携带到服务端，是通过**请求头Cookie**，携带的。</a></p><p><img src="/.com//image-20230112105658486.png" alt="image-20230112105658486"> </p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul><li>优点：HTTP协议中支持的技术（像Set-Cookie 响应头的解析以及 Cookie 请求头数据的携带，都是浏览器自动进行的，是无需我们手动操作的）</li><li>缺点：<ul><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>不安全，用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><blockquote><p>跨域介绍：</p><p>​ <img src="/.com//image-20230112103840467-1715613343041-302.png" alt="image-20230112103840467" style="zoom:80%;"> </p><ul><li>现在的项目，大部分都是前后端分离的，前后端最终也会分开部署，前端部署在服务器 192.168.150.200 上，端口 80，后端部署在 192.168.150.100上，端口 8080</li><li>我们打开浏览器直接访问前端工程，访问url：<a href="http://192.168.150.200/login.html">http://192.168.150.200/login.html</a></li><li>然后在该页面发起请求到服务端，而服务端所在地址不再是localhost，而是服务器的IP地址192.168.150.100，假设访问接口地址为：<a href="http://192.168.150.100:8080/login">http://192.168.150.100:8080/login</a></li><li>那此时就存在跨域操作了，因为我们是在 <a href="http://192.168.150.200/login.html">http://192.168.150.200/login.html</a> 这个页面上访问了<a href="http://192.168.150.100:8080/login">http://192.168.150.100:8080/login</a> 接口</li><li>此时如果服务器设置了一个Cookie，这个Cookie是不能使用的，因为Cookie无法跨域</li></ul><p>区分跨域的维度：</p><ul><li>协议</li><li>IP&#x2F;协议</li><li>端口</li></ul><p>只要上述的三个维度有任何一个维度不同，那就是跨域操作</p><p>举例：</p><p>​<a href="http://192.168.150.200/login.html">http://192.168.150.200/login.html</a> ———-&gt; <a href="https://192.168.150.200/login">https://192.168.150.200/login</a>   [协议不同，跨域]</p><p>​<a href="http://192.168.150.200/login.html">http://192.168.150.200/login.html</a> ———-&gt; <a href="http://192.168.150.100/login">http://192.168.150.100/login</a>     [IP不同，跨域]</p><p>​<a href="http://192.168.150.200/login.html">http://192.168.150.200/login.html</a> ———-&gt; <a href="http://192.168.150.200:8080/login">http://192.168.150.200:8080/login</a>   [端口不同，跨域]</p><p>​    <a href="http://192.168.150.200/login.html">http://192.168.150.200/login.html</a> ———-&gt; <a href="http://192.168.150.200/login">http://192.168.150.200/login</a>     [不跨域]   </p></blockquote><h3 id="方案二-Session"><a href="#方案二-Session" class="headerlink" title="方案二 - Session"></a>方案二 - Session</h3><p>前面介绍的时候，我们提到Session，它是服务器端会话跟踪技术，所以它是存储在服务器端的。而 Session 的底层其实就是基于我们刚才所介绍的 Cookie 来实现的。</p><ul><li><p>获取Session</p><p><img src="/.com//image-20230112105938545-1715613343041-303.png" alt="image-20230112105938545"> </p><p>如果我们现在要基于 Session 来进行会话跟踪，浏览器在第一次请求服务器的时候，我们就可以直接在服务器当中来获取到会话对象Session。如果是第一次请求Session ，会话对象是不存在的，这个时候服务器会自动的创建一个会话对象Session 。而每一个会话对象Session ，它都有一个ID（示意图中Session后面括号中的1，就表示ID），我们称之为 Session 的ID。</p></li><li><p>响应Cookie (JSESSIONID)</p><p><img src="/.com//image-20230112110441075-1715613343041-304.png" alt="image-20230112110441075"> </p><p>接下来，服务器端在给浏览器响应数据的时候，它会将 Session 的 ID 通过 Cookie 响应给浏览器。其实在响应头当中增加了一个 Set-Cookie 响应头。这个  Set-Cookie  响应头对应的值是不是cookie？ cookie 的名字是固定的 JSESSIONID 代表的服务器端会话对象 Session 的 ID。浏览器会自动识别这个响应头，然后自动将Cookie存储在浏览器本地。</p></li><li><p>查找Session</p><p><img src="/.com//image-20230112101943835-1715613343041-305.png" alt="image-20230112101943835"> </p><p>接下来，在后续的每一次请求当中，都会将 Cookie 的数据获取出来，并且携带到服务端。接下来服务器拿到JSESSIONID这个 Cookie 的值，也就是 Session 的ID。拿到 ID 之后，就会从众多的 Session 当中来找到当前请求对应的会话对象Session。</p><p>这样我们是不是就可以通过 Session 会话对象在同一次会话的多次请求之间来共享数据了？好，这就是基于 Session 进行会话跟踪的流程。</p></li></ul><p><strong>代码测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/s1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">session1</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;HttpSession-s1: &#123;&#125;&quot;</span>, session.hashCode());</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">&quot;loginUser&quot;</span>, <span class="string">&quot;tom&quot;</span>); <span class="comment">//往session中存储数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/s2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">session2</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        log.info(<span class="string">&quot;HttpSession-s2: &#123;&#125;&quot;</span>, session.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">loginUser</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;loginUser&quot;</span>); <span class="comment">//从session中获取数据</span></span><br><span class="line">        log.info(<span class="string">&quot;loginUser: &#123;&#125;&quot;</span>, loginUser);</span><br><span class="line">        <span class="keyword">return</span> Result.success(loginUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A. 访问 s1 接口，<a href="http://localhost:8080/s1">http://localhost:8080/s1</a></p><p><img src="/.com//image-20230112111004447.png" alt="image-20230112111004447"> </p><p>请求完成之后，在响应头中，就会看到有一个Set-Cookie的响应头，里面响应回来了一个Cookie，就是JSESSIONID，这个就是服务端会话对象 Session 的ID。</p><p>B. 访问 s2 接口，<a href="http://localhost:8080/s2">http://localhost:8080/s2</a></p><p><img src="/.com//image-20230112111137207.png" alt="image-20230112111137207"> </p><p>接下来，在后续的每次请求时，都会将Cookie的值，携带到服务端，那服务端呢，接收到Cookie之后，会自动的根据JSESSIONID的值，找到对应的会话对象Session。</p><p>那经过这两步测试，大家也会看到，在控制台中输出如下日志：</p><p><img src="/.com//image-20230112111328117-1715613343041-308.png" alt="image-20230112111328117"> </p><p>两次请求，获取到的Session会话对象的hashcode是一样的，就说明是同一个会话对象。而且，第一次请求时，往Session会话对象中存储的值，第二次请求时，也获取到了。 那这样，我们就可以通过Session会话对象，在同一个会话的多次请求之间来进行数据共享了。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul><li>优点：Session是存储在服务端的，安全</li><li>缺点：<ul><li>服务器集群环境下无法直接使用Session</li><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><blockquote><p>PS：Session 底层是基于Cookie实现的会话跟踪，如果Cookie不可用，则该方案，也就失效了。</p></blockquote><blockquote><p>服务器集群环境为何无法使用Session？</p><p>​<img src="/.com//image-20230112112557480-1715613343042-309.png" alt="image-20230112112557480" style="zoom:67%;"> </p><ul><li>首先第一点，我们现在所开发的项目，一般都不会只部署在一台服务器上，因为一台服务器会存在一个很大的问题，就是单点故障。所谓单点故障，指的就是一旦这台服务器挂了，整个应用都没法访问了。</li></ul><p>​    <img src="/.com//image-20230112112740131-1715613343042-310.png" alt="image-20230112112740131"> </p><ul><li><p>所以在现在的企业项目开发当中，最终部署的时候都是以集群的形式来进行部署，也就是同一个项目它会部署多份。比如这个项目我们现在就部署了 3 份。</p></li><li><p>而用户在访问的时候，到底访问这三台其中的哪一台？其实用户在访问的时候，他会访问一台前置的服务器，我们叫负载均衡服务器，我们在后面项目当中会详细讲解。目前大家先有一个印象负载均衡服务器，它的作用就是将前端发起的请求均匀的分发给后面的这三台服务器。</p><p><img src="/.com//image-20230112113558810-1715613343042-311.png" alt="image-20230112113558810"> </p></li><li><p>此时假如我们通过 session 来进行会话跟踪，可能就会存在这样一个问题。用户打开浏览器要进行登录操作，此时会发起登录请求。登录请求到达负载均衡服务器，将这个请求转给了第一台 Tomcat 服务器。</p><p>Tomcat 服务器接收到请求之后，要获取到会话对象session。获取到会话对象 session 之后，要给浏览器响应数据，最终在给浏览器响应数据的时候，就会携带这么一个 cookie 的名字，就是 JSESSIONID ，下一次再请求的时候，是不是又会将 Cookie 携带到服务端？</p><p>好。此时假如又执行了一次查询操作，要查询部门的数据。这次请求到达负载均衡服务器之后，负载均衡服务器将这次请求转给了第二台 Tomcat 服务器，此时他就要到第二台 Tomcat 服务器当中。根据JSESSIONID 也就是对应的 session 的 ID 值，要找对应的 session 会话对象。</p><p>我想请问在第二台服务器当中有没有这个ID的会话对象 Session， 是没有的。此时是不是就出现问题了？我同一个浏览器发起了 2 次请求，结果获取到的不是同一个会话对象，这就是Session这种会话跟踪方案它的缺点，在服务器集群环境下无法直接使用Session。</p></li></ul></blockquote><p>大家会看到上面这两种传统的会话技术，在现在的企业开发当中是不是会存在很多的问题。 为了解决这些问题，在现在的企业开发当中，基本上都会采用第三种方案，通过令牌技术来进行会话跟踪。接下来我们就来介绍一下令牌技术，来看一下令牌技术又是如何跟踪会话的。</p><h3 id="方案三-令牌技术"><a href="#方案三-令牌技术" class="headerlink" title="方案三 - 令牌技术"></a>方案三 - 令牌技术</h3><p>这里我们所提到的令牌，其实它就是一个用户身份的标识，看似很高大上，很神秘，其实本质就是一个字符串。</p><p><img src="/.com//image-20230112102022634-1715613343042-312.png" alt="image-20230112102022634"> </p><p>如果通过令牌技术来跟踪会话，我们就可以在浏览器发起请求。在请求登录接口的时候，如果登录成功，我就可以生成一个令牌，令牌就是用户的合法身份凭证。接下来我在响应数据的时候，我就可以直接将令牌响应给前端。</p><p>接下来我们在前端程序当中接收到令牌之后，就需要将这个令牌存储起来。这个存储可以存储在 cookie 当中，也可以存储在其他的存储空间(比如：localStorage)当中。</p><p>接下来，在后续的每一次请求当中，都需要将令牌携带到服务端。携带到服务端之后，接下来我们就需要来校验令牌的有效性。如果令牌是有效的，就说明用户已经执行了登录操作，如果令牌是无效的，就说明用户之前并未执行登录操作。</p><p>此时，如果是在同一次会话的多次请求之间，我们想共享数据，我们就可以将共享的数据存储在令牌当中就可以了。</p><p><strong>优缺点</strong></p><ul><li>优点：<ul><li>支持PC端、移动端</li><li>解决集群环境下的认证问题</li><li>减轻服务器的存储压力（无需在服务器端存储）</li></ul></li><li>缺点：需要自己实现（包括令牌的生成、令牌的传递、令牌的校验）</li></ul><p>针对于这三种方案，现在企业开发当中使用的最多的就是第三种令牌技术进行会话跟踪。而前面的这两种传统的方案，现在企业项目开发当中已经很少使用了。所以在我们的课程当中，我们也将会采用令牌技术来解决案例项目当中的会话跟踪问题。</p><h2 id="JWT令牌技术"><a href="#JWT令牌技术" class="headerlink" title="JWT令牌技术"></a>JWT令牌技术</h2><ul><li><p><strong>全称</strong>：<code>Json Web Token</code></p></li><li><p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息，用于数字签名的存在，这些信息是可靠的</p></li><li><p><strong>组成</strong>：</p><ul><li><p>第一部分：Header(头)，记录令牌类型、签名算法等，例如：{“alg”:”HS256”,”type”:”JWT”}</p></li><li><p>第二部分：Payload(有效载荷)，携带一些自定义信息，默认信息等，例如：{“id”:”1”,”username”:”tom”}</p></li><li><p>第三部分：Signature(签名)，防止Token被篡改，确保安全性，将Header、Payload，并加入指定密钥，通过指定签名算法计算而来</p></li></ul></li></ul><p><img src="/.com//image-20240325110500548.png" alt="image-20240325110500548"></p><ul><li><strong>场景</strong>：登录认证<ol><li>登录成功后，生成令牌</li><li>后续每个请求，都需要携带jwt令牌，系统在每次请求处理之前，先校验令牌，通过后，在处理</li></ol></li></ul><p><img src="/.com//image-20240325110921704.png" alt="image-20240325110921704"></p><p><img src="/.com//image-20240325114101996-1715613343042-315.png" alt="image-20240325114101996"></p><h3 id="JWT令牌-生成"><a href="#JWT令牌-生成" class="headerlink" title="JWT令牌-生成"></a><strong>JWT令牌-生成</strong></h3><ul><li>要在pom文件中引入相关的依赖</li></ul><p><img src="/.com//image-20240325113642999-1715613343042-316.png" alt="image-20240325113642999"></p><ul><li><p>编写测试类</p><p><img src="/.com//image-20240325113707625.png" alt="image-20240325113707625"></p></li></ul><h3 id="JWT令牌-解析"><a href="#JWT令牌-解析" class="headerlink" title="JWT令牌-解析"></a>JWT令牌-解析</h3><p><img src="/.com//image-20240325113912663-1715613343042-318.png" alt="image-20240325113912663"></p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>JWT校验时使用的签名密钥，必须和生成JWT令牌时使用的密钥时配套的</li><li>如果JWT令牌解析校验时报错，则说明JWT令牌被篡改或失效了，令牌非法</li></ul><h2 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 概念：Filter过滤器，是JavaWeb三大组件（Servlet、Listener、Filter）之一</span><br><span class="line">-- 过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能</span><br><span class="line">-- 过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等</span><br></pre></td></tr></table></figure><h3 id="Filter快速入门"><a href="#Filter快速入门" class="headerlink" title="Filter快速入门"></a>Filter快速入门</h3><ul><li>定义Filter：定义一个类，实现Filter（javax.servlet）接口，并重写其所有方法</li><li>配置Filter：Filter类上加<code>@WebFilter</code>注解，配置拦截资源的路径，引导类上加<code>@ServletComponentScan</code>开启Sevlet组件支持</li></ul><p>Filter类</p><p><img src="/.com//image-20240325152707043-1715613343042-319.png" alt="image-20240325152707043"></p><p>引导类</p><p><img src="/.com//image-20240325152730300-1715613343042-320.png" alt="image-20240325152730300"></p><h3 id="详解（执行流程、拦截路径、过滤器链）"><a href="#详解（执行流程、拦截路径、过滤器链）" class="headerlink" title="详解（执行流程、拦截路径、过滤器链）"></a>详解（执行流程、拦截路径、过滤器链）</h3><p>1.执行流程</p><ul><li>请求&#x3D;&#x3D;&gt;放行前的逻辑&#x3D;&#x3D;&gt;放行&#x3D;&#x3D;&gt;访问Web资源&#x3D;&#x3D;&gt;放行后的逻辑</li></ul><p>2.拦截路径</p><ul><li>&#x2F;login</li><li>&#x2F;depts&#x2F;*</li><li>&#x2F;*</li></ul><p>3.过滤器链</p><ul><li>一个web应用中，配置了多个过滤器，就形成了一个过滤器链</li><li><img src="/.com//image-20240325154952548-1715613343042-321.png" alt="image-20240325154952548"></li></ul><h3 id="登录校验-Filter"><a href="#登录校验-Filter" class="headerlink" title="登录校验-Filter"></a>登录校验-Filter</h3><ul><li>所有的请求，拦截到了之后，都需要校验令牌吗？<ul><li>不是 有一个例外 登录请求 因为没登陆的时候是没有jwt令牌的</li></ul></li><li>拦截到请求后，什么情况下可以放行，执行业务操作？<ul><li>有令牌，且令牌校验通过（合法），否则都返回登录错误的结果</li></ul></li></ul><p>步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) Request;</span><br><span class="line">      <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) Response;</span><br><span class="line"><span class="comment">//1.获取请求url</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL().toString();</span><br><span class="line">      log.info(<span class="string">&quot;请求的url:&#123;&#125;&quot;</span>,url);</span><br><span class="line">      <span class="comment">//2.判断请求url中是否含有login，如果包含，则说明是登录请求，放行</span></span><br><span class="line">      <span class="keyword">if</span> (url.contains(<span class="string">&quot;login&quot;</span>)) &#123;</span><br><span class="line">          log.inf<span class="title function_">o</span><span class="params">(<span class="string">&quot;登陆操作，放行&quot;</span>)</span>;</span><br><span class="line">          Chain.doFilter(Request,Response);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//3.获取请求头中的令牌</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">      <span class="comment">//4.判断令牌是否存在，如果不存在，返回错误结果（未登录）</span></span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasLength(jwt)) &#123;  <span class="comment">//判断jwt令牌是否为null或空字符串</span></span><br><span class="line">          log.info(<span class="string">&quot;请求头token为空，返回未登录的信息&quot;</span>);</span><br><span class="line">          <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">          <span class="comment">//手动转换为json格式---&gt;阿里巴巴提供的fastJSON工具类</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">          resp.getWriter().write(notLogin);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//5.解析token，如果解析失败，返回错误结果（未登录）</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          JwtUtils.parseJWT(jwt);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//jwt解析失败</span></span><br><span class="line">          log.info(<span class="string">&quot;令牌解析失败，返回未登录的信息&quot;</span>);</span><br><span class="line">          <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">          <span class="comment">//手动转换为json格式---&gt;阿里巴巴提供的fastJSON工具类</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">          resp.getWriter().write(notLogin);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.放行</span></span><br><span class="line">      log.info(<span class="string">&quot;令牌合法，放行通过&quot;</span>);</span><br><span class="line">      Chain.doFilter(Request,Response);</span><br></pre></td></tr></table></figure><h2 id="Interceptor拦截器"><a href="#Interceptor拦截器" class="headerlink" title="Interceptor拦截器"></a>Interceptor拦截器</h2><ul><li>概念：是一种动态拦截方法调用的机制，类似于过滤器，Spring框架中提供，用来动态拦截控制器方法的执行</li><li>作用：拦截请求，在指定的方法调用前后，根据业务需求执行预先设定的代码</li></ul><h3 id="简介-快速入门"><a href="#简介-快速入门" class="headerlink" title="简介&amp;快速入门"></a>简介&amp;快速入门</h3><ol><li><p>定义拦截器，实现HandlerInterceptor接口，并重写其所有方法</p><p><img src="/.com//image-20240325215327083.png" alt="image-20240325215327083"></p></li><li><p>注册拦截器</p><p><img src="/.com//image-20240325215313458-1715613343042-323.png" alt="image-20240325215313458"></p></li></ol><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><ol><li><strong>拦截器-拦截器路径</strong><ul><li>拦截器可以根据需求，配置不同的拦截路径</li><li><img src="/.com//image-20240325215510710.png"></li><li><img src="/.com//image-20240325215526255.png"></li></ul></li><li><strong>拦截器-执行流程</strong><ul><li><img src="/.com//image-20240326085139308.png" alt="image-20240326085139308"></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filter 和 Interceptor</span><br><span class="line">接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口</span><br><span class="line">拦截范围不同：过滤器Filter会拦截所有资源，而Interceptor只会拦截SpringMVC环境中的资源</span><br></pre></td></tr></table></figure><h3 id="登录校验-interceptor"><a href="#登录校验-interceptor" class="headerlink" title="登录校验-interceptor"></a>登录校验-interceptor</h3><p>步骤：</p><p>​在Filter的基础上进行更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取请求url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL().toString();</span><br><span class="line">        log.info(<span class="string">&quot;请求的url:&#123;&#125;&quot;</span>,url);</span><br><span class="line">        <span class="comment">//2.判断请求url中是否含有login，如果包含，则说明是登录请求，放行</span></span><br><span class="line">        <span class="keyword">if</span> (url.contains(<span class="string">&quot;login&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;登陆操作，放行&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.获取请求头中的令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">//4.判断令牌是否存在，如果不存在，返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(jwt)) &#123;  <span class="comment">//判断jwt令牌是否为null或空字符串</span></span><br><span class="line">            log.info(<span class="string">&quot;请求头token为空，返回未登录的信息&quot;</span>);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动转换为json格式---&gt;阿里巴巴提供的fastJSON工具类</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.解析token，如果解析失败，返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtils.parseJWT(jwt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//jwt解析失败</span></span><br><span class="line">            log.info(<span class="string">&quot;令牌解析失败，返回未登录的信息&quot;</span>);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动转换为json格式---&gt;阿里巴巴提供的fastJSON工具类</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        log.info(<span class="string">&quot;令牌合法，放行通过&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/.com//image-20240327183856718.png" alt="image-20240327183856718"></p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="当前问题"><a href="#当前问题" class="headerlink" title="当前问题"></a>当前问题</h2><p>登录功能和登录校验功能我们都实现了，下面我们学习下今天最后一块技术点：异常处理。首先我们先来看一下系统出现异常之后会发生什么现象，再来介绍异常处理的方案。</p><p>我们打开浏览器，访问系统中的新增部门操作，系统中已经有了 “就业部” 这个部门，我们再来增加一个就业部，看看会发生什么现象。</p><img src="/.com//image-20230112125651073.png" alt="image-20230112125651073" style="zoom: 80%;">   <p>点击确定之后，窗口关闭了，页面没有任何反应，就业部也没有添加上。 而此时，大家会发现，网络请求报错了。</p><img src="/.com//image-20230112125737863.png" alt="image-20230112125737863" style="zoom:80%;"> <p>状态码为500，表示服务器端异常，我们打开idea，来看一下，服务器端出了什么问题。</p><p><img src="/.com//image-20230112125826602.png" alt="image-20230112125826602"> </p><p>上述错误信息的含义是，dept部门表的name字段的值 就业部 重复了，因为在数据库表dept中已经有了就业部，我们之前设计这张表时，为name字段建议了唯一约束，所以该字段的值是不能重复的。</p><p>而当我们再添加就业部，这个部门时，就违反了唯一约束，此时就会报错。</p><p>我们来看一下出现异常之后，最终服务端给前端响应回来的数据长什么样。</p><p><img src="/.com//image-20230112130253486.png" alt="image-20230112130253486"> </p><p>响应回来的数据是一个JSON格式的数据。但这种JSON格式的数据还是我们开发规范当中所提到的统一响应结果Result吗？显然并不是。由于返回的数据不符合开发规范，所以前端并不能解析出响应的JSON数据。</p><p>接下来我们需要思考的是出现异常之后，当前案例项目的异常是怎么处理的？</p><ul><li>答案：没有做任何的异常处理</li></ul><p><img src="/.com//image-20230107121909087.png" alt="image-20230107121909087"></p><p>当我们没有做任何的异常处理时，我们三层架构处理异常的方案：</p><ul><li>Mapper接口在操作数据库的时候出错了，此时异常会往上抛(谁调用Mapper就抛给谁)，会抛给service。 </li><li>service 中也存在异常了，会抛给controller。</li><li>而在controller当中，我们也没有做任何的异常处理，所以最终异常会再往上抛。最终抛给框架之后，框架就会返回一个JSON格式的数据，里面封装的就是错误的信息，但是框架返回的JSON格式的数据并不符合我们的开发规范。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>那么在三层构架项目中，出现了异常，该如何处理?</p><ul><li>方案一：在所有Controller的所有方法中进行try…catch处理<ul><li>缺点：代码臃肿（不推荐）</li></ul></li><li>方案二：全局异常处理器<ul><li>好处：简单、优雅（推荐）</li></ul></li></ul><p><img src="/.com//image-20230107122904214.png" alt="image-20230107122904214"></p><h2 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h2><p>我们该怎么样定义全局异常处理器？</p><ul><li>定义全局异常处理器非常简单，就是定义一个类，在类上加上一个注解@RestControllerAdvice，加上这个注解就代表我们定义了一个全局异常处理器。</li><li>在全局异常处理器当中，需要定义一个方法来捕获异常，在这个方法上需要加上注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定我们要捕获的是哪一类型的异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span> <span class="comment">//指定能够处理的异常类型</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ex</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();<span class="comment">//打印堆栈中的异常信息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//捕获到异常之后，响应一个标准的Result</span></span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;对不起,操作失败,请联系管理员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@RestControllerAdvice &#x3D; @ControllerAdvice + @ResponseBody</p><p>处理异常的方法返回值会转换为json后再响应给前端</p></blockquote><p>重新启动SpringBoot服务，打开浏览器，再来测试一下添加部门这个操作，我们依然添加已存在的 “就业部” 这个部门：</p><p><img src="/.com//image-20230112131232032.png" alt="image-20230112131232032"> </p><p><img src="/.com//image-20230112131135272.png" alt="image-20230112131135272"> </p><p>此时，我们可以看到，出现异常之后，异常已经被全局异常处理器捕获了。然后返回的错误信息，被前端程序正常解析，然后提示出了对应的错误提示信息。</p><p>以上就是全局异常处理器的使用，主要涉及到两个注解：</p><ul><li>@RestControllerAdvice  &#x2F;&#x2F;表示当前类为全局异常处理器</li><li>@ExceptionHandler  &#x2F;&#x2F;指定可以捕获哪种类型的异常进行处理</li></ul><h1 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h1><ul><li>注解：<code>@Transactional</code></li><li>位置：业务层(service)的方法上、类上、接口上</li><li>作用：将当前方法交给spring进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；回滚事务</li></ul><p><img src="/.com//image-20240326091451610.png" alt="image-20240326091451610"></p><h2 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h2><h3 id="回滚rollback"><a href="#回滚rollback" class="headerlink" title="回滚rollback"></a>回滚rollback</h3><ul><li><code>@rollbackFor</code></li><li>默认情况下，只有出现@RuntimeException才会回滚，rollbackFor属性用于控制出现何种异常类型，回滚事务</li><li><img src="/.com//image-20240326093053231.png" alt="image-20240326093053231"></li></ul><h3 id="传播行为propagation"><a href="#传播行为propagation" class="headerlink" title="传播行为propagation"></a>传播行为propagation</h3><p>事务传播行为：指的就是当一个事务方法被另一事务方法调用时，这个事务方法该如何进行事务控制</p><ul><li>REQUIRED：大部分情况下都是用该传播行为即可</li><li>REQUIRES_NEW：当我们不希望事务之间相互影响，可以使用该传播行为，比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功</li></ul><p><img src="/.com//image-20240326095623453.png" alt="image-20240326095623453"></p><p>例如：</p><p><img src="/.com//image-20240328104531917-1715613343042-331.png" alt="image-20240328104531917"></p><p>在上述完成删除部门操作时，不管失败与否 都要记录日志 那么deptLogService中的insert语句就要添加事务</p><p><img src="/.com//image-20240326100618155-1715613343042-332.png" alt="image-20240326100618155"></p><p>当Transaction的值为默认值时，加入delete中的语句报错 会发生回滚 到时会连带insert一起回滚</p><p>如果设置REQUIRES_NEW则不会  因为propagation的默认值会自动加入已存在的事务  REQUIRES_NEW则会创建新的事务</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="AOP基础"><a href="#AOP基础" class="headerlink" title="AOP基础"></a>AOP基础</h2><h3 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h3><ul><li><code>AOP</code>：Aspect Oriented Progtamming(面向切面编程、面向方面编程)，其实就是棉线特定方法编程</li></ul><p> <strong>场景：</strong></p><ul><li>案例部分佛南功能运行较慢，定位执行耗时较长的业务方法，此时需要统计每一个业务方法的执行耗时</li><li><img src="/.com//image-20240326110621621.png" alt="image-20240326110621621"></li></ul><p><strong>实现：</strong></p><ul><li>动态代理时面向切面编程最主流的实现，而SpringAOP时Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程</li></ul><p><strong>底层原理：</strong></p><ul><li>动态代理机制</li></ul><p><strong>Spring的AOP的底层用到了两种代理机制：</strong></p><ul><li>JDK的动态代理：针对实现接口的类产生代理 </li><li>Cglib的动态代理：针对没有实现接口的类产生代理</li></ul><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ul><li><p>导入依赖</p><p><img src="/.com//image-20240326111320941-1715613343042-334.png" alt="image-20240326111320941"></p></li><li><p>编写aop程序：针对于特定方法根据业务需要进行编程</p><p><img src="/.com//image-20240326112306354-1715613343042-335.png" alt="image-20240326112306354"></p></li></ul><h3 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><ul><li>连接点：<code>JoinPoint</code>，可以被AOP控制的方法（暗含方法执行的相关信息）</li><li>通知：<code>Advice</code>， 指哪些重复的逻辑，也就是共性功能（最终体现为一个方法）</li><li>切入点：<code>PointCut</code>，匹配链接点的条件，通知仅会在切入点方法执行时被应用</li><li>切面：<code>Aspect</code>，描述通知与切入点，的对应关系（通知+切入点）</li><li>目标对象：<code>Target</code>，通知所应用的对象</li></ul><p><img src="/.com//image-20240326125641380.png" alt="image-20240326125641380"></p><h3 id="AOP执行流程"><a href="#AOP执行流程" class="headerlink" title="AOP执行流程"></a>AOP执行流程</h3><p><img src="/.com//image-20240326130435084.png" alt="image-20240326130435084"></p><h2 id="AOP进阶"><a href="#AOP进阶" class="headerlink" title="AOP进阶"></a>AOP进阶</h2><h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><ul><li><code>@Around</code> ：环绕通知，此注解标注的通知方法在目标方法前、后都被执行<ul><li><img src="/.com//image-20240326144648642-1715613343042-338.png" alt="image-20240326144648642"></li></ul></li><li><code>@Before</code> ：前置通知，此注解标注的通知方法在目标方法前被执行<ul><li><img src="/.com//image-20240326144638119-1715613343042-339.png" alt="image-20240326144638119"></li></ul></li><li><code>@After</code> （<strong>重点</strong>）：后置通知，此注解标注的通知方式在目标方法后被执行<ul><li><img src="/.com//image-20240326144656721-1715613343042-340.png" alt="image-20240326144656721"></li></ul></li><li><code>@AfterRuning</code> ：返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行<ul><li><img src="/.com//image-20240326144703033-1715613343042-341.png" alt="image-20240326144703033"></li></ul></li><li><code>@AfterThrowing</code> ：异常后通知，此注解标注的通知方法发生异常后通知<ul><li><img src="/.com//image-20240326144709491-1715613343042-342.png" alt="image-20240326144709491"></li></ul></li></ul><p><strong>注意事项</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行</span><br><span class="line"><span class="meta">@Around</span>环绕通知方法的返回值，必须指定为Object，来接受原始方法的返回值</span><br></pre></td></tr></table></figure><p><strong>抽取：</strong></p><p><code>@PointCut</code>注解</p><ul><li>该注解的作用是将公共的切点表达式抽取出来，需要使用的时引用该切点表达式即可</li></ul><p><img src="/.com//image-20240326144849843-1715613343042-343.png" alt="image-20240326144849843"></p><p><img src="/.com//image-20240326144931497-1715613343042-344.png" alt="image-20240326144931497"></p><p>直接调用 别的类中的也可直接调用 这里取决于px的修饰符</p><ul><li>private：仅能在当前切面类中引用该表达式</li><li>public：其他外部的切面类中也可以引用该表达式</li></ul><h3 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h3><p><strong>当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通方法都会被执行</strong></p><p>执行顺序：</p><ul><li><p>1.不同切面类中，默认按照切面类的类名字母排序</p><ul><li><p>目标方法前的通知方法：字母排名靠前的先执行</p></li><li><p>目标方法后的通知方法：字母排名靠前的后执行</p></li></ul></li><li><p>2.用<code>@Order(数字)</code> 加在切面类上来控制顺序</p><ul><li>目标方法前的通知方法：数字小的先执行</li><li>目标方法后的通知方法：数字小的后执行</li></ul></li></ul><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><ul><li>切入点表达式：描述切入点方法的一种表达式</li><li>作用：主要用来决定项目中的那些方法需要加入通知</li><li>常见形式<ul><li><code>execution(...)</code> ：根据方法的签名来匹配</li><li><code>@annotation(...)</code> ：根据注解匹配</li></ul></li></ul><h4 id="executation"><a href="#executation" class="headerlink" title="executation"></a>executation</h4><p>execution主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹，语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executation(访问修饰符？ 返回值 包名.类名？ 方法名(方法参数) <span class="keyword">throws</span> 异常？ )</span><br></pre></td></tr></table></figure><ul><li>其中带<code>?</code>的表示可省略的部分<ul><li>访问修饰符：可省略(比如：public、protected)</li><li>包名.类名：可省略</li><li>throw 异常：可省略 (注意是方法向上声明抛出的异常，不是实际抛出的异常)</li></ul></li><li>可以使用通配符描述切入点<ul><li><code>*</code> ： 单个独立的任意符号，可以统配任意返回值、包名、类名、方法名、任意类型的一个参数、也可以统配包、类、方法名的一部分<ul><li><img src="/.com//image-20240326161142261-1715613343042-345.png" alt="image-20240326161142261"></li></ul></li><li><code>..</code> ： 多个连续的任意符号，可以通配任意层级的包，或任意类型，任意个数的参数<ul><li><img src="/.com//image-20240326161240834-1715613343042-346.png" alt="image-20240326161240834"></li></ul></li></ul></li></ul><p><img src="/.com//image-20240326161917056-1715613343042-347.png" alt="image-20240326161917056"></p><p><img src="/.com//image-20240326161540654-1715613343042-348.png" alt="image-20240326161540654"></p><h4 id="annotation"><a href="#annotation" class="headerlink" title="@annotation"></a>@annotation</h4><p>@annotation 切入点表达式，用于匹配表示有特定注解的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@annotation(com.raehp.anno.Log)</span><br></pre></td></tr></table></figure><p>实现步骤：</p><ul><li><p>创建Annoation注解</p></li><li><p><img src="/.com//image-20240326162858318-1715613343042-349.png" alt="image-20240326162858318"></p></li><li><p>注解中添加@Retention注解、@Target注解</p><p><img src="/.com//image-20240326162938421-1715613343042-350.png" alt="image-20240326162938421"></p></li><li><p>在需要通知的方法上添加注解</p><p><img src="/.com//image-20240326163003775-1715613343042-351.png" alt="image-20240326163003775"></p></li><li><p>通过Pointcut修改切入点表达式 声明注解</p></li></ul><p><img src="/.com//image-20240326163051297-1715613343042-352.png" alt="image-20240326163051297"></p><h3 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h3><ul><li>在Spring中用<code>JoinPoint</code>抽象了连接点，用它可以获得方法执行时的信息，如目标类名，方法名，方法参数等。<ul><li>对于<code>@Around</code> 通知，获取连接点信息只能使用，<code>ProceedingJoinPoint</code></li><li>对于其他四种通知，获取连接点信息只能使用 <code>JoinPoint</code> ，他是 <code>ProceedingJoinPoint</code> 的父类型</li></ul></li></ul><p><img src="/.com//image-20240326190904328.png" alt="image-20240326190904328"></p><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>springboot中支持三种格式的配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.port=<span class="number">8081</span>  --properties</span><br><span class="line">server:</span><br><span class="line">port: <span class="number">8082</span>--yml</span><br><span class="line">server:</span><br><span class="line">port: <span class="number">8083</span>--yaml</span><br></pre></td></tr></table></figure><p>其中 ：优先级<code>properties &gt; yml &gt; yaml</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虽然springboot支持多种格式配置文件，但是在项目开发过程中，推荐统一使用一种格式的配置 （yml是主流）</span><br></pre></td></tr></table></figure><ul><li><p>Springboot除了支持配置文件属性配置，还支持 <code>Java系统属性 </code>和 <code>命令行参数</code> 的方式进行属性配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Java系统属性</span><br><span class="line">-Dserver.port=9000</span><br><span class="line"># 命令行参数</span><br><span class="line">--server.port=10010</span><br></pre></td></tr></table></figure><p>其中：优先级<code>命令行参数</code> &gt; <code>Java系统属性</code></p><p><img src="/.com//image-20240401095305704-1715613343042-354.png" alt="image-20240401095305704"></p></li></ul><p>​<img src="/.com//image-20240401095654133-1715613343042-355.png" alt="image-20240401095654133"></p><p><strong>那么，当我们打包成jar包之后 那我们 该如何设置Java系统属性 和命令行参数</strong></p><ul><li><p>先打开jar包所在位置</p><p><img src="/.com//image-20240401095729789-1715613343042-356.png" alt="image-20240401095729789"></p></li><li><p>在当前文件地址打开cmd  输入</p><p><img src="/.com//image-20240401095818059-1715613343042-357.png" alt="image-20240401095818059"></p></li></ul><p>那么这5种配置方式的优先级大小呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令行参数 &gt; Java系统属性 &gt; properties &gt; yml &gt; yaml</span><br></pre></td></tr></table></figure><h2 id="Bean管理"><a href="#Bean管理" class="headerlink" title="Bean管理"></a>Bean管理</h2><h3 id="获取bean"><a href="#获取bean" class="headerlink" title="获取bean"></a>获取bean</h3><ul><li><p>默认情况下，Spring项目启动时，会把bean都创建好放在IOC容器，如果想主动获取这些bean，可以通过如下方式</p><ul><li><p>注入ApplicaionContext</p><p><img src="/.com//image-20240401102748733-1715613343042-358.png"></p></li><li><p>根据name获取bean</p><p><img src="/.com//image-20240401102528247-1715613343042-359.png" alt="image-20240401102528247"></p></li><li><p>根据类型获取</p><p><img src="/.com//image-20240401102536962-1715613343042-360.png" alt="image-20240401102536962"></p></li><li><p>根据name获取bean（带转换类型）</p><p><img src="/.com//image-20240401102617263-1715613343042-361.png"></p></li></ul></li></ul><p>运行结果：</p><p>​<img src="/.com//image-20240401102653230-1715613343042-362.png" alt="image-20240401102653230"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上述所说的 【Spring 项目启动时，会把其中的bean都创建好】 还会受到作用域及延迟初始化影响，这里主要针对于 默认的单例非延迟加载的bean而言</span><br></pre></td></tr></table></figure><h3 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h3><ul><li><p>Spring支持五种作用域 后三者在web环境才生效</p><p><img src="/.com//image-20240401104035633.png" alt="image-20240401104035633"></p></li><li><p>可以通过<code>@Scope</code> 注解来进行配置作用域</p><p><img src="/.com//image-20240401104123066-1715613343042-364.png" alt="image-20240401104123066"></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认singleton 的bean  在容器启动时被创建，可以使用@Lazy注解来延迟初始化（延迟到第一次使用时）</span><br><span class="line">prototype的bean，第一次使用该bean的时候 都会创建一个新的实例</span><br><span class="line">实际开发中，绝大部分的bean是单例的，也就是说绝大部分的bean不需要设置prototype</span><br></pre></td></tr></table></figure><p>标注prototype的运行结果：</p><p><img src="/.com//image-20240401104420321-1715613343042-365.png" alt="image-20240401104420321"></p><p>默认值的运行结果</p><p><img src="/.com//image-20240401104458244-1715613343042-367.png" alt="image-20240401104458244"></p><p>添加@Lazy注解后的运行结果（scope为默认值的情况下）：在调用的时候 初始化</p><p><img src="/.com//image-20240401104748294-1715613343042-366.png" alt="image-20240401104748294"></p><p>不加@Lazy注解：在调用前 初始化</p><p><img src="/.com//image-20240401104833746-1715613343042-368.png" alt="image-20240401104833746"></p><h3 id="第三方bean"><a href="#第三方bean" class="headerlink" title="第三方bean"></a>第三方bean</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果要管理的bean对象 来自第三方（不是自己定义的） 是无法使用@Component及衍生注解来声明bean的，就需要用到@Bean注解</span><br><span class="line"></span><br><span class="line">若要管理第三方的bean对象，建议对这些bean集中管理分类配置，可以通过@Configuration注解来声明一个配置类</span><br></pre></td></tr></table></figure><ul><li>在启动类中 使用@Bean 注解 来 声明第三方类<ul><li><img src="/.com//image-20240401111143619-1715613343042-370.png" alt="image-20240401111143619"></li></ul></li><li>在通过@Autowired 注解来注入 测试<ul><li><img src="/.com//image-20240401111242081-1715613343042-369.png" alt="image-20240401111242081"></li></ul></li></ul><p>但这个时候 我们会发现 声明第三方类的过程 是在启动类中实现的（不建议）</p><p>声明配置类的方法：</p><ul><li><p>先创建一个类 标注 <code>@Configuration</code> 注解 声明配置类</p><ul><li><img src="/.com//image-20240401111541227-1715613343042-371.png" alt="image-20240401111541227"></li></ul></li><li><p>如果想要依赖注入  则直接以形参的方式 写到方法中即可</p></li></ul><h2 id="SpringBoot原理"><a href="#SpringBoot原理" class="headerlink" title="SpringBoot原理"></a>SpringBoot原理</h2><h3 id="起步依赖原理"><a href="#起步依赖原理" class="headerlink" title="起步依赖原理"></a>起步依赖原理</h3><p>起步依赖原理：Maven的依赖传递</p><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>方案一：<code>@ComponentScan</code> 组件扫描</li></ul><p><img src="/.com//image-20240401122207578-1715613343042-372.png" alt="image-20240401122207578"></p><ul><li><p>方案二：<code>@Import</code> 导入。使用@Import 导入的类会被Spring 加载到IOC容器中，导入形式主要有以下几种</p><ul><li><h2 id="导入普通类"><a href="#导入普通类" class="headerlink" title="导入普通类"></a>导入普通类</h2><ul><li><img src="/.com//image-20240401122947934-1715613343042-373.png" alt="image-20240401122947934"></li></ul></li><li><p>导入配置类</p><ul><li><img src="/.com//image-20240401123312638-1715613343042-374.png" alt="image-20240401123312638"></li></ul></li><li><p>导入ImportSelector 接口实现类</p><ul><li><img src="/.com//image-20240401123344957-1715613343042-375.png" alt="image-20240401123344957"></li></ul></li><li><p><code>@EnableXxxx</code> 注解，封装 <code>@Import</code></p><ul><li><img src="/.com//image-20240401123509258-1715613343042-376.png" alt="image-20240401123509258"></li></ul></li></ul></li></ul><h4 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h4><h5 id="SpringbootApplication"><a href="#SpringbootApplication" class="headerlink" title="@SpringbootApplication"></a>@SpringbootApplication</h5><p>Springboot的启动类上有个 <code>@SpringBootApplication</code> 注解 这个注解内还 有着 以下三个注解：</p><p><img src="/.com//image-20240401151513118.png" alt="image-20240401151513118"></p><p>自动配置的核心：<code>@EnableAutoConfiguration</code></p><p><code>@SpringbootApplication</code>  该注解标注在Springboot的工程引导类上，是Springboot中<strong>最最最</strong>重要的注解。该注解由三个部分组成：</p><ul><li><code>@SpringbootConfiguration</code> ：该注解与 <code>@Configruration</code> 注解作用相同，用来声明当前也是一个配置类</li><li><code>@ComponentScan</code> ： 组件扫描，默认扫描当前引导类所在的包及其子包</li><li><code>@EnaleAutoConfiguration</code> ：SpringBoot 实现自动化配置的核心</li></ul><h5 id="ConditionalMissingBean"><a href="#ConditionalMissingBean" class="headerlink" title="@ConditionalMissingBean"></a>@ConditionalMissingBean</h5><ul><li>作用：按照一定条件进行判断，在满足给定条件后才会注册对应的bean对象到springboot的IOC容器中</li><li>位置：方法、类</li><li><code>@Conditional</code> 本身是一个父注解，派生出大量的子注解：<ul><li><code>@ConditionalOnClass</code> ：判断环境中 是否有对应的字节码文件，才会注册bean到IOC容器中<ul><li><img src="/.com//image-20240401160505935-1715613343042-378.png" alt="image-20240401160505935"></li></ul></li><li><code>@ConditionalOnMissingBean</code> ：判断环境中没有对应的bean(类型 或 名称) 才注册bean到IOC容器<ul><li><img src="/.com//image-20240401160522629-1715613343042-379.png" alt="image-20240401160522629"></li></ul></li><li><code>@ConditionalOnProperty</code> ：判断配置文件中有对应属性和值，才注册bean到IOC容器<ul><li><img src="/.com//image-20240401160537920-1715613343042-380.png" alt="image-20240401160537920"></li></ul></li></ul></li></ul><p></p><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><ul><li>场景：在实际开发中，经常会定义一些公共组件，提供给各个团队使用，而在Springboot的项目中，一般会将这些公共组件封装为SpringBoot的starter。</li><li><img src="/.com//image-20240401163617636-1715613343042-381.png" alt="image-20240401163617636"></li><li><img src="/.com//image-20240401163634021.png" alt="image-20240401163634021"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：springboot官方提供的起步依赖中 spring-boot 在前   </span><br><span class="line">其他技术提供： 功能在前</span><br></pre></td></tr></table></figure><p><img src="/.com//image-20240401163744139.png" alt="image-20240401163744139"></p><p>图中，黄色背景中 有粉色背景的依赖  所以 当我加载黄色依赖的时候 它会自动加载里面引入的粉色依赖</p><h4 id="自定义start"><a href="#自定义start" class="headerlink" title="自定义start"></a>自定义start</h4><p><img src="/.com//image-20240401163913668-1715613343042-384.png" alt="image-20240401163913668"></p><p><img src="/.com//image-20240401163920815.png" alt="image-20240401163920815"></p><p>步骤： </p><ul><li>将之前工程中的 AliOSSProperties.java   AliOSSUtils.java 复制到aliyun-oss-boot-autocongifure工程中 这个时候会发现报错了 <ul><li>AliOSSUtils.java 方法报错：MultipartFile 原因是没有导入spring-boot-starter-web 依赖</li><li><img src="/.com//image-20240401195856740.png" alt="image-20240401195856740"></li><li><img src="/.com//image-20240401200005244-1715613343042-387.png" alt="image-20240401200005244"></li><li>get set方法找不到 是因为AliyunOSSProperties中的 lombok依赖没有导入 这时候只需要重写以下get set方法就行了</li></ul></li><li>这个时候 发现 AliOSSProperties.java   AliOSSUtils.java   上面的<code>@compenent</code> 注解都用没用了：因为 将来如过有用户使用 我们也不想让他们扫描到  所以 要把从<code>@compenent</code> 注解删掉   但是删掉后 又有错误<ul><li>因为不是IOC容器 所以不能使用<code>@Autowired</code>  注入   但是要求中 说我们要进行注入AliOSSUtils  所以就要用到 <code>@Bean</code> 注解<ul><li>声明一个 配置类 <code>@Confirguration</code> 来进行 配置 将其交给IOC容器 <ul><li><img src="/.com//image-20240401201658838-1715613343042-388.png" alt="image-20240401201658838"></li></ul></li></ul></li><li>AliOSSProperties.java  也会报错  <ul><li><img src="/.com//image-20240401200727060-1715613343042-389.png" alt="image-20240401200727060"></li><li><img src="/.com//image-20240401200742532-1715613343042-390.png" alt="image-20240401200742532"></li><li>这时我们发现 缺少了 <code>@EnableConfirgurationProperties</code> 注解 所以我们要 在AliyunOSSConfirgue中添加 此注解<ul><li><img src="/.com//image-20240401201802085-1715613343042-392.png" alt="image-20240401201802085"></li></ul></li></ul></li></ul></li><li>此外 还会发现  AliOSSUtils 中的 aliOSSProperties 我们并没有声明值 所以我们要给他写上get set方法 <ul><li><img src="/.com//image-20240401201017568-1715613343042-391.png" alt="image-20240401201017568"></li><li>并且 在配置类的  <code>@EnableConfirgurationProperties</code>  注解内添加  并将AliOSSProperties.class类导入 <ul><li><img src="/.com//image-20240401201108735-1715613343042-393.png" alt="image-20240401201108735"></li><li>进行注入   并将方法 中的值进行返回  注入 直接在方法形参内声明<ul><li><img src="/.com//image-20240401201146741-1715613343042-396.png" alt="image-20240401201146741"></li></ul></li></ul></li></ul></li><li>最后 进行测试<ul><li><img src="/.com//image-20240401201326172-1715613343042-394.png" alt="image-20240401201326172"></li><li>引入测试类  并 在pom文件中 引入aliyun-oss-spring-boot-starter 的依赖  注意 不需要引入 aliyun-oss-spring-boot-autoconfigure 的 依赖 因为 aliyun-oss-spring-boot-starter  已经引入 又因为 依赖的传递性 所以 不用在引入了</li><li><img src="/.com//image-20240401201513561-1715613343042-395.png" alt="image-20240401201513561"></li><li>uploadController 中  注入aliOSSUtils    并调用upload方法 此时 就获得了 图像的url</li></ul></li></ul><h1 id="Maven高级"><a href="#Maven高级" class="headerlink" title="Maven高级"></a>Maven高级</h1><h2 id="分模块设计与开发"><a href="#分模块设计与开发" class="headerlink" title="分模块设计与开发"></a>分模块设计与开发</h2><p>当我们很多人 共同开发一个项目的时候 如何做到数据共享呢？  这个时候就要将 我们要共i想的数据  封装到一个新模块中  当我们需要使用的 时候 直接导入对应的依赖即可</p><p>将之前完成的tlias包 进行分模块    </p><ul><li>先分别创建存放pojo和utils的模块<ul><li><img src="/.com//image-20240402092430991-1715613343043-397.png" alt="image-20240402092430991"></li></ul></li><li>将pojo包下的类 一同copy 到 tlias-pojo模块中 utils同理<ul><li><img src="/.com//image-20240402092640342-1715613343043-398.png" alt="image-20240402092640342"></li><li>再将 pojo类所需要的依赖 导入到pom文件中去</li></ul></li><li>最后 在这个项目中  导入 tlais-pojo 和tlais-utils 的依赖<ul><li><img src="/.com//image-20240402092833445-1715613343043-399.png" alt="image-20240402092833445"></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.什么是分模块设计？</span><br><span class="line">·将项目按照功能拆分成若干个子模块</span><br><span class="line">2.为什么要分模块设计？</span><br><span class="line">·方便项目的管理和维护、扩展，也方便模块间的相互调用，资源共享</span><br><span class="line">3.注意事项：</span><br><span class="line">·分模块设计需要先针对模块功能进行设计，在进行编码。不会先将工程开发完毕，然后进行拆分</span><br></pre></td></tr></table></figure><h2 id="继承与聚合"><a href="#继承与聚合" class="headerlink" title="继承与聚合"></a>继承与聚合</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>概念：继承描述的是两个工程间的关系，与Java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承</li><li>作用：简化依赖配置、统一管理依赖</li><li>实现：<parent></parent></li></ul><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><ol><li>创建maven模块，tlias-parent，该工程为父工程，设置打包方式<code>pom</code> （默认jar）<ul><li><img src="/.com//image-20240402100153810-1715613343043-400.png" alt="image-20240402100153810"></li></ul></li><li>在子工程的pom.xml文件中，配置继承关系<ul><li><img src="/.com//image-20240402100221947.png" alt="image-20240402100221947"></li><li><strong>relativePath 父工程的相对路径</strong></li></ul></li><li>在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）<ul><li><img src="/.com//image-20240402100324022-1715613343043-402.png" alt="image-20240402100324022"></li></ul></li></ol><p><img src="/.com//image-20240402100116088-1715613343043-403.png" alt="image-20240402100116088"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">在子工程中，配置了继承关系之后，坐标中的groupId是可以省略的，因为会自动创建父工程的</span><br><span class="line">relativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库/远程仓库查找该工程）</span><br></pre></td></tr></table></figure><p><strong>打包方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jar:普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行）</span><br><span class="line">war：普通web程序打包，需要部署在外部的tomcat服务器中运行</span><br><span class="line">pom：父工程或聚合工程，该模块不写代码，仅进行依赖管理</span><br></pre></td></tr></table></figure><h4 id="版本锁定"><a href="#版本锁定" class="headerlink" title="版本锁定"></a>版本锁定</h4><ul><li>在maven中，可以在父工程的pom文件中通过，<denpendencyManager> 来统一管理版本<ul><li><img src="/.com//image-20240402103059965.png" alt="image-20240402103059965"></li><li><strong>子工程引入依赖时，无需指定<version> 版本号，父工程统一管理，变更依赖版本，只需要在父工程中变更</version></strong></li></ul></denpendencyManager></li><li>自定义属性&#x2F;引用属性<ul><li>如果 以后引入的依赖太多 一个个版本找起来也很麻烦 这个时候 就需要定义属性了<ul><li><img src="/.com//image-20240402104254199-1715613343043-405.png" alt="image-20240402104254199"></li><li><img src="/.com//image-20240402104303201-1715613343043-406.png" alt="image-20240402104303201"></li><li><img src="/.com//image-20240402104307962-1715613343043-407.png" alt="image-20240402104307962"></li><li><img src="/.com//image-20240402104434598.png" alt="image-20240402104434598"></li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">面试题：</span><br><span class="line">&lt;dependencyManager&gt; 与 &lt;dependencies&gt; 的区别是什么？</span><br><span class="line">&lt;dependencies&gt; 是直接依赖，在父工程中配置了依赖，子工程会直接继承下来</span><br><span class="line">&lt;dependencyManager&gt; 是统一管理依赖版本，不会直接依赖，还需要在子工程中引入所需要的依赖（无需指定版本）</span><br></pre></td></tr></table></figure><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>当我们要打包项目的时候 要一个个install然后再pakage  这个时候 会很繁琐 我们就要用到耦合</p><p><img src="/.com//image-20240402112815627.png" alt="image-20240402112815627"></p><ul><li>maven 中可以通过 <models> 设置当前聚合工程所包含的子模块名称<ul><li><img src="/.com//image-20240402112947489-1715613343043-410.png" alt="image-20240402112947489"></li></ul></models></li><li><img src="/.com//image-20240402113005262-1715613343043-411.png" alt="image-20240402113005262"><ul><li>这个时候 直接运行 父工程中的package 就可实现 打包操作</li></ul></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul><li>作用：<ul><li>聚合用于快速构建项目</li><li>继承用于简化依配置、统一依赖管理</li></ul></li><li>相同点：<ul><li>聚合与继承的pom.xml 文件打包方式均为pom 额可以将两种关系制作到同一个pom文件中</li><li>聚合与继承 均属于 设计性模块 并无实际的模块内容</li></ul></li><li>不同点：<ul><li>聚合实在聚合工程中配置，聚合可以感知到参与聚合的模块有那些</li><li>继承是在子模块中配置关系，父模块无法感知那些子模块 继承了自己</li></ul></li></ul><p>​ </p><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><ul><li>私服是一种特殊的远程仓库，他是架设在局域网内的仓库服务，用来代替位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题</li><li><img src="/.com//image-20240402115910067.png" alt="image-20240402115910067"></li></ul><p>创建私服 的方法较为固定 参考 [私服配置说明.md](E:\BaiduNetdiskDownload\最新版JavaWeb开发教程\资料\day15-maven高级\资料\01. maven高级\02. 私服配置案例\私服配置说明.md) </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2024/03/01/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/03/01/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Java概述"><a href="#一、Java概述" class="headerlink" title="一、Java概述"></a>一、Java概述</h2><h3 id="1、JVM、JRE和JDK的关系"><a href="#1、JVM、JRE和JDK的关系" class="headerlink" title="1、JVM、JRE和JDK的关系"></a>1、JVM、JRE和JDK的关系</h3><p>​<strong>JVM</strong></p><p>是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p><p>​<strong>JRE</strong></p><p>包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p><p>​<strong>JDK</strong></p><p>是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p><h3 id="2、什么是跨平台性？原理是什么"><a href="#2、什么是跨平台性？原理是什么" class="headerlink" title="2、什么是跨平台性？原理是什么"></a>2、什么是跨平台性？原理是什么</h3><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p><p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p><h3 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h3><p>简单易学（Java语言的语法与C语言和C++语言很接近）</p><p>面向对象（封装，继承，多态）</p><p>平台无关性（Java虚拟机实现平台无关性）</p><p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</p><p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</p><p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</p><h3 id="3、什么是字节码？采用字节码的最大好处是什么"><a href="#3、什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="3、什么是字节码？采用字节码的最大好处是什么"></a>3、什么是字节码？采用字节码的最大好处是什么</h3><p><strong>字节码：</strong>Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p><h3 id="4、Java和C-的区别"><a href="#4、Java和C-的区别" class="headerlink" title="4、Java和C++的区别"></a>4、Java和C++的区别</h3><ul><li><p>都是面向对象的语言，都支持封装、继承和多态</p></li><li><p>Java不提供指针来直接访问内存，程序内存更加安全</p></li><li><p>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</p></li><li><p>Java有自动内存管理机制，不需要程序员手动释放无用内存</p></li></ul><h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h2><h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3><h4 id="1-Java有哪些数据类型"><a href="#1-Java有哪些数据类型" class="headerlink" title="1.Java有哪些数据类型"></a>1.Java有哪些数据类型</h4><ul><li>基本数据类型<ul><li>数值型<ul><li>整数类型(byte,short,int,long)</li><li>浮点类型(float,double)</li></ul></li><li>字符型(char)</li><li>布尔型(boolean)</li></ul></li><li>引用数据类型<ul><li>类(class)</li><li>接口(interface)</li><li>数组([])</li></ul></li></ul><p><img src="/.com//image-20240119173941173.png" alt="image-20240119173941173"></p><h4 id="2、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#2、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上"></a>2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h4><p>​在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p><h3 id="2、编码"><a href="#2、编码" class="headerlink" title="2、编码"></a>2、编码</h3><h4 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h4><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><h3 id="3、注释"><a href="#3、注释" class="headerlink" title="3、注释"></a>3、注释</h3><ul><li>单行注释<br>格式： &#x2F;&#x2F; 注释文字</li><li>多行注释<br>格式： &#x2F;* 注释文字 *&#x2F;</li><li>文档注释<br>格式：&#x2F;** 注释文字 *&#x2F;</li></ul><h3 id="4、访问修饰符"><a href="#4、访问修饰符" class="headerlink" title="4、访问修饰符"></a>4、访问修饰符</h3><p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。<br>public : 对所有类可见。使用对象：类、接口、变量、方法</p><p><img src="/.com//image-20240119174842955.png" alt="image-20240119174842955"></p><h3 id="5、运算符"><a href="#5、运算符" class="headerlink" title="5、运算符"></a>5、运算符</h3><h4 id="和-的区别"><a href="#和-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h4><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p><p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><h3 id="6、关键字"><a href="#6、关键字" class="headerlink" title="6、关键字"></a>6、关键字</h3><h4 id="1-Java-有没有-goto"><a href="#1-Java-有没有-goto" class="headerlink" title="1. Java 有没有 goto"></a>1. Java 有没有 goto</h4><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p><h4 id="2-final-有什么用？"><a href="#2-final-有什么用？" class="headerlink" title="2. final 有什么用？"></a>2. final 有什么用？</h4><p>用于修饰类、属性和方法；</p><ul><li>被final修饰的类不可以被继承</li><li>被final修饰的方法不可以被重写</li><li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li></ul><h4 id="3-final-finally-finalize区别"><a href="#3-final-finally-finalize区别" class="headerlink" title="3.final finally finalize区别"></a>3.final finally finalize区别</h4><p>final：可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</p><p>finally：一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</p><p>finalize：是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</p><h4 id="4-this关键字的用法"><a href="#4-this关键字的用法" class="headerlink" title="4. this关键字的用法"></a>4. this关键字的用法</h4><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p><p><strong>this的用法在java中大体可以分为3种：</strong></p><p>①. 普通的直接引用，this相当于是指向当前对象本身。</p><p>②. 形参与成员名字重名，用this来区分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③. 引用本类的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-super关键字的用法"><a href="#5-super关键字的用法" class="headerlink" title="5. super关键字的用法"></a>5. super关键字的用法</h4><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p><p>super也有三种用法：</p><p>①. 普通的直接引用</p><p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p><p>②. 子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p><p>③. 引用父类构造函数</p><ul><li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li><li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li></ul><h4 id="6-this与super的区别"><a href="#6-this与super的区别" class="headerlink" title="6. this与super的区别"></a>6. this与super的区别</h4><p><img src="/.com//image-20240119180341803.png" alt="image-20240119180341803"></p><h4 id="7-static存在的主要意义"><a href="#7-static存在的主要意义" class="headerlink" title="7. static存在的主要意义"></a>7. static存在的主要意义</h4><p><img src="/.com//image-20240119180404935.png" alt="image-20240119180404935"></p><h4 id="8-static的独特之处"><a href="#8-static的独特之处" class="headerlink" title="8. static的独特之处"></a>8. static的独特之处</h4><ul><li>被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</li></ul><h4 id="9-static应用场景"><a href="#9-static应用场景" class="headerlink" title="9. static应用场景"></a>9. static应用场景</h4><p>因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。</p><p>因此比较常见的static应用场景有：</p><ul><li>修饰成员变量</li><li>修饰成员方法</li><li>静态代码块</li><li>修饰类【只能修饰内部类也就是静态内部类】</li><li>静态导包</li></ul><h4 id="10-static注意事项"><a href="#10-static注意事项" class="headerlink" title="10. static注意事项"></a>10. static注意事项</h4><ol><li>静态只能访问静态。</li><li>非静态既可以访问非静态的，也可以访问静态的。</li></ol><h3 id="7、流程控制语句"><a href="#7、流程控制语句" class="headerlink" title="7、流程控制语句"></a>7、流程控制语句</h3><h4 id="1、break-continue-return-的区别及作用"><a href="#1、break-continue-return-的区别及作用" class="headerlink" title="1、break ,continue ,return 的区别及作用"></a>1、break ,continue ,return 的区别及作用</h4><p><strong>break</strong> 跳出总上一层循环，不再执行循环(结束当前的循环体)</p><p><strong>continue</strong> 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p><p><strong>return</strong> 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p><h4 id="2-在-Java-中，如何跳出当前的多重嵌套循环"><a href="#2-在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="2. 在 Java 中，如何跳出当前的多重嵌套循环"></a>2. 在 Java 中，如何跳出当前的多重嵌套循环</h4><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ok:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;,j=&quot;</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span> ok;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h2><h3 id="1、面向对象概述"><a href="#1、面向对象概述" class="headerlink" title="1、面向对象概述"></a>1、面向对象概述</h3><h5 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h5><p><strong>面向过程：</strong></p><p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。</p><p>缺点：没有面向对象易维护、易复用、易扩展</p><p><strong>面向对象：</strong></p><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p><p>缺点：性能比面向过程低</p><p><strong>面向过程是具体化的</strong>，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p><p><strong>面向对象是模型化的</strong>，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p><p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p><h3 id="2、面向对象三大特性"><a href="#2、面向对象三大特性" class="headerlink" title="2、面向对象三大特性"></a>2、面向对象三大特性</h3><h4 id="1-面向对象的特征有哪些方面"><a href="#1-面向对象的特征有哪些方面" class="headerlink" title="1. 面向对象的特征有哪些方面"></a>1. 面向对象的特征有哪些方面</h4><h5 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a><strong>抽象</strong></h5><p>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h5><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h5><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p>关于继承如下 3 点请记住：</p><ul><li><p>子类拥有父类非 private 的属性和方法。</p></li><li><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p></li><li><p>子类可以用自己的方式实现父类的方法。（以后介绍）。</p></li></ul><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h5><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p><strong>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</strong></p><p><strong>其中Java 面向对象编程三大特性：封装 继承 多态</strong></p><p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），</p><p>方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p><ul><li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li><li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li></ul><h4 id="2-Java语言是如何实现多态的？"><a href="#2-Java语言是如何实现多态的？" class="headerlink" title="2. Java语言是如何实现多态的？"></a>2. Java语言是如何实现多态的？</h4><h5 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h5><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><p>继承：在多态中必须存在有继承关系的子类和父类。</p><p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p><p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p><h4 id="3-面向对象五大基本原则是什么（可选）"><a href="#3-面向对象五大基本原则是什么（可选）" class="headerlink" title="3. 面向对象五大基本原则是什么（可选）"></a>3. 面向对象五大基本原则是什么（可选）</h4><ul><li><p>单一职责原则SRP(Single Responsibility Principle)</p></li><li><p>开放封闭原则OCP(Open－Close Principle)</p></li><li><p>里式替换原则LSP(the Liskov Substitution Principle LSP)</p></li><li><p>依赖倒置原则DIP(the Dependency Inversion Principle DIP)</p></li><li><p>接口分离原则ISP(the Interface Segregation Principle ISP)</p></li></ul><h3 id="3、类与接口"><a href="#3、类与接口" class="headerlink" title="3、类与接口"></a>3、类与接口</h3><h4 id="1-抽象类和接口的对比"><a href="#1-抽象类和接口的对比" class="headerlink" title="1.抽象类和接口的对比"></a><strong>1.抽象类和接口的对比</strong></h4><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p><p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p><p><strong>相同点</strong></p><p>接口和抽象类都不能实例化</p><p>都位于继承的顶端，用于被其他实现或继承</p><p>都包含抽象方法，其子类都必须覆写这些抽象方法</p><p><strong>不同点</strong></p><p><img src="/.com//image-20240119181802331.png" alt="image-20240119181802331"></p><p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p><ul><li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li><li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li></ul><h4 id="2-普通类和抽象类有哪些区别？"><a href="#2-普通类和抽象类有哪些区别？" class="headerlink" title="2. 普通类和抽象类有哪些区别？"></a>2. 普通类和抽象类有哪些区别？</h4><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h4 id="3-抽象类能使用-final-修饰吗？"><a href="#3-抽象类能使用-final-修饰吗？" class="headerlink" title="3. 抽象类能使用 final 修饰吗？"></a>3. 抽象类能使用 final 修饰吗？</h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p><h4 id="4-创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#4-创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="4. 创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>4. 创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4><p>new关键字</p><p>new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。 </p><h3 id="4、变量与方法"><a href="#4、变量与方法" class="headerlink" title="4、变量与方法"></a>4、变量与方法</h3><h4 id="1-成员变量与局部变量的区别有哪些"><a href="#1-成员变量与局部变量的区别有哪些" class="headerlink" title="1. 成员变量与局部变量的区别有哪些"></a>1. 成员变量与局部变量的区别有哪些</h4><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</p><p>成员变量：方法外部，类内部定义的变量</p><p>局部变量：类的方法中的变量。</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>成员变量：针对整个类有效。<br>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p><h5 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h5><p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。<br>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</p><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：当方法调用完，或者语句结束后，就自动释放。</p><h5 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h5><p>成员变量：有默认初始值。</p><p>局部变量：没有默认初始值，使用前必须赋值。</p><h5 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h5><p>在使用变量时需要遵循的原则为：就近原则<br>首先在局部范围找，有就使用；接着在成员位置找。</p><h4 id="2-在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#2-在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="2. 在Java中定义一个不做事且没有参数的构造方法的作用"></a>2. 在Java中定义一个不做事且没有参数的构造方法的作用</h4><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。</p><h4 id="3-在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#3-在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="3. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>3. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h4><p>帮助子类做初始化工作。</p><h4 id="4-一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#4-一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="4. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>4. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h4><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h4 id="5-构造方法有哪些特性？"><a href="#5-构造方法有哪些特性？" class="headerlink" title="5. 构造方法有哪些特性？"></a>5. 构造方法有哪些特性？</h4><p>名字与类名相同；</p><p>没有返回值，但不能用void声明构造函数；</p><p>生成类的对象时自动执行，无需调用。</p><h4 id="6-静态变量和实例变量区别"><a href="#6-静态变量和实例变量区别" class="headerlink" title="6.静态变量和实例变量区别"></a>6.静态变量和实例变量区别</h4><p><strong>静态变量</strong>： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</p><p><strong>实例变量</strong>： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p><h3 id="5、内部类"><a href="#5、内部类" class="headerlink" title="5、内部类"></a>5、内部类</h3><h4 id="1-什么是内部类？"><a href="#1-什么是内部类？" class="headerlink" title="1. 什么是内部类？"></a>1. 什么是内部类？</h4><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。</p><h4 id="2-内部类的分类有哪些"><a href="#2-内部类的分类有哪些" class="headerlink" title="2. 内部类的分类有哪些"></a>2. 内部类的分类有哪些</h4><p>内部类可以分为四种：<strong>成员内部类</strong>、<strong>局部内部类</strong>、<strong>匿名内部类</strong>和<strong>静态内部类</strong>。</p><h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>定义在类内部的静态类，就是静态内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static variable:&quot;</span> + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，<code>new 外部类.静态内部类()</code>，如下：、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure><h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;visit outer static  variable:&quot;</span> + radius);</span><br><span class="line">           System.out.println(<span class="string">&quot;visit outer   variable:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式<code>外部类实例.new 内部类()</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure><h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><p>定义在方法中的内部类，就是局部内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">out_a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">STATIC_b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFunctionClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inner_c</span> <span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span>  <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStaticFunctionClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span></span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span>  <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法</p><p>定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，<code>new 内部类()</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStaticFunctionClass</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匿名内部类&quot;</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//匿名内部类必须继承或实现一个已有的接口 </span></span><br><span class="line"> <span class="keyword">interface</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了没有名字，匿名内部类还有以下特点：</p><ul><li><p>匿名内部类必须继承一个抽象类或者实现一个接口。</p></li><li><p>匿名内部类不能定义任何静态成员和静态方法。</p></li><li><p>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</p></li><li><p>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p></li></ul><p>匿名内部类创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类/接口&#123; </span><br><span class="line">  <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-内部类的优点"><a href="#3-内部类的优点" class="headerlink" title="3. 内部类的优点"></a>3. 内部类的优点</h4><p>我们为什么要使用内部类呢？因为它有以下优点：</p><ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li><li>内部类不为同一包的其他类所见，具有很好的封装性；</li><li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li><li>匿名内部类可以很方便的定义回调。</li></ul><h4 id="4-内部类有哪些应用场景"><a href="#4-内部类有哪些应用场景" class="headerlink" title="4. 内部类有哪些应用场景"></a>4. 内部类有哪些应用场景</h4><ol><li>一些多算法场合</li><li>解决一些非面向对象的语句块。</li><li>适当使用内部类，使得代码更加灵活和富有扩展性。</li><li>当某个类除了它的外部类，不再被其他的类使用时。</li></ol><h4 id="5-局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#5-局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="5. 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>5. 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><p>public class Outer {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">outMethod</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。</p><p>而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。</p><p>加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;局部变量：&quot;</span> + age);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类变量：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类变量：&quot;</span> + Outer.<span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">   in.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部变量：<span class="number">14</span></span><br><span class="line">内部类变量：<span class="number">13</span></span><br><span class="line">外部类变量：<span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="6、重写与重载"><a href="#6、重写与重载" class="headerlink" title="6、重写与重载"></a>6、重写与重载</h3><h4 id="1-构造器（constructor）是否可被重写（override）"><a href="#1-构造器（constructor）是否可被重写（override）" class="headerlink" title="1. 构造器（constructor）是否可被重写（override）"></a>1. 构造器（constructor）是否可被重写（override）</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p><h4 id="2-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#2-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="2. 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>2. 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p><strong>重载</strong>：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p><p><strong>重写</strong>：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</p><h3 id="7、对象相等判断"><a href="#7、对象相等判断" class="headerlink" title="7、对象相等判断"></a>7、对象相等判断</h3><h4 id="1-和-equals-的区别是什么"><a href="#1-和-equals-的区别是什么" class="headerlink" title="1. &#x3D;&#x3D; 和 equals 的区别是什么"></a>1. &#x3D;&#x3D; 和 equals 的区别是什么</h4><p><strong>&#x3D;&#x3D; :</strong> 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址)</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。</p><p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。<br>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</p><h4 id="2-hashCode-与-equals-重要"><a href="#2-hashCode-与-equals-重要" class="headerlink" title="2. hashCode 与 equals (重要)"></a>2. hashCode 与 equals (重要)</h4><p>HashSet如何检查重复</p><p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</p><p>hashCode和equals方法的关系</p><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p><p><strong>hashCode()介绍</strong></p><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p><p><strong>hashCode()与equals()的相关规定</strong></p><p>如果两个对象相等，则hashcode一定也是相同的</p><p>两个对象相等，对两个对象分别调用equals方法都返回true</p><p>两个对象有相同的hashcode值，它们也不一定是相等的</p><p><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></p><p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p><h3 id="8、值传递"><a href="#8、值传递" class="headerlink" title="8、值传递"></a>8、值传递</h3><h5 id="1-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#1-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="1.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>1.<strong>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</strong></h5><p>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p><h5 id="2-为什么-Java-中只有值传递"><a href="#2-为什么-Java-中只有值传递" class="headerlink" title="2.为什么 Java 中只有值传递"></a>2.<strong>为什么 Java 中只有值传递</strong></h5><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p><p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p><p><strong>例1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    swap(num1, num2);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 20</span><br></pre></td></tr></table></figure><p><img src="/.com//Snipaste_2024-02-02_15-31-57.jpg"></p><p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 例2.</strong></p><p><strong>例2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><img src="/.com//Snipaste_2024-02-02_15-33-41.jpg"></p><p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p><p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p><p><strong>例3：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Student x, Student y)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><p>交换之前：</p><p><img src="/.com//Snipaste_2024-02-02_15-37-29.jpg"></p><p>交换之后：</p><p><img src="/.com//Snipaste_2024-02-02_15-37-35.jpg"></p><p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p><p>下面再总结一下Java中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h5 id="3-值传递和引用传递有什么区别"><a href="#3-值传递和引用传递有什么区别" class="headerlink" title="3.值传递和引用传递有什么区别"></a>3.值传递和引用传递有什么区别</h5><p><strong>值传递</strong>：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p><p><strong>引用传递</strong>：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p><p>Java基础知识点总结归纳，超级全面！（2021版）</p><p>Java程序员-张凯</p><p>于 2021-05-03 12:28:26 发布</p><p>阅读量7.8w<br> 收藏 1.2k</p><p>点赞数 270<br>文章标签： Java基础知识点 java Java基础知识点整理 Java基础知识点总结归纳<br>版权<br>凯哥今天看了网上好多关于Java基础知识点汇总的博客，but，感觉都不尽如人意，要么不全面，要么不准确，要么排版太乱了！</p><p>所以今天花了一天时间整理了一份Java基础知识点总结归纳，超级全面！希望对大家有帮助哈~</p><p>由于本文篇幅过长，博主为了方便大家阅读和收藏，特意将本文转成了一份PDF版的文档。</p><p>需要PDF版的朋友可以关注微信公众号：Java团长，发送“ 基础知识 ”即可获取哈~</p><p>一、Java概述<br>1、何为编程<br>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。</p><p>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</p><p>2、什么是Java<br>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p><p>3、jdk1.5之后的三大版本<br>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）<br>Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</p><p>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）<br>Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</p><p>Java ME（J2ME，Java 2 Platform Micro Edition，微型版）<br>Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</p><p>4、JVM、JRE和JDK的关系<br>JVM<br>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p><p>JRE<br>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p><p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p><p>JDK<br>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p><p>JVM&amp;JRE&amp;JDK关系图：</p><p>5、什么是跨平台性？原理是什么<br>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p><p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p><p>6、Java语言有哪些特点<br>简单易学（Java语言的语法与C语言和C++语言很接近）</p><p>面向对象（封装，继承，多态）</p><p>平台无关性（Java虚拟机实现平台无关性）</p><p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</p><p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</p><p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</p><p>安全性</p><p>7、什么是字节码？采用字节码的最大好处是什么<br>字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>采用字节码的好处：</p><p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><p>先看下java中的编译器和解释器：</p><p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</p><p>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。</p><p>8、什么是Java程序的主类？应用程序和小程序的主类有何不同？<br>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p><p>9、Java应用程序与小程序之间有那些差别？<br>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p><p>10、Java和C++的区别<br>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p><p>都是面向对象的语言，都支持封装、继承和多态<br>Java不提供指针来直接访问内存，程序内存更加安全<br>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。<br>Java有自动内存管理机制，不需要程序员手动释放无用内存<br>11、Oracle JDK 和 OpenJDK 的对比<br>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；<br>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；<br>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；<br>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；<br>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；<br>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。<br>二、基础语法<br>1、数据类型</p><ol><li>Java有哪些数据类型<br>定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</li></ol><p>分类</p><p>基本数据类型<br>数值型<br>整数类型(byte,short,int,long)<br>浮点类型(float,double)<br>字符型(char)<br>布尔型(boolean)<br>引用数据类型<br>类(class)<br>接口(interface)<br>数组([])<br>Java基本数据类型图</p><ol start="2"><li><p>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上<br>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p></li><li><p>用最有效率的方法计算 2 乘以 8<br>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p></li><li><p>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少<br>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p></li><li><p>float f&#x3D;3.4;是否正确<br>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。</p></li><li><p>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗<br>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p></li></ol><p>而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1 + 1);其中有隐含的强制类型转换。</p><p>2、编码<br>Java语言采用何种编码方案？有何特点？<br>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><p>3、注释</p><ol><li>什么Java注释<br>定义：用于解释说明程序的文字</li></ol><p>分类</p><p>单行注释<br>格式： &#x2F;&#x2F; 注释文字<br>多行注释<br>格式： &#x2F;* 注释文字 <em>&#x2F;<br>文档注释<br>格式：&#x2F;</em>* 注释文字 *&#x2F;<br>作用</p><p>在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</p><p>注意事项：多行和文档注释都不能嵌套使用。</p><p>4、访问修饰符</p><ol><li>访问修饰符 public,private,protected,以及不写（默认）时的区别<br>定义：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</li></ol><p>分类</p><p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。<br>public : 对所有类可见。使用对象：类、接口、变量、方法</p><p>访问修饰符图</p><p>5、运算符<br>&amp;和&amp;&amp;的区别<br>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p><p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><p>6、关键字</p><ol><li><p>Java 有没有 goto<br>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p></li><li><p>final 有什么用？<br>用于修饰类、属性和方法；</p></li></ol><p>被final修饰的类不可以被继承<br>被final修饰的方法不可以被重写<br>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</p><ol start="3"><li>final finally finalize区别<br>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。<br>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。<br>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</li><li>this关键字的用法<br>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</li></ol><p>this的用法在java中大体可以分为3种：</p><p>①. 普通的直接引用，this相当于是指向当前对象本身。</p><p>②. 形参与成员名字重名，用this来区分：</p><p>public Person(String name, int age) {<br>    this.name &#x3D; name;<br>    this.age &#x3D; age;<br>}<br>③. 引用本类的构造函数</p><p>class Person{<br>    private String name;<br>    private int age;</p><pre><code>public Person() &#123;&#125; public Person(String name) &#123;    this.name = name;&#125;public Person(String name, int age) &#123;    this(name);    this.age = age;&#125;</code></pre><p>}</p><ol start="5"><li>super关键字的用法<br>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</li></ol><p>super也有三种用法：</p><p>①. 普通的直接引用</p><p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p><p>②. 子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p><p>class Person{<br>    protected String name;</p><pre><code>public Person(String name) &#123;    this.name = name;&#125;</code></pre><p>}</p><p>class Student extends Person{<br>    private String name;</p><pre><code>public Student(String name, String name1) &#123;    super(name);    this.name = name1;&#125; public void getInfo()&#123;    System.out.println(this.name);      //Child    System.out.println(super.name);     //Father&#125;</code></pre><p>}</p><p>public class Test {<br>    public static void main(String[] args) {<br>       Student s1 &#x3D; new Student(“Father”,”Child”);<br>       s1.getInfo();</p><pre><code>&#125;</code></pre><p>}</p><p>③. 引用父类构造函数</p><p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。<br>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p><ol start="6"><li>this与super的区别<br>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）<br>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）<br>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。<br>super()和this()均需放在构造方法内第一行。<br>尽管可以用this调用一个构造器，但却不能调用两个。<br>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。<br>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。<br>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li><li>static存在的主要意义<br>static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！</li></ol><p>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p><p>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p><ol start="8"><li>static的独特之处<br>被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。<br>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</li></ol><p>在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。<br>static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！<br>被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p><ol start="9"><li>static应用场景<br>因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。</li></ol><p>因此比较常见的static应用场景有：</p><p>修饰成员变量<br>修饰成员方法<br>静态代码块<br>修饰类【只能修饰内部类也就是静态内部类】<br>静态导包</p><ol start="10"><li>static注意事项<br>静态只能访问静态。<br>非静态既可以访问非静态的，也可以访问静态的。<br>7、流程控制语句</li><li>break ,continue ,return 的区别及作用<br>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</li></ol><p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p><p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p><ol start="2"><li>在 Java 中，如何跳出当前的多重嵌套循环<br>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</li></ol><p>public static void main(String[] args) {<br>    ok:<br>    for (int i &#x3D; 0; i &lt; 10; i++) {<br>        for (int j &#x3D; 0; j &lt; 10; j++) {<br>            System.out.println(“i&#x3D;” + i + “,j&#x3D;” + j);<br>            if (j &#x3D;&#x3D; 5) {<br>                break ok;<br>            }</p><pre><code>    &#125;&#125;</code></pre><p>}<br>三、面向对象<br>1、面向对象概述<br>面向对象和面向过程的区别<br>面向过程：</p><p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。</p><p>缺点：没有面向对象易维护、易复用、易扩展</p><p>面向对象：</p><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p><p>缺点：性能比面向过程低</p><p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p><p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p><p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p><p>2、面向对象三大特性</p><ol><li>面向对象的特征有哪些方面<br>面向对象的特征主要有以下几个方面：</li></ol><p>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><p>封装</p><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><p>继承</p><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p>关于继承如下 3 点请记住：</p><p>子类拥有父类非 private 的属性和方法。<br>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>子类可以用自己的方式实现父类的方法。（以后介绍）。<br>多态</p><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><p>其中Java 面向对象编程三大特性：封装 继承 多态</p><p>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p><p>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</p><p>关于继承如下 3 点请记住：</p><p>子类拥有父类非 private 的属性和方法。</p><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p><p>子类可以用自己的方式实现父类的方法。</p><p>多态性：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p><p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p><p>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；<br>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p><ol start="2"><li>什么是多态机制？Java语言是如何实现多态的？<br>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</li></ol><p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><p>多态的实现</p><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><p>继承：在多态中必须存在有继承关系的子类和父类。</p><p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p><p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p><p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p><p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p><ol start="3"><li>面向对象五大基本原则是什么（可选）<br>单一职责原则SRP(Single Responsibility Principle)<br>类的功能要单一，不能包罗万象，跟杂货铺似的。</li></ol><p>开放封闭原则OCP(Open－Close Principle)<br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</p><p>里式替换原则LSP(the Liskov Substitution Principle LSP)<br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</p><p>依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</p><p>接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p><p>3、类与接口</p><ol><li>抽象类和接口的对比<br>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</li></ol><p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p><p>相同点</p><p>接口和抽象类都不能实例化<br>都位于继承的顶端，用于被其他实现或继承<br>都包含抽象方法，其子类都必须覆写这些抽象方法</p><p>不同点</p><p>备注：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p><p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p><p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p><p>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。<br>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</p><ol start="2"><li><p>普通类和抽象类有哪些区别？<br>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类不能直接实例化，普通类可以直接实例化。</p></li><li><p>抽象类能使用 final 修饰吗？<br>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p></li><li><p>创建一个对象用什么关键字？对象实例与对象引用有何不同？<br>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</p></li></ol><p>4、变量与方法</p><ol><li>成员变量与局部变量的区别有哪些<br>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</li></ol><p>成员变量：方法外部，类内部定义的变量</p><p>局部变量：类的方法中的变量。</p><p>成员变量和局部变量的区别</p><p>作用域</p><p>成员变量：针对整个类有效。<br>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p><p>存储位置</p><p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。<br>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</p><p>生命周期</p><p>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：当方法调用完，或者语句结束后，就自动释放。</p><p>初始值</p><p>成员变量：有默认初始值。</p><p>局部变量：没有默认初始值，使用前必须赋值。</p><p>使用原则</p><p>在使用变量时需要遵循的原则为：就近原则<br>首先在局部范围找，有就使用；接着在成员位置找。</p><ol start="2"><li><p>在Java中定义一个不做事且没有参数的构造方法的作用<br>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p></li><li><p>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？<br>帮助子类做初始化工作。</p></li><li><p>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？<br>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p></li><li><p>构造方法有哪些特性？<br>名字与类名相同；</p></li></ol><p>没有返回值，但不能用void声明构造函数；</p><p>生成类的对象时自动执行，无需调用。</p><ol start="6"><li>静态变量和实例变量区别<br>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</li></ol><p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p><ol start="7"><li>静态变量与普通变量区别<br>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li></ol><p>还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</p><ol start="8"><li>静态方法和实例方法有何不同？<br>静态方法和实例方法的区别主要体现在两个方面：</li></ol><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。<br>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</p><ol start="9"><li><p>在一个静态方法内调用一个非静态成员为什么是非法的？<br>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p></li><li><p>什么是方法的返回值？返回值的作用是什么？<br>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p></li></ol><p>5、内部类</p><ol><li><p>什么是内部类？<br>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。</p></li><li><p>内部类的分类有哪些<br>内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p></li></ol><p>静态内部类</p><p>定义在类内部的静态类，就是静态内部类。</p><p>public class Outer {</p><pre><code>private static int radius = 1; static class StaticInner &#123;    public void visit() &#123;        System.out.println(&quot;visit outer static  variable:&quot; + radius);    &#125;&#125;</code></pre><p>}</p><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下：</p><p>Outer.StaticInner inner &#x3D; new Outer.StaticInner();<br>inner.visit();<br>成员内部类</p><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p><p>public class Outer {</p><pre><code>private static  int radius = 1;private int count =2; class Inner &#123;    public void visit() &#123;        System.out.println(&quot;visit outer static  variable:&quot; + radius);        System.out.println(&quot;visit outer   variable:&quot; + count);    &#125;&#125;</code></pre><p>}</p><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下：</p><p>Outer outer &#x3D; new Outer();<br>Outer.Inner inner &#x3D; outer.new Inner();<br>inner.visit();<br>局部内部类</p><p>定义在方法中的内部类，就是局部内部类。</p><p>public class Outer {</p><pre><code>private  int out_a = 1;private static int STATIC_b = 2; public void testFunctionClass()&#123;    int inner_c =3;    class Inner &#123;        private void fun()&#123;            System.out.println(out_a);            System.out.println(STATIC_b);            System.out.println(inner_c);        &#125;    &#125;    Inner  inner = new Inner();    inner.fun();&#125;public static void testStaticFunctionClass()&#123;    int d =3;    class Inner &#123;        private void fun()&#123;            // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量            System.out.println(STATIC_b);            System.out.println(d);        &#125;    &#125;    Inner  inner = new Inner();    inner.fun();&#125;</code></pre><p>}<br>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()，如下：</p><p> public static void testStaticFunctionClass(){<br>    class Inner {<br>    }<br>    Inner  inner &#x3D; new Inner();<br> }<br>匿名内部类</p><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p><p>public class Outer {</p><pre><code>private void test(final int i) &#123;    new Service() &#123;        public void method() &#123;            for (int j = 0; j &lt; i; j++) &#123;                System.out.println(&quot;匿名内部类&quot; );            &#125;        &#125;    &#125;.method();&#125;</code></pre><p> }<br> &#x2F;&#x2F;匿名内部类必须继承或实现一个已有的接口<br> interface Service{<br>    void method();<br>}<br>除了没有名字，匿名内部类还有以下特点：</p><p>匿名内部类必须继承一个抽象类或者实现一个接口。<br>匿名内部类不能定义任何静态成员和静态方法。<br>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。<br>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。<br>匿名内部类创建方式：</p><p>new 类&#x2F;接口{<br>  &#x2F;&#x2F;匿名内部类实现部分<br>}</p><ol start="3"><li>内部类的优点<br>我们为什么要使用内部类呢？因为它有以下优点：</li></ol><p>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！<br>内部类不为同一包的其他类所见，具有很好的封装性；<br>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。<br>匿名内部类可以很方便的定义回调。</p><ol start="4"><li>内部类有哪些应用场景<br>一些多算法场合<br>解决一些非面向对象的语句块。<br>适当使用内部类，使得代码更加灵活和富有扩展性。<br>当某个类除了它的外部类，不再被其他的类使用时。</li><li>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？<br>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？</li></ol><p>先看这段代码：</p><p>public class Outer {</p><pre><code>void outMethod()&#123;    final int a =10;    class Inner &#123;        void innerMethod()&#123;            System.out.println(a);        &#125;     &#125;&#125;</code></pre><p>}<br>以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p><ol start="6"><li><p>内部类相关，看程序说出运行结果<br>public class Outer {<br> private int age &#x3D; 12;</p><p> class Inner {<br> private int age &#x3D; 13;<br> public void print() {<br>     int age &#x3D; 14;<br>     System.out.println(“局部变量：” + age);<br>     System.out.println(“内部类变量：” + this.age);<br>     System.out.println(“外部类变量：” + Outer.this.age);<br> }<br> }</p><p> public static void main(String[] args) {<br> Outer.Inner in &#x3D; new Outer().new Inner();<br> in.print();<br> }</p></li></ol><p>}<br>运行结果：</p><p>局部变量：14<br>内部类变量：13<br>外部类变量：12<br>6、重写与重载</p><ol><li><p>构造器（constructor）是否可被重写（override）<br>构造器不能被继承，因此不能被重写，但可以被重载。</p></li><li><p>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？<br>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p></li></ol><p>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p><p>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</p><p>7、对象相等判断</p><ol><li>&#x3D;&#x3D; 和 equals 的区别是什么<br>&#x3D;&#x3D; : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址)</li></ol><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。</p><p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p><p>举个例子：</p><p>public class test1 {<br>    public static void main(String[] args) {<br>        String a &#x3D; new String(“ab”); &#x2F;&#x2F; a 为一个引用<br>        String b &#x3D; new String(“ab”); &#x2F;&#x2F; b为另一个引用,对象的内容一样<br>        String aa &#x3D; “ab”; &#x2F;&#x2F; 放在常量池中<br>        String bb &#x3D; “ab”; &#x2F;&#x2F; 从常量池中查找<br>        if (aa &#x3D;&#x3D; bb) &#x2F;&#x2F; true<br>            System.out.println(“aa&#x3D;&#x3D;bb”);<br>        if (a &#x3D;&#x3D; b) &#x2F;&#x2F; false，非同一对象<br>            System.out.println(“a&#x3D;&#x3D;b”);<br>        if (a.equals(b)) &#x2F;&#x2F; true<br>            System.out.println(“aEQb”);<br>        if (42 &#x3D;&#x3D; 42.0) { &#x2F;&#x2F; true<br>            System.out.println(“true”);<br>        }<br>    }<br>}<br>说明：</p><p>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。<br>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</p><ol start="2"><li>hashCode 与 equals (重要)<br>HashSet如何检查重复</li></ol><p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</p><p>hashCode和equals方法的关系</p><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p><p>hashCode()介绍</p><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p>为什么要有 hashCode</p><p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>hashCode()与equals()的相关规定</p><p>如果两个对象相等，则hashcode一定也是相同的</p><p>两个对象相等，对两个对象分别调用equals方法都返回true</p><p>两个对象有相同的hashcode值，它们也不一定是相等的</p><p>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</p><p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p><p>8、值传递</p><ol><li><p>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递<br>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p></li><li><p>为什么 Java 中只有值传递<br>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p></li></ol><p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p><p>下面通过 3 个例子来给大家说明</p><p>example 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><pre><code>swap(num1, num2); System.out.println(&quot;num1 = &quot; + num1);System.out.println(&quot;num2 = &quot; + num2);</code></pre><p>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br></pre></td></tr></table></figure><p>}<br>结果：</p><p>a &#x3D; 20<br>b &#x3D; 10<br>num1 &#x3D; 10<br>num2 &#x3D; 20<br>解析：</p><p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</p><p>example 2</p><pre><code>public static void main(String[] args) &#123;    int[] arr = &#123; 1, 2, 3, 4, 5 &#125;;    System.out.println(arr[0]);    change(arr);    System.out.println(arr[0]);&#125; public static void change(int[] array) &#123;    // 将数组的第一个元素变为0    array[0] = 0;&#125;</code></pre><p>结果：</p><p>1<br>0<br>解析：</p><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</p><p>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</p><p>example 3</p><p>public class Test {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">    Test.swap(s1, s2);</span><br><span class="line">    System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Student x, Student y)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>结果：</p><p>x:小李<br>y:小张<br>s1:小张<br>s2:小李<br>解析：</p><p>交换之前：</p><p>交换之后：</p><p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p><p>总结</p><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p><p>下面再总结一下Java中方法参数的使用情况：</p><p>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》<br>一个方法可以改变一个对象参数的状态。<br>一个方法不能让对象参数引用一个新的对象。</p><ol start="3"><li>值传递和引用传递有什么区别<br>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</li></ol><p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p><h3 id="9、Java包"><a href="#9、Java包" class="headerlink" title="9、Java包"></a>9、Java包</h3><h5 id="1-JDK-中常用的包有哪些"><a href="#1-JDK-中常用的包有哪些" class="headerlink" title="1. JDK 中常用的包有哪些"></a>1. JDK 中常用的包有哪些</h5><ul><li>java.lang：这个是系统的基础类；</li><li>java.io：这里面是所有输入输出有关的类，比如文件操作等；</li><li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</li><li>java.net：这里面是与网络有关的类；</li><li>java.util：这个是系统辅助类，特别是集合类；</li><li>java.sql：这个是数据库操作的类。</li></ul><h5 id="2-import-java和javax有什么区别"><a href="#2-import-java和javax有什么区别" class="headerlink" title="2.import java和javax有什么区别"></a>2.import java和javax有什么区别</h5><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。</p><p>所以，实际上java和javax没有区别。这都是一个名字。</p><h2 id="四、IO流"><a href="#四、IO流" class="headerlink" title="四、IO流"></a>四、IO流</h2><h3 id="1、java-中-IO-流分为几种"><a href="#1、java-中-IO-流分为几种" class="headerlink" title="1、java 中 IO 流分为几种?"></a>1、java 中 IO 流分为几种?</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li><p>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p></li><li><p>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p><p><img src="/.com//aaaa.png" alt="aaaa"></p><p><img src="/.com//aaaaaaaaaaaaaaa.png" alt="aaaaaaaaaaaaaaa"></p></li></ul><h3 id="2、Files的常用方法都有哪些？"><a href="#2、Files的常用方法都有哪些？" class="headerlink" title="2、Files的常用方法都有哪些？"></a>2、Files的常用方法都有哪些？</h3><ul><li>Files. exists()：检测文件路径是否存在。</li><li>Files. createFile()：创建文件。</li><li>Files. createDirectory()：创建文件夹。</li><li>Files. delete()：删除一个文件或目录。</li><li>Files. copy()：复制文件。</li><li>Files. move()：移动文件。</li><li>Files. size()：查看文件个数。</li><li>Files. read()：读取文件。</li><li>Files. write()：写入文件。</li></ul><h3 id="3、字节流和字符流的区别"><a href="#3、字节流和字符流的区别" class="headerlink" title="3、字节流和字符流的区别"></a>3、字节流和字符流的区别</h3><p>1.字节流读取的时候，读到一个字节就返回一个字节； 字符流使用了字节流读到一个或多个字节（中文对应的字节数是两个，在UTF-8码表中是3个字节）时。先去查指定的编码表，将查到的字符返回。<br>2.字节流可以处理所有类型数据，如：图片，MP3，AVI视频文件，而字符流只能处理字符数据。只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都用字节流。</p><h3 id="4、转换流"><a href="#4、转换流" class="headerlink" title="4、转换流"></a>4、转换流</h3><p>InputStreamReader 是字节流通向字符流的桥梁<br>OutputStreamWriter 是字符流通向字节流的桥梁<br>转换流可以将字节转成字符，原因在于，将获取到的字节通过查编码表获取到指定对应字符。<br>转换流的最强功能就是基于 字节流 + 编码表 。没有转换，没有字符流</p><h3 id="5、打印流"><a href="#5、打印流" class="headerlink" title="5、打印流"></a>5、打印流</h3><p>PrintWriter<br>PrintStream<br>注:<br>A:只操作目的地,不操作数据源<br>B:可以操作任意类型的数据<br>C:如果启用了自动刷新，在调用println(),printf(),format()方法的时候，能够换行并刷新<br>D:可以直接操作文件</p><h3 id="6、序列化流"><a href="#6、序列化流" class="headerlink" title="6、序列化流"></a>6、序列化流</h3><p>ObjectOutputStream序列化流<br>ObjectInputStream反序列化流<br>序列化：把对象作为一个整体按照流一样的方式传输或者存储。<br>反序列化：把网络中的流数据或者文件中的流数据还原成对象<br>主要方法有：<br>1.Object readObject();该方法抛出异常：ClassNotFountException。</p><ol start="2"><li>void writeObject(Object)：被写入的对象必须实现一个接口：Serializable，否则就会抛出：NotSerializableException<br>3.如果实现了该接口，想解决黄线问题就生成一个随机的serialVersionUID号码</li></ol><p>7、综合小案例:  键盘录入数据保存到文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//创建键盘录入</span></span><br><span class="line">    InputStream is=System.in;</span><br><span class="line">    <span class="comment">//将字节流转换为字符流</span></span><br><span class="line">    InputStreamReader isr=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line">    <span class="comment">//高效字符流读取数据</span></span><br><span class="line">    BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">    <span class="comment">//打印流写入数据,第一个true表示如果文件中有内容就追加数据,第二个true表示启用自动刷新</span></span><br><span class="line">    PrintWriter pw=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="literal">true</span>),<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    String line=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;over&quot;</span>.equals(line))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//PrintWriter启用自动刷新</span></span><br><span class="line">        pw.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    pw.close();</span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五、反射"><a href="#五、反射" class="headerlink" title="五、反射"></a>五、反射</h2><h3 id="1、什么是反射机制？"><a href="#1、什么是反射机制？" class="headerlink" title="1、什么是反射机制？"></a>1、什么是反射机制？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p><strong>静态编译和动态编译</strong></p><p><strong>静态编译：</strong>在编译时确定类型，绑定对象<br><strong>动态编译：</strong>运行时确定类型，绑定对象</p><h3 id="2、反射机制优缺点"><a href="#2、反射机制优缺点" class="headerlink" title="2、反射机制优缺点"></a>2、反射机制优缺点</h3><ul><li>优点： 运行期类型的判断，动态加载类，提高代码灵活度。</li><li>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li></ul><h3 id="3、-反射机制的应用场景有哪些？"><a href="#3、-反射机制的应用场景有哪些？" class="headerlink" title="3、 反射机制的应用场景有哪些？"></a>3、 反射机制的应用场景有哪些？</h3><p>反射是框架设计的灵魂。</p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p><h3 id="4、Java获取反射的三种方法"><a href="#4、Java获取反射的三种方法" class="headerlink" title="4、Java获取反射的三种方法"></a>4、Java获取反射的三种方法</h3><p>1.通过new对象实现反射机制</p><p>2.通过路径实现反射机制</p><p>3.通过类名实现反射机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Get</span> &#123;</span><br><span class="line">    <span class="comment">//获取反射机制三种方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//方式一(通过建立对象)</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">classobj1</span> <span class="operator">=</span> stu.getClass();</span><br><span class="line">        System.out.println(classobj1.getName());</span><br><span class="line">        <span class="comment">//方式二（所在通过路径-相对路径）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">classobj2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line">        System.out.println(classobj2.getName());</span><br><span class="line">        <span class="comment">//方式三（通过类名）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">classobj3</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(classobj3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、网络编程"><a href="#六、网络编程" class="headerlink" title="六、网络编程"></a>六、网络编程</h2><h3 id="1、网络协议是什么？"><a href="#1、网络协议是什么？" class="headerlink" title="1、网络协议是什么？"></a>1、网络协议是什么？</h3><p>在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p><h3 id="2、为什么要对网络协议分层？"><a href="#2、为什么要对网络协议分层？" class="headerlink" title="2、为什么要对网络协议分层？"></a>2、为什么要对网络协议分层？</h3><ul><li>简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。</li><li>灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。</li><li>易于实现和维护。</li><li>促进标准化工作。分开后，每层功能可以相对简单地被描述。</li></ul><p>网络协议分层的缺点： 功能可能出现在多个层里，产生了额外开销。</p><p>四层协议，五层协议和七层协议的关系如下：</p><ul><li>TCP&#x2F;IP是一个四层的体系结构，主要包括：应用层、运输层、网际层和网络接口层。</li><li>五层协议的体系结构主要包括：应用层、运输层、网络层，数据链路层和物理层。</li><li>OSI七层协议模型主要包括是：应用层（Application）、表示层（Presentation）、会话层（Session）、运输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</li></ul><p><img src="/.com//20200316173310511.png" alt="20200316173310511"></p><p>注：五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构。</p><h3 id="3、TCP-UDP协议"><a href="#3、TCP-UDP协议" class="headerlink" title="3、TCP&#x2F;UDP协议"></a>3、TCP&#x2F;UDP协议</h3><p><strong>UDP协议</strong></p><ul><li><p>用户数据报协议(User Datagram Protocol)</p></li><li><p>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p></li><li><p>由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</p></li><li><p>例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议</p></li></ul><p><strong>TCP协议</strong></p><ul><li><p>传输控制协议 (Transmission Control Protocol)</p></li><li><p>TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”</p></li><li><p>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠</p><p>第一次握手，客户端向服务器端发出连接请求，等待服务器确认</p><p>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求</p><p>第三次握手，客户端再次向服务器端发送确认信息，确认连接</p></li><li><p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等</p></li></ul><h3 id="4、UDP通信程序"><a href="#4、UDP通信程序" class="headerlink" title="4、UDP通信程序"></a>4、UDP通信程序</h3><h4 id="1、UDP发送数据"><a href="#1、UDP发送数据" class="headerlink" title="1、UDP发送数据"></a>1、UDP发送数据</h4><ul><li><p>Java中的UDP通信</p></li><li><p>UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念</p></li><li><p>Java提供了DatagramSocket类作为基于UDP协议的Socket</p></li><li><p>构造方法</p><p>|方法名|说明| |-|-| |DatagramSocket()|创建数据报套接字并将其绑定到本机地址上的任何可用端口| |DatagramPacket(byte[] buf,int len,InetAddress add,int port)|创建数据包,发送长度为len的数据包到指定主机的指定端口|</p></li><li><p>相关方法</p><p>|方法名|说明| |-|-| |void send(DatagramPacket p)|发送数据报包| |void close()|关闭数据报套接字| |void receive(DatagramPacket p)|从此套接字接受数据报包|</p></li><li><p>发送数据的步骤</p></li><li><p>创建发送端的Socket对象(DatagramSocket)</p></li><li><p>个创建数据，并把数据打包</p></li><li><p>调用DatagramSocket对象的方法发送数据</p></li><li><p>关闭发送端</p></li><li><p>代码演示</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="comment">// DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建数据，并把数据打包</span></span><br><span class="line">        <span class="comment">//DatagramPacket(byte[] buf, int length, InetAddress address, int port)</span></span><br><span class="line">        <span class="comment">//构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。</span></span><br><span class="line">        <span class="type">byte</span>[] bys = <span class="string">&quot;hello,udp,我来了&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys,bys.length,InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用DatagramSocket对象的方法发送数据</span></span><br><span class="line">        <span class="comment">//void send(DatagramPacket p) 从此套接字发送数据报包</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭发送端</span></span><br><span class="line">        <span class="comment">//void close() 关闭此数据报套接字</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、UDP接收数据"><a href="#2、UDP接收数据" class="headerlink" title="2、UDP接收数据"></a>2、UDP接收数据</h4><ul><li><p>接收数据的步骤</p></li><li><p>创建接收端的Socket对象(DatagramSocket)</p></li><li><p>创建一个数据包，用于接收数据</p></li><li><p>调用DatagramSocket对象的方法接收数据</p></li><li><p>解析数据包，并把数据在控制台显示</p></li><li><p>关闭接收端</p></li><li><p>构造方法</p><p>|方法名|说明| |-|-| |DatagramPacket(byte[] buf, int len)|创建一个DatagramPacket用于接收长度为len的数据包|</p></li><li><p>相关方法</p><p>|方法名|说明| |-|-| |byte[] getData()|返回数据缓冲区| |int getLength()|返回要发送的数据的长度或接收的数据的长度|</p></li><li><p>示例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">          <span class="comment">//创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">          <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//创建一个数据包，用于接收数据</span></span><br><span class="line">          <span class="type">byte</span>[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">          <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys, bys.length);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">          ds.receive(dp);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//解析数据包，并把数据在控制台显示</span></span><br><span class="line">          System.out.println(<span class="string">&quot;数据是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(), <span class="number">0</span>,                                             dp.getLength()));</span><br><span class="line">        &#125;</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、UDP通信程序练习"><a href="#3、UDP通信程序练习" class="headerlink" title="3、UDP通信程序练习"></a>3、UDP通信程序练习</h4><ul><li><p>案例需求</p><p>UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束</p><p>UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收</p></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    UDP发送数据：</span></span><br><span class="line"><span class="comment">        数据来自于键盘录入，直到输入的数据是886，发送数据结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">//键盘录入数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="comment">//输入的数据是886，发送数据结束</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;886&quot;</span>.equals(s)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建数据，并把数据打包</span></span><br><span class="line">            <span class="type">byte</span>[] bys = s.getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys, bys.length, InetAddress.getByName(<span class="string">&quot;192.168.1.66&quot;</span>), <span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用DatagramSocket对象的方法发送数据</span></span><br><span class="line">            ds.send(dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭发送端</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    UDP接收数据：</span></span><br><span class="line"><span class="comment">        因为接收端不知道发送端什么时候停止发送，故采用死循环接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//创建一个数据包，用于接收数据</span></span><br><span class="line">            <span class="type">byte</span>[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys, bys.length);</span><br><span class="line">            <span class="comment">//调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">            ds.receive(dp);</span><br><span class="line">            <span class="comment">//解析数据包，并把数据在控制台显示</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(), <span class="number">0</span>, dp.getLength()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭接收端</span></span><br><span class="line"><span class="comment">//        ds.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、UDP三种通讯方式"><a href="#4、UDP三种通讯方式" class="headerlink" title="4、UDP三种通讯方式"></a>4、UDP三种通讯方式</h4><ul><li><p>单播</p><p>单播用于两个主机之间的端对端通信</p></li><li><p>组播</p><p>组播用于对一组特定的主机进行通信</p></li><li><p>广播</p><p>广播用于一个主机对整个局域网上所有主机上的数据通信</p></li></ul><h4 id="5、UDP组播实现"><a href="#5、UDP组播实现" class="headerlink" title="5、UDP组播实现"></a>5、UDP组播实现</h4><ul><li>实现步骤</li><li>发送端<ol><li>创建发送端的Socket对象(DatagramSocket)</li><li>创建数据，并把数据打包(DatagramPacket)</li><li>调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)</li><li>释放资源</li></ol></li><li>接收端<ol><li>创建接收端Socket对象(MulticastSocket)</li><li>创建一个箱子,用于接收数据</li><li>把当前计算机绑定一个组播地址</li><li>将数据接收到箱子中</li><li>解析数据包,并打印数据</li><li>释放资源</li></ol></li><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClinetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello 组播&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;224.0.1.0&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">// 2. 创建数据，并把数据打包(DatagramPacket)</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,address,port);</span><br><span class="line">        <span class="comment">// 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建接收端Socket对象(MulticastSocket)</span></span><br><span class="line">        <span class="type">MulticastSocket</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MulticastSocket</span>(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 2. 创建一个箱子,用于接收数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 3. 把当前计算机绑定一个组播地址,表示添加到这一组中.</span></span><br><span class="line">        ms.joinGroup(InetAddress.getByName(<span class="string">&quot;224.0.1.0&quot;</span>));</span><br><span class="line">        <span class="comment">// 4. 将数据接收到箱子中</span></span><br><span class="line">        ms.receive(dp);</span><br><span class="line">        <span class="comment">// 5. 解析数据包,并打印数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = dp.getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> dp.getLength();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,length));</span><br><span class="line">        <span class="comment">// 6. 释放资源</span></span><br><span class="line">        ms.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、UDP广播实现"><a href="#6、UDP广播实现" class="headerlink" title="6、UDP广播实现"></a>6、UDP广播实现</h4><ul><li>实现步骤</li><li>发送端<ol><li>创建发送端Socket对象(DatagramSocket)</li><li>创建存储数据的箱子,将广播地址封装进去</li><li>发送数据</li><li>释放资源</li></ol></li><li>接收端<ol><li>创建接收端的Socket对象(DatagramSocket)</li><li>创建一个数据包，用于接收数据</li><li>调用DatagramSocket对象的方法接收数据</li><li>解析数据包，并把数据在控制台显示</li><li>关闭接收端</li></ol></li><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">          <span class="comment">// 1. 创建发送端Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">// 2. 创建存储数据的箱子,将广播地址封装进去</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;广播 hello&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;255.255.255.255&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,address,port);</span><br><span class="line">        <span class="comment">// 3. 发送数据</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 2. 创建一个数据包，用于接收数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 3. 调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">        ds.receive(dp);</span><br><span class="line">        <span class="comment">// 4. 解析数据包，并把数据在控制台显示</span></span><br><span class="line">        <span class="type">byte</span>[] data = dp.getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> dp.getLength();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,length));</span><br><span class="line">        <span class="comment">// 5. 关闭接收端</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、TCP通信程序"><a href="#5、TCP通信程序" class="headerlink" title="5、TCP通信程序"></a>5、TCP通信程序</h3><h4 id="1、TCP发送数据"><a href="#1、TCP发送数据" class="headerlink" title="1、TCP发送数据"></a>1、TCP发送数据</h4><ul><li><p>Java中的TCP通信</p></li><li><p>Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。</p></li><li><p>Java为客户端提供了Socket类，为服务器端提供了ServerSocket类</p></li><li><p>构造方法</p><p>|方法名|说明| |-|-| |Socket(InetAddress address,int port)|创建流套接字并将其连接到指定IP指定端口号| |Socket(String host, int port)|创建流套接字并将其连接到指定主机上的指定端口号|</p></li><li><p>相关方法</p><p>|方法名|说明| |-|-| |InputStream getInputStream()|返回此套接字的输入流| |OutputStream getOutputStream()|返回此套接字的输出流|</p></li><li><p>示例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//TCP协议，发送数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建Socket对象</span></span><br><span class="line">        <span class="comment">//细节：在创建对象的同时会连接服务端</span></span><br><span class="line">        <span class="comment">//      如果连接不上，代码会报错</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.可以从连接通道中获取输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//写出数据</span></span><br><span class="line">        os.write(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、TCP接收数据"><a href="#2、TCP接收数据" class="headerlink" title="2、TCP接收数据"></a>2、TCP接收数据</h4><ul><li><p>构造方法</p><p>|方法名|说明| |-|-| |ServerSocket(int port)|创建绑定到指定端口的服务器套接字|</p></li><li><p>相关方法</p><p>|方法名|说明| |-|-| |Socket accept()|监听要连接到此的套接字并接受它|</p></li><li><p>注意事项</p></li></ul><ol><li>accept方法是阻塞的,作用就是等待客户端连接</li><li>客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接</li><li>针对客户端来讲,是往外写的,所以是输出流 针对服务器来讲,是往里读的,所以是输入流</li><li>read方法也是阻塞的</li><li>客户端在关流的时候,还多了一个往服务器写结束标记的动作</li><li>最后一步断开连接,通过四次挥手协议保证连接终止</li></ol><ul><li><p>三次握手和四次挥手</p></li><li><p>三次握手</p><p><img src="/.com//image1.png" alt="image1">!](.&#x2F;assets&#x2F;image1.png)</p></li><li><p>四次挥手</p><p><img src="/.com//image2.png" alt="image2">!](.&#x2F;assets&#x2F;image2.png)</p></li><li><p>示例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//TCP协议，接收数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象ServerSocker</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.监听客户端的链接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.从连接通道中获取输入流读取数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、TCP程序练习（传输中文）"><a href="#3、TCP程序练习（传输中文）" class="headerlink" title="3、TCP程序练习（传输中文）"></a>3、TCP程序练习（传输中文）</h4><p>发送端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//TCP协议，发送数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建Socket对象</span></span><br><span class="line">        <span class="comment">//细节：在创建对象的同时会连接服务端</span></span><br><span class="line">        <span class="comment">//      如果连接不上，代码会报错</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.可以从连接通道中获取输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//写出数据</span></span><br><span class="line">        os.write(<span class="string">&quot;你好你好&quot;</span>.getBytes());<span class="comment">//12字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//TCP协议，接收数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象ServerSocker</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.监听客户端的链接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.从连接通道中获取输入流读取数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = br.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、多线程"><a href="#七、多线程" class="headerlink" title="七、多线程"></a>七、多线程</h2><h3 id="1、线程和进程"><a href="#1、线程和进程" class="headerlink" title="1、线程和进程"></a>1、线程和进程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进程：</span><br><span class="line">是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间。</span><br><span class="line">线程：</span><br><span class="line">是进程中的一个执行路径，共享一个内存空间，线程之间可以自由切换，并发执行，一个进程最少有一个线程。</span><br><span class="line">线程实际上是在进程基础之上的进一步划分，一个进程启动之后，里面的若干执行路径又可以划分成若干个线程。</span><br></pre></td></tr></table></figure><h3 id="2、线程调度"><a href="#2、线程调度" class="headerlink" title="2、线程调度"></a>2、线程调度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">分时调度</span><br><span class="line">所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。</span><br><span class="line"></span><br><span class="line">抢占式调度</span><br><span class="line">优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），java使用的为抢占式调度。</span><br><span class="line">CPU使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核心而言，某个时刻，只能执行一个线程，而CPU在多个线程间切换速度相对我们的感觉要快，看上去就是 在同一时刻运行，其实，多线程程序（基于一个CPU）并不能提高程序的运行速度，但能够提高程序的运行效率，让CPU使用率更高。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩展：数据库服务器，上千线程使用数据库，数据库只有8个CPU，同时开启1k个连接，让1k个人操作他，8个CPU交替执行效率快，还是1k个人排队用8个CPU快?</span><br><span class="line">答：1k人排队用8个CPU效率更高，（A完成B开始，B完成C开始），缺少了切换的时间。</span><br></pre></td></tr></table></figure><h3 id="3、同步与异步"><a href="#3、同步与异步" class="headerlink" title="3、同步与异步"></a>3、同步与异步</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">之前谈的线程安全是同步，线程不安全是异步。</span><br><span class="line">同步：排队执行，效率低但是安全</span><br><span class="line">异步：同时执行，效率高但是数据不安全</span><br></pre></td></tr></table></figure><h3 id="4、并发与并行"><a href="#4、并发与并行" class="headerlink" title="4、并发与并行"></a>4、并发与并行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">并发：指两个or多个事件在 同一个时间段内 发生</span><br><span class="line">并行：指两个or多个事件在 同一时刻 发生（同时发生）</span><br></pre></td></tr></table></figure><h3 id="5、实现多线程的三种方式"><a href="#5、实现多线程的三种方式" class="headerlink" title="5、实现多线程的三种方式"></a>5、实现多线程的三种方式</h3><h4 id="1、继承Thread"><a href="#1、继承Thread" class="headerlink" title="1、继承Thread"></a>1、继承Thread</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread是Java提供的线程类，继承了该类的就是一个线程类。</span><br><span class="line"></span><br><span class="line">主线程和分支线程是并发执行的，谁在前谁在后  是随机的  抢占式分配</span><br><span class="line"></span><br><span class="line">编写一个类extends Thread，重写线程类的run方法，触发方式是调用Thread对象的start()方法启动任务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由一个线程执行的方法，那么这个方法也会执行在这个线程里面。</span><br><span class="line">每个线程都有自己的栈空间，共用一份堆内存。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line"> System.out.println(i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadDemo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">MyThread</span> <span class="variable">my1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"> <span class="type">MyThread</span> <span class="variable">my2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="comment">// my1.run();</span></span><br><span class="line"><span class="comment">// my2.run();</span></span><br><span class="line"> <span class="comment">//void start() 导致此线程开始执⾏; Java虚拟机调⽤此线程的run⽅法</span></span><br><span class="line"> my1.start();</span><br><span class="line"> my2.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>两个⼩问题 为什么要重写run()⽅法？ </p><ul><li>因为run()是⽤来封装被线程执⾏的代码</li></ul></li><li><p>run()⽅法和start()⽅法的区别？</p><ul><li>run()：封装线程执⾏的代码，直接调⽤，相当于普通⽅法的调⽤ </li><li>start()：启动线程；然后由JVM调⽤此线程的run()⽅法</li></ul></li></ul><h4 id="2、实现Runnable接口"><a href="#2、实现Runnable接口" class="headerlink" title="2、实现Runnable接口"></a>2、实现Runnable接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">编写一个类implements Runnable接口，并实现run()方法</span><br><span class="line"></span><br><span class="line">实现Runnable与继承Thread相比有如下优势：</span><br><span class="line">1.通过创建任务，然后给线程分配的方式来实现的多线程，更适合多个线程同时执行相同任务的情况。即1个任务多个线程执行，很方便。</span><br><span class="line">2.可以避免单继承所带来的局限性。(最有优势的点)。Java中extends只能继承一个类，单继承，implements是实现接口，可以多实现，并且还可以extends一个类。</span><br><span class="line">3.任务与线程本身是分离的，提高了程序的健壮性。</span><br><span class="line">4.后续学习的线程池技术（管理的是任务而不是线程），只接受Runnable类型的任务，不接受Thread类型的线程。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableDemo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">//创建MyRunnable类的对象</span></span><br><span class="line"> <span class="type">MyRunnable</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"> <span class="comment">//创建Thread类的对象，把MyRunnable对象作为构造⽅法的参数</span></span><br><span class="line"> <span class="comment">//Thread(Runnable target)</span></span><br><span class="line"><span class="comment">// Thread t1 = new Thread(my);</span></span><br><span class="line"><span class="comment">// Thread t2 = new Thread(my);</span></span><br><span class="line"> <span class="comment">//Thread(Runnable target, String name)</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">&quot;坦克&quot;</span>);</span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">&quot;⻜机&quot;</span>);</span><br><span class="line"> <span class="comment">//启动线程</span></span><br><span class="line"> t1.start();</span><br><span class="line"> t2.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、Callable接口"><a href="#3、Callable接口" class="headerlink" title="3、Callable接口"></a>3、Callable接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java中的第三种线程实现方式</span><br><span class="line">创建线程一般就继承Thread和实现Runnable，这两种方法创建的线程和主线程是一块执行的，两个一块走。</span><br><span class="line">Callable实现线程的话既可以两个一块走，也可以实现主线程等子线程执行完毕返回结果</span><br></pre></td></tr></table></figure><h5 id="1、Runnable与Callable"><a href="#1、Runnable与Callable" class="headerlink" title="1、Runnable与Callable"></a>1、Runnable与Callable</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">接口定义</span><br><span class="line">//Callable接口</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line">//Runnable接口</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、Callable使用步骤"><a href="#2、Callable使用步骤" class="headerlink" title="2、Callable使用步骤"></a>2、Callable使用步骤</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 编写类实现Callable接口 , 实现call方法</span><br><span class="line">    class XXX implements Callable&lt;T&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public &lt;T&gt; call() throws Exception &#123;</span><br><span class="line">        return T;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">2. 创建FutureTask对象 , 并传入第一步编写的Callable类对象</span><br><span class="line">FutureTask&lt;Integer&gt; future = new FutureTask&lt;&gt;(callable);</span><br><span class="line">3. 通过Thread,启动线程</span><br><span class="line">new Thread(future).start();</span><br><span class="line"></span><br><span class="line">Callable相对麻烦一点，实现Callable接口的类需要使用泛型，任务执行完毕以后进行return返回什么类型的结果给启动线程的人。</span><br><span class="line"></span><br><span class="line">FutureTask有get()方法获取线程执行的结果，但要知道，比如说主线程调用了线程A，线程A需要花10s完成某件事情并返回结果，那么主线程如果没调用get方法，它就不会等这10s，并发执行两个线程，但如果调了这个方法，主线程就会等这10s，等待线程A执行完毕，主线程获取结果之后再往下执行。</span><br><span class="line">还有一个get(long timeout,TimeUnit unit)，给一个最多能能带的时间，要是超时，算了不要了。</span><br><span class="line"></span><br><span class="line">FutureTask对象名.isDone()可以判断任务是否执行完毕</span><br><span class="line">FutureTask对象名.cancel(true)  取消任务，其返回值为true 取消成功，任务还没完成被干掉了。return FALSE的情况绝大多数是因为任务已经执行完毕，执行成功了，没有办法再取消了。</span><br><span class="line"></span><br><span class="line">该方法作为了解，用得并不多。</span><br></pre></td></tr></table></figure><h3 id="6、Thread类"><a href="#6、Thread类" class="headerlink" title="6、Thread类"></a>6、Thread类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">构造方法：</span><br><span class="line">Thread(Runnable target) 分配新的 Thread对象。  </span><br><span class="line">Thread(Runnable target, String name) 分配新的 Thread对象。不仅传一个任务，也可以传任务name。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常用方法：</span><br><span class="line">getName()   返回此线程名称</span><br><span class="line">getId()    返回此Thread的标识符</span><br><span class="line">getPriority()    返回此线程的优先级</span><br><span class="line">getPriority(int newPriority)    更改此线程的优先级，控制线程抢到时间片的几率  可以传入静态修饰的常量  MAX_PRIORITY(线程可以拥有的最大优先级)  MIN_PRIORITY(线程可以拥有的最低优先级)   NORM_PRIORITY(分配给线程的默认优先级)</span><br><span class="line">start()    此线程开始执行，Java虚拟机调用此线程的run方法。</span><br><span class="line">stop()    已过时，这种方式本质上不安全。比如 正在IO，停了，正在使用某些资源无法释放，资源依然被占用。</span><br><span class="line">那么怎么停止线程这一单独执行路径呢？可以设置变量作为标记，线程一直监听该变量的值，一旦变了，通知线程，线程自杀，run方法return 。</span><br><span class="line">sleep(long millis)    导致当前正在执行的线程休眠(暂时停止执行)指定的毫秒数。</span><br><span class="line">sleep(long millis,int nanos)    导致当前正在执行的线程休眠(暂时停止执行)指定的毫秒数加上指定的纳秒数。</span><br><span class="line">sleep很常见，比如想每个1秒输出一个数字，则sleep(1000)</span><br><span class="line">setDaemon(boolean on)    将此线程标记为守护线程(当所有用户线程全部死亡后，守护线程自动死亡，它依附于用户线程)or用户线程(主线程和子线程都称为用户线程，所有用户线程必须全部死亡，程序才会结束)</span><br></pre></td></tr></table></figure><h4 id="1、设置和获取线程名称"><a href="#1、设置和获取线程名称" class="headerlink" title="1、设置和获取线程名称"></a>1、设置和获取线程名称</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread类有一个static方法currentThread()获取当前线程，所以可以通过 类名.方法名 调用该方法。</span><br><span class="line">getName()方法返回线程名称</span><br><span class="line">构造时不传name也有默认name——Thread-0、Thread-1...</span><br><span class="line"></span><br><span class="line">也可以new出来接收一下，设置线程name,再start方法调用run</span><br></pre></td></tr></table></figure><h4 id="2、线程休眠"><a href="#2、线程休眠" class="headerlink" title="2、线程休眠"></a>2、线程休眠</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread类的static方法sleep，也是直接通过 类.方法名 方式调用。</span><br><span class="line">下图运行时会每隔一秒输出一个数字</span><br></pre></td></tr></table></figure><h4 id="3、线程阻塞-interrupt"><a href="#3、线程阻塞-interrupt" class="headerlink" title="3、线程阻塞 interrupt()"></a>3、线程阻塞 interrupt()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不只指的是线程休眠了 睡了，线程是一条执行路径，比如一个线程执行路径代码100行，可能有10行是读取某个文件，这个文件读取耗时1s，那么这1秒也是阻塞的，它停在那读文件，后面读完才会继续执行。</span><br><span class="line">可以把线程阻塞简单理解为所有比较耗时间的操作，比如常见的文件读取，会导致线程等待在那个位置，代码不会继续执行，除非文件读完。</span><br><span class="line">再比如说等待用户输入，用户不输入，代码就会等在那不会继续执行，线程阻塞 又称为耗时操作。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在需要杀死线程的代码块处调用 线程对象.interrupt()</span><br><span class="line">调用该方法会告知Thread该死亡了，Thread之后怎么办还是看Thread try到中断异常后如何处理的代码块。</span><br><span class="line">就会进入该线程run方法的try catch中断异常，然后怎么做是看程序员在catch异常后的catch块里写的什么操作，一般这个位置拿来释放资源(交代线程后事)，然后return，return即正常结束了run方法，Thread正常自杀。</span><br></pre></td></tr></table></figure><p><img src="/.com//s1-1709083445233-32.png" alt="s1"></p><p><img src="/.com//s2-1709083445234-35.png" alt="s2"></p><p><img src="/.com//s3-1709083445234-33.png" alt="s3"></p><h4 id="4、守护线程"><a href="#4、守护线程" class="headerlink" title="4、守护线程"></a>4、守护线程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程：分为守护线程和用户线程</span><br><span class="line">用户线程：当一个进程不包含任何的存活的用户线程时，进程结束。</span><br><span class="line">守护线程：守护用户线程的，当最后一个用户线程结束时，所有守护线程自动死亡。</span><br><span class="line"></span><br><span class="line">直接创建的线程都是用户线程，若想设置守护线程需要创建Thread对象之后，start之前调用setDaemon方法，实参为true。</span><br><span class="line">主线程输出到5，main方法还要结束，此时子线程又输出了一个6，这是在上一个中断线程的源码的基础上加了一个设置守护线程的方法。</span><br></pre></td></tr></table></figure><p><img src="/.com//a1-1709083445234-34.png" alt="a1"></p><h4 id="5、线程安全问题"><a href="#5、线程安全问题" class="headerlink" title="5、线程安全问题"></a>5、线程安全问题</h4><h4 id="1、线程不安全"><a href="#1、线程不安全" class="headerlink" title="1、线程不安全"></a>1、线程不安全</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">举个例子，不能一直空说大汉吃一碗面</span><br><span class="line">卖票，实现Runnable的任务类，类的方法就是对当前票数--，sleep是故意为了让它出线程不安全的问题，演示线程不安全的事，启动三个Thread，共同执行卖票这个任务。</span><br><span class="line"></span><br><span class="line">分析结果：单看逻辑，怎么都不会出现负数。出现负数是因为有可能A线程发现count为1(极端情况)进入while循环，还没进行count--操作，其他两个线程插足(抢到时间片)也通过count&gt;0进入线程，所以后面进行count--，出现了-1   -2</span><br></pre></td></tr></table></figure><h4 id="2、线程安全"><a href="#2、线程安全" class="headerlink" title="2、线程安全"></a>2、线程安全</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先明确线程不安全的原因：</span><br><span class="line">多个线程同时执行，去同时操作一个数据，导致某个数据看到的和在自己使用时数据不一致，因为其看到的和使用的中间间隔代码执行时被其他线程插足了(其他线程进来把数据改了)，所以最终导致运行不符合预期。</span><br><span class="line"></span><br><span class="line">很简单，就让某个线程在执行 看到的和使用时的数据 之间的代码块时，其他线程不插足，排队执行。</span><br><span class="line">大汉排队吃锅里的食物，每个人看到的和吃到嘴里的 不会有差异。</span><br><span class="line"></span><br><span class="line">关于线程同步，有三种不同的关于让线程排队执行的方式，都是通过上锁，加锁的方式。</span><br></pre></td></tr></table></figure><h5 id="1、实现线程安全1-同步代码块"><a href="#1、实现线程安全1-同步代码块" class="headerlink" title="1、实现线程安全1-同步代码块"></a>1、实现线程安全1-同步代码块</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">可以简单认为，被括住的代码块是排队执行的。</span><br><span class="line">格式</span><br><span class="line">synchronized(锁对象)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Java中任何对象都可以作为锁对象存在，可以认为任何对象都可以打锁标记。打锁标记我们不用管，是内存底层的机制。线程会观察锁对象是否打了锁的标记，如果被打了，说明有人正在执行，他就会等，一直等，一直看标记是不是解锁了。某个线程执行完毕后，解锁，其他人抢，抢到就上锁。一般回首掏比较nb，见下图的运行结果，大部分是Thread-0抢到了。</span><br><span class="line">注意：100个线程要上同一把锁才能实现排队的效果。</span><br><span class="line"></span><br><span class="line">下图就是在卖票的例子上加了一个private Object o = new Object()和synchronized  就实现了线程安全。 </span><br><span class="line">卖票的例子   就new了一个Ticket对象(任务)，所以线程用的是一个锁对象o。</span><br></pre></td></tr></table></figure><p><img src="/.com//a2-1709083445234-38.png" alt="a2">!](.&#x2F;assets&#x2F;a2.png)</p><p><img src="/.com//a3-1709083445234-36.png" alt="a3">!](.&#x2F;assets&#x2F;a3.png)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有线程要共用一把锁，线程.start()方法会调用run方法，如果在run方法里new 锁对象，则成了每个线程都有自己独立的锁，就没有线程安全的说法了。如下图，还是会出现-1  -2</span><br></pre></td></tr></table></figure><p><img src="/.com//a4-1709083445234-37.png" alt="a4">!](.&#x2F;assets&#x2F;a4.png)</p><h5 id="2、实现线程安全2-同步方法"><a href="#2、实现线程安全2-同步方法" class="headerlink" title="2、实现线程安全2-同步方法"></a>2、实现线程安全2-同步方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">同步代码甚至可以以一行代码为单位进行加锁，但同步方法以方法为单位进行加锁。</span><br><span class="line">格式</span><br><span class="line">给方法添加synchronized修饰词</span><br><span class="line"></span><br><span class="line">这里的锁就是任务Ticket对象，一个任务多个线程调用，才会安全。</span><br><span class="line">Runnable run = new Ticket();</span><br><span class="line">new Thread(run).start();</span><br><span class="line">new Thread(run).start();</span><br><span class="line">new Thread(run).start();</span><br><span class="line"></span><br><span class="line">同步方法用的是一个this这把锁，要是有多个同步方法，or有个同步代码是传的this为锁对象，则若有一个同步方法在执行，其他同步方法都执行不了(Thread-0上锁之后，其他Thread都不能执行别的同步方法)，都是排队的，因为上的是同一把锁。</span><br></pre></td></tr></table></figure><p><img src="/.com//b1-1709083445234-40.png" alt="b1">!](.&#x2F;assets&#x2F;b1.png)</p><p><img src="/.com//b2-1709083445234-42.png" alt="b2">!](.&#x2F;assets&#x2F;b2.png)</p><h5 id="3、实现线程安全3-Lock锁"><a href="#3、实现线程安全3-Lock锁" class="headerlink" title="3、实现线程安全3-Lock锁"></a>3、实现线程安全3-Lock锁</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">同步代码块和同步方法都属于隐式锁，就是具体是怎么锁的我们不用管，只需把格式写好，它就自己锁，自己开，这就叫隐式锁。</span><br><span class="line">显式锁就是自己创建锁对象，自己上锁，自己解锁。</span><br><span class="line"></span><br><span class="line">在Ticket类里定义一个属性显式锁l</span><br><span class="line">private lock l = new ReentrantLock();</span><br><span class="line">在需要上锁的地方 l.lock()</span><br><span class="line">在需要解锁的地方 l.unlock()</span><br><span class="line"></span><br><span class="line">因为是new一个任务(Ticket)对象 所以用的是同一把显式锁l</span><br><span class="line"></span><br><span class="line">显式锁比隐式锁更好一些，更能体现程序员在控制 锁的概念</span><br><span class="line"></span><br><span class="line">while true里的代码如下，就是法1同步代码块的地方</span><br></pre></td></tr></table></figure><p><img src="/.com//b3-1709083445236-48.png" alt="b3">!](.&#x2F;assets&#x2F;b3.png)</p><h3 id="7、公平锁与非公平锁"><a href="#7、公平锁与非公平锁" class="headerlink" title="7、公平锁与非公平锁"></a>7、公平锁与非公平锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">公平锁</span><br><span class="line">排队 先来先到，A线程先来等，那么解锁之后A线程先执行并上锁</span><br><span class="line"></span><br><span class="line">非公平锁</span><br><span class="line">一旦解锁，大家一起抢</span><br><span class="line"></span><br><span class="line">Java里默认的，上述三种线程安全方法都是非公平锁。</span><br><span class="line"></span><br><span class="line">显式锁l里，fair参数为true，表示是公平锁，构造方法的实参：</span><br><span class="line">private lock l = new ReentrantLock(true)</span><br></pre></td></tr></table></figure><h3 id="8、线程死锁"><a href="#8、线程死锁" class="headerlink" title="8、线程死锁"></a>8、线程死锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">死锁  互相等待的一种僵局</span><br><span class="line"></span><br><span class="line">避免的话  在开发时，在任何有锁的方法(点播里的是给方法加synchronized修饰词)里尽量不要编写另一个带锁的方法</span><br></pre></td></tr></table></figure><h3 id="9、-悲观锁和乐观锁"><a href="#9、-悲观锁和乐观锁" class="headerlink" title="9、 悲观锁和乐观锁"></a>9、 悲观锁和乐观锁</h3><p><strong>synchronized和CAS的区别 :</strong></p><p><strong>相同点：</strong>在多线程情况下，都可以保证共享数据的安全性。</p><p><strong>不同点：</strong>synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每 次操作共享数据之前，都会上锁。（悲观锁）</p><p> cas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。</p><p> 如果别人修改过，那么我再次获取现在最新的值。</p><p> 如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁）</p><h3 id="10、生产者与消费者"><a href="#10、生产者与消费者" class="headerlink" title="10、生产者与消费者"></a>10、生产者与消费者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">食物类，为了让他在做菜时更容易出问题，设置name和taste之间sleep一会，执行设置name后，时间片被占，再次抢占到时间片时回来执行设置taste</span><br></pre></td></tr></table></figure><p><img src="/.com//c1-1709083445235-43.png" alt="c1">!](.&#x2F;assets&#x2F;c1.png)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">厨师   声明为线程，就做饭。</span><br></pre></td></tr></table></figure><p><img src="/.com//c2-1709083445235-46.png" alt="c2">!](.&#x2F;assets&#x2F;c2.png)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务员，因为厨师的run方法里的set方法sleep了100ms，所以这里也sleep一下。</span><br></pre></td></tr></table></figure><p><img src="/.com//c3-1709083445235-44.png" alt="c3">!](.&#x2F;assets&#x2F;c3.png)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main方法</span><br><span class="line">代码里写的是老干妈小米粥香辣味，运行结果是甜辣味。就说明出问题了，厨师刚生产设置了name，sleep 的时候，服务员线程把菜端走了，所以taste没有设置，还是之前的甜辣味。</span><br><span class="line">出现了两个线程进行协作时不协调的问题。</span><br></pre></td></tr></table></figure><p><img src="/.com//c4-1709083445235-45.png" alt="c4">!](.&#x2F;assets&#x2F;c4.png)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于这个问题，多数人认为可以给食物类的get set上锁，给方法加synchronized修饰词，都是用的this锁，所以厨师在做菜的时候，服务员不能端走，但厨师会一直回手掏，会出更大的问题，所以不能解决上述问题。</span><br></pre></td></tr></table></figure><p><img src="/.com//c5-1709083445235-47.png" alt="c5">!](.&#x2F;assets&#x2F;c5.png)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">厨师做饭时，服务员睡着，厨师做完饭，叫醒服务员，服务员去上菜然后厨师睡着，服务员上完菜把盘子端回来再把厨师叫醒，服务员睡着...</span><br><span class="line"></span><br><span class="line">可以在上锁后(synchronized)再加以设置标记实现。</span><br><span class="line">给Food类加一个private boolean flag = true</span><br><span class="line">假设true表示可以生产</span><br><span class="line">flag判完设置为FALSE，确保不会连续执行第二次，一次做饭，一次端盘子，notifyAll是唤醒当前处于等待的所有线程，然后自己等待。</span><br></pre></td></tr></table></figure><p><img src="/.com//c6-1709083445236-49.png" alt="c6">!](.&#x2F;assets&#x2F;c6.png)</p><p><img src="/.com//c7-1709083445236-51.png" alt="c7">!](.&#x2F;assets&#x2F;c7.png)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果   没有任何问题了</span><br></pre></td></tr></table></figure><p><img src="/.com//c8-1709083445236-50.png" alt="c8">!](.&#x2F;assets&#x2F;c8.png)</p><p>线程的六种状态</p><ul><li>New</li></ul><p>​刚被创建 尚未启动的线程处于此状态</p><ul><li>Runnable</li></ul><p>​Java虚拟机中执行的线程处于此状态</p><ul><li>Blocked</li></ul><p>​被阻塞等待监视器锁定的线程处于此状态</p><p>​线程安全里提过上锁的概念，多个线程从一起执行到排队执行，当处于排队的时候就处于Blocked状态，排完队进入Runnable状态</p><ul><li>Waiting</li></ul><p>​无限期等待另一个线程执行特定操作的线程处于此状态 比如没有指定休眠时间的休眠，一直睡，知道被唤醒则进入Runnable状态</p><ul><li>Timed_Waiting</li></ul><p>​无限期等待另一个线程执行最多指定等待时间的操作的线程处于此状态 可以不用等别人唤醒，毕竟是指定时间的，倒也可以被唤醒，醒了直接进入Runnable状态</p><ul><li>Terminated</li></ul><p>​已退出的线程处于此状态</p><p><img src="/.com//q1-1709083445237-52.png" alt="q1">!](.&#x2F;assets&#x2F;q1.png)</p><h3 id="11、线程池"><a href="#11、线程池" class="headerlink" title="11、线程池"></a>11、线程池</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建线程-&gt;创建任务-&gt;执行任务-&gt;销毁线程</span><br><span class="line">有时候创建任务和执行任务只占整个过程大概5%的时间，真正花时间的是创建线程和销毁线程。</span><br><span class="line"></span><br><span class="line">如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低 系统的效率，因为频繁创建线程和销毁线程需要时间. 线程池就是一个容纳多个线程的容器，池中的线程可以反复使用，省去了频繁创建线程对象的操作，节省了大量的时间和资源。</span><br><span class="line"></span><br><span class="line">合理设置线程池的长度也很有必要，依次领任务。如果是非定长线程池，见到任务来了没相应闲状态的线程，就会new一个Thread并且线程池长度+1了。既然能自动扩容也有自动清缓存，如果有多个线程一直处于闲，就销毁了。</span><br><span class="line"></span><br><span class="line">Java中自己主动使用线程池的还是少的，后端开发本来就是基于多线程的，已经有池缓存的概念了，不需要额外加线程池了。</span><br></pre></td></tr></table></figure><h5 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h5><ul><li>降低资源消耗</li><li>提高响应速度</li><li>提高线程的可管理性</li></ul><h3 id="12、volatitle关键字"><a href="#12、volatitle关键字" class="headerlink" title="12、volatitle关键字"></a>12、volatitle关键字</h3><p> 当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题</p><p> 1，堆内存是唯一的，每一个线程都有自己的线程栈。</p><p> 2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。</p><p> 3 ，在线程中，每一次使用是从变量的副本中获取的。</p><p><strong>Volatile关键字 :</strong> 强制线程每次在使用的时候，都会看一下共享区域最新的值</p><p><strong>Volatile解决：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;小路同学&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        t2.setName(<span class="string">&quot;小皮同学&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Money</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(Money.money == <span class="number">100000</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结婚基金已经不是十万了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Money.money = <span class="number">90000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>synchronized解决：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;小路同学&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        t2.setName(<span class="string">&quot;小皮同学&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.myvolatile2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Money</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.myvolatile2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span>  <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Money.lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Money.money != <span class="number">100000</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;结婚基金已经不是十万了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.myvolatile2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Money.lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Money.money = <span class="number">90000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、常用API"><a href="#八、常用API" class="headerlink" title="八、常用API"></a>八、常用API</h2><h3 id="1、String相关"><a href="#1、String相关" class="headerlink" title="1、String相关"></a>1、String相关</h3><h4 id="1、字符型常量和字符串常量的区别"><a href="#1、字符型常量和字符串常量的区别" class="headerlink" title="1、字符型常量和字符串常量的区别"></a>1、字符型常量和字符串常量的区别</h4><p>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符<br>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)<br>占内存大小：字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</p><h4 id="2、什么是字符串常量池？"><a href="#2、什么是字符串常量池？" class="headerlink" title="2、什么是字符串常量池？"></a>2、什么是字符串常量池？</h4><p>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p><h4 id="3、String-是最基本的数据类型吗？"><a href="#3、String-是最基本的数据类型吗？" class="headerlink" title="3、String 是最基本的数据类型吗？"></a>3、String 是最基本的数据类型吗？</h4><p>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p><p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars &#x3D; {‘你’,‘好’};</p><p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p><h4 id="4、String有哪些特性"><a href="#4、String有哪些特性" class="headerlink" title="4、String有哪些特性"></a>4、String有哪些特性</h4><p>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</p><p>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</p><p>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</p><h4 id="5、String为什么是不可变的吗？"><a href="#5、String为什么是不可变的吗？" class="headerlink" title="5、String为什么是不可变的吗？"></a>5、String为什么是不可变的吗？</h4><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p><p>&#x2F;** The value is used for character storage. *&#x2F;<br>private final char value[];</p><h4 id="6、String真的是不可变的吗？"><a href="#6、String真的是不可变的吗？" class="headerlink" title="6、String真的是不可变的吗？"></a>6、String真的是不可变的吗？</h4><p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</p><ol><li>String不可变但不代表引用不可以变</li></ol><p>String str &#x3D; “Hello”;<br>str &#x3D; str + “ World”;<br>System.out.println(“str&#x3D;” + str);<br>结果：</p><p>str&#x3D;Hello World<br>解析：</p><p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p><ol start="2"><li><p>通过反射是可以修改所谓的“不可变”对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符串&quot;Hello World&quot;， 并赋给引用s</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">// Hello World</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取String类中的value字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">valueFieldOfString</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">valueFieldOfString.setAccessible(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line"><span class="type">char</span>[] value = (<span class="type">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">value[<span class="number">5</span>] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">// Hello_World</span></span><br></pre></td></tr></table></figure></li></ol><p>结果：</p><p>s &#x3D; Hello World<br>s &#x3D; Hello_World<br>解析：</p><p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p><h4 id="7、是否可以继承-String-类"><a href="#7、是否可以继承-String-类" class="headerlink" title="7、是否可以继承 String 类"></a>7、是否可以继承 String 类</h4><p>String 类是 final 类，不可以被继承。</p><h4 id="8、String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#8、String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？"></a>8、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</h4><p>不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。</p><h4 id="9、String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#9、String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="9、String s &#x3D; new String(“xyz”);创建了几个字符串对象"></a>9、String s &#x3D; new String(“xyz”);创建了几个字符串对象</h4><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>; <span class="comment">//str1指向静态区</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">//str2指向堆上的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str2.equals(str4)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str4); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == <span class="string">&quot;hello&quot;</span>); <span class="comment">//false</span></span><br><span class="line">str2 = str1;</span><br><span class="line">System.out.println(str2 == <span class="string">&quot;hello&quot;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="10、如何将字符串反转？"><a href="#10、如何将字符串反转？" class="headerlink" title="10、如何将字符串反转？"></a>10、如何将字符串反转？</h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">stringBuffer. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">stringBuilder. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure><h4 id="11、数组有没有-length-方法？String-有没有-length-方法"><a href="#11、数组有没有-length-方法？String-有没有-length-方法" class="headerlink" title="11、数组有没有 length()方法？String 有没有 length()方法"></a>11、数组有没有 length()方法？String 有没有 length()方法</h4><p>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</p><h4 id="12、String-类的常用方法都有那些？"><a href="#12、String-类的常用方法都有那些？" class="headerlink" title="12、String 类的常用方法都有那些？"></a>12、String 类的常用方法都有那些？</h4><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p><h4 id="13、在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#13、在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="13、在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>13、在使用 HashMap 的时候，用 String 做 key 有什么好处？</h4><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p><h4 id="14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"><a href="#14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"></a>14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h4><p>可变性</p><p>String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p><p>线程安全性</p><p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p><p>性能</p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p>对于三者使用的总结</p><p>如果要操作少量的数据用 &#x3D; String</p><p>单线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuilder</p><p>多线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuffer</p><h3 id="2、Date相关"><a href="#2、Date相关" class="headerlink" title="2、Date相关"></a>2、Date相关</h3><h3 id="3、包装类相关"><a href="#3、包装类相关" class="headerlink" title="3、包装类相关"></a>3、包装类相关</h3><h4 id="1、自动装箱与拆箱"><a href="#1、自动装箱与拆箱" class="headerlink" title="1、自动装箱与拆箱"></a>1、自动装箱与拆箱</h4><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p><p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p><h4 id="2、int-和-Integer-有什么区别"><a href="#2、int-和-Integer-有什么区别" class="headerlink" title="2、int 和 Integer 有什么区别"></a>2、int 和 Integer 有什么区别</h4><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。</p><p>Java 为每个原始类型提供了包装类型：</p><p>原始类型: boolean，char，byte，short，int，long，float，double</p><p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p><h4 id="3、Integer-a-127-与-Integer-b-127相等吗？"><a href="#3、Integer-a-127-与-Integer-b-127相等吗？" class="headerlink" title="3、Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗？"></a>3、Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗？</h4><p>对于对象引用类型：&#x3D;&#x3D;比较的是对象的内存地址。<br>对于基本数据类型：&#x3D;&#x3D;比较的是值。</p><p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1&#x3D;&#x3D;b1的结果是false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    System.out.println(a == b); <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">    System.out.println(a == c); <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    System.out.println(b == c); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(a1 == b1); <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    System.out.println(a2 == b2); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
